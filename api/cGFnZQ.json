{"per_page":10,"total":2,"current":1,"data":[{"title":"new和malloc的区别","date":"2019-09-19T06:58:35.000Z","date_formatted":{"ll":"Sep 19, 2019","L":"09/19/2019","MM-DD":"09-19"},"excerpt":"<h2 id=\"1-申请的内存所在位置\">1. 申请的内存所在位置<a href=\"posts/new和malloc的区别#1-申请的内存所在位置\"></a></h2><p>　　new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。</p>\n<p>　　自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。</p>\n<p>　　那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。</p>","link":"posts/new和malloc的区别","tags":["C++"],"categories":["C++"]},{"title":"Linux--awk命令","date":"2019-09-18T12:00:37.000Z","date_formatted":{"ll":"Sep 18, 2019","L":"09/18/2019","MM-DD":"09-18"},"excerpt":"<h2 id=\"一：awk简介\">一：awk简介<a href=\"posts/Linux-awk命令#一：awk简介\"></a></h2><p>​        awk其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。实际上 AWK 的确拥有自己的语言： AWK 程序设计语言 ， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。</p>\n<p>​       awk 是一种很棒的语言，它适合文本处理和报表生成，其语法较为常见，借鉴了某些语言的一些精华，如 C 语言等。在 linux 系统日常处理工作中，发挥很重要的作用，掌握了 awk将会使你的工作变的高大上。 awk 是三剑客的老大，利剑出鞘，必会不同凡响。</p>","link":"posts/Linux-awk命令","tags":["Linux"],"categories":["awk"]},{"title":"编译器架构的王者LLVM——使用JIT引擎","date":"2019-09-11T12:15:43.000Z","date_formatted":{"ll":"Sep 11, 2019","L":"09/11/2019","MM-DD":"09-11"},"thumbnail":"/posts/编译器架构的王者LLVM——使用JIT引擎/c0c2f09d002c93057a08ccca749b0648.jpeg","excerpt":"<h1 id=\"使用JIT引擎\">使用JIT引擎<a href=\"posts/编译器架构的王者LLVM——使用JIT引擎#使用JIT引擎\"></a></h1><p>LLVM从设计之初就考虑了解释执行的功能,这非常其作为一款跨平台的中间字节码来使用,可以方便地跨平台运行。又具有编译型语言的优势，非常的方便。</p>\n<p>我们使用的LLVM3.6版，移除了原版JIT，改换成了新版的MCJIT，性格有了不小的提升，本文就MCJIT的使用和注意事项，进行简要的介绍。</p>","link":"posts/编译器架构的王者LLVM——使用JIT引擎","tags":["C++"],"categories":["编译器"]},{"title":"源码解读Linux的limits.conf文件","date":"2019-09-09T12:19:38.000Z","date_formatted":{"ll":"Sep 9, 2019","L":"09/09/2019","MM-DD":"09-09"},"thumbnail":"/posts/源码解读Linux的limits-conf文件/20190910105208.png","excerpt":"<p>目录 </p>\n<ol>\n<li><p>前言 1</p>\n</li>\n<li><p>PAM 2</p>\n</li>\n<li><p>pam_limits 2</p>\n</li>\n<li><p>limits.conf的由来 3</p>\n</li>\n<li><p>模块入口函数 4</p>\n</li>\n<li><p>解析limits.conf 6</p>\n</li>\n<li><p>生效limits.conf 7</p>\n</li>\n<li><p>systemctl和systemd 8</p>\n</li>\n<li><p>总结 10</p>\n</li>\n</ol>\n<p>附1：资源 11</p>\n<p>附2：编译ninja 11</p>\n<p>附3：使用meson编译systemd 11</p>\n<p>附4：安装Python-3.7.2 12</p>\n<p>附5：安装libcap 12</p>","link":"posts/源码解读Linux的limits-conf文件","tags":["Linux"],"categories":["Linux"]},{"title":"模版元编程应用","date":"2019-06-19T02:34:15.000Z","date_formatted":{"ll":"Jun 19, 2019","L":"06/19/2019","MM-DD":"06-19"},"thumbnail":"/posts/模版元编程应用/20190905201147.jpg","excerpt":"<h3 id=\"1-概述\">1.概述<a href=\"posts/模版元编程应用#1-概述\"></a></h3><p>　　关于C++11模板元的基本用法和常用技巧，在常规编程中可能很少遇到，那么C++11模版元编程用来解决什么实际问题呢，在实际工程中又该如何应用呢？本文将侧重介绍C++11模板的一些具体应用，向读者展示模版元编程的具体应用。</p>\n<p>　　我们将展示如何通过C++11模版元来实现function_traits、Vairant类型和泛型bind绑定器。function_traits侧重于如何萃取可调用对象的一些元信息，Variant则是一种能接受多种类型数据的“万能”类型，bind则是一个泛化的绑定器，下面来看看这些具体的例子。</p>","link":"posts/模版元编程应用","tags":["C++"],"categories":["C++"]},{"title":"C++中优雅的异步操作","date":"2019-06-14T06:21:26.000Z","date_formatted":{"ll":"Jun 14, 2019","L":"06/14/2019","MM-DD":"06-14"},"thumbnail":"/posts/C++中优雅的异步操作/0341e046a16c2b9a2762a35c3cde7dbf.jpg","excerpt":"<p>　　c++11中增加了线程，使得我们可以非常方便的创建线程，它的基本用法是这样的：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"function\">thread <span class=\"title\">t</span><span class=\"params\">(f, n + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">t.join();</span><br></pre></td></tr></table></div></figure>\n\n<p>　　但是线程毕竟是属于比较低层次的东西，有时候使用有些不便，比如我希望获取线程函数的返回结果的时候，我就不能直接通过thread.join()得到结果，这时就必须定义一个变量，在线程函数中去给这个变量赋值，然后join,最后得到结果，这个过程是比较繁琐的。c++11还提供了异步接口std::async，通过这个异步接口可以很方便的获取线程函数的执行结果。std::async会自动创建一个线程去调用线程函数，它返回一个std::future，这个future中存储了线程函数返回的结果，当我们需要线程函数的结果时，直接从future中获取，非常方便。但是我想说的是，<strong>其实std::async给我们提供的便利可不仅仅是这一点，它首先解耦了线程的创建和执行，使得我们可以在需要的时候获取异步操作的结果；其次它还提供了线程的创建策略（比如可以通过延迟加载的方式去创建线程）</strong>，使得我们可以以多种方式去创建线程。在介绍async具体用法以及为什么要用std::async代替线程的创建之前，我想先说一说std::future、std::promise和std::packaged_task。</p>","link":"posts/C++中优雅的异步操作","tags":["C++"],"categories":["C++"]},{"title":"Mutex介绍","date":"2019-06-14T03:00:47.000Z","date_formatted":{"ll":"Jun 14, 2019","L":"06/14/2019","MM-DD":"06-14"},"thumbnail":"/posts/Mutex介绍/20190905201210.jpg","excerpt":"<p>Mutex 又称互斥量，C++ 11中与 Mutex 相关的类（包括锁类型）和函数都声明在 <mutex> 头文件中，所以如果你需要使用 std::mutex，就必须包含 <mutex> 头文件。</mutex></mutex></p>\n<h3 id=\"头文件介绍\"><mutex> 头文件介绍</mutex><a href=\"posts/Mutex介绍#头文件介绍\"></a></h3><h4 id=\"Mutex-系列类-四种\">Mutex 系列类(四种)<a href=\"posts/Mutex介绍#Mutex-系列类-四种\"></a></h4><ul>\n<li><p>std::mutex，最基本的 Mutex 类。</p>\n</li>\n<li><p>std::recursive_mutex，递归 Mutex 类。</p>\n</li>\n<li><p>std::time_mutex，定时 Mutex 类。</p>\n</li>\n<li><p>std::recursive_timed_mutex，定时递归 Mutex 类。</p>\n</li>\n</ul>","link":"posts/Mutex介绍","tags":["C++"],"categories":["C++"]},{"title":"C++之Lambda研究","date":"2019-06-03T12:20:52.000Z","date_formatted":{"ll":"Jun 3, 2019","L":"06/03/2019","MM-DD":"06-03"},"excerpt":"<h1 id=\"1-前言\">1. 前言<a href=\"posts/Lambda#1-前言\"></a></h1><p>本文代码测试环境为“GCC-9.1.0”，有关编译器的安装请参考《<a href=\"https://blog.csdn.net/Aquester/article/details/89735466\" target=\"_blank\" rel=\"noopener\">安装GCC-8.3.0及其依赖</a>》，适用于“GCC-9.1.0”。</p>\n<p>本文试图揭露Lambda背后一面，以方便更好的理解和掌握Lambda。Lambda代码段实际为一个编译器生成的类的“operator ()”函数，编译器会为每一个Lambda函数生成一个匿名的类（在C++中，类和结构体实际一样，无本质区别，除了默认的访问控制）。</p>\n<p>对Lambda的最简单理解，是将它看作一个匿名类（或结构体），实际上也确实如此，编译器把Lambda编译成了匿名类。</p>","link":"posts/Lambda","tags":["C++"],"categories":["C++"]},{"title":"C++ 模板偏特化－来自STL的思考","date":"2019-05-31T06:29:52.000Z","date_formatted":{"ll":"May 31, 2019","L":"05/31/2019","MM-DD":"05-31"},"excerpt":"<p>之前学习STL时接触过一段时间的模板，模板是C++泛型编程编程的基础<br>STL从头到尾都是模板泛型编程，我觉得用的最巧妙的就是在traits萃取技巧时用到的模板偏特化</p>\n<hr>\n<ul>\n<li>先简要回顾一下模板吧，模板主要分为函数模板与类模板</li>\n</ul>\n<h2 id=\"函数模板\">函数模板<a href=\"posts/模板特化#函数模板\"></a></h2><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">T</span> <span class=\"title\">add</span>(<span class=\"title\">T</span> <span class=\"title\">a</span>, <span class=\"title\">T</span> <span class=\"title\">b</span>) &#123;</span> <span class=\"keyword\">return</span> a + b;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>, b = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; add(a + b) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>","link":"posts/模板特化","tags":["C++"],"categories":["C++"]},{"title":"C++中的万能引用和完美转发","date":"2019-05-29T02:05:19.000Z","date_formatted":{"ll":"May 29, 2019","L":"05/29/2019","MM-DD":"05-29"},"excerpt":"<h2 id=\"C-中的万能引用和完美转发\">C++中的万能引用和完美转发<a href=\"posts/完美转发#C-中的万能引用和完美转发\"></a></h2><ul>\n<li>阅读这篇博文需要了解C++中的左值（lvalue）和右值（rvalue）的概念，详情参见我的另外一篇博文：C++移动语义及拷贝优化</li>\n<li>万能引用和完美转发多涉及到模板的使用，如若不是自己写模板，则可不用关心</li>\n</ul>\n<h3 id=\"左值与右值的区分\">左值与右值的区分<a href=\"posts/完美转发#左值与右值的区分\"></a></h3><p>首先理解什么是右值引用（下面是百度百科给出的解释）：</p>\n<p>   右值引用（及其支持的Move语意和完美转发）是C++0x将要加入的最重大语言特性之一，这点从该特性的提案在C++ - State of the Evolution列表上高居榜首也可以看得出来。从实践角度讲，它能够完美解决C++中长久以来为人所诟病的临时对象效率问题。从语言本身讲，它健全了C++中的引用类型在左值右值方面的缺陷。从库设计者的角度讲，它给库设计者又带来了一把利器。从库使用者的角度讲，不动一兵一卒便可以获得“免费的”效率提升… 　　在标准C++语言中，临时量（术语为右值，因其出现在赋值表达式的右边）可以被传给函数，但只能被接受为const &amp;类型。这样函数便无法区分传给const &amp;的是真实的右值还是常规变量。而且，由于类型为const &amp;，函数也无法改变所传对象的值。C++0x将增加一种名为右值引用的新的引用类型，记作typename &amp;&amp;。这种类型可以被接受为非const值，从而允许改变其值。</p>","link":"posts/完美转发","tags":["C++"],"categories":["C++"]}]}