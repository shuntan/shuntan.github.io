{"per_page":10,"total":2,"current":1,"data":[{"title":"RetroArch上手教程","date":"2020-02-07T12:27:34.000Z","date_formatted":{"ll":"Feb 7, 2020","L":"02/07/2020","MM-DD":"02-07"},"excerpt":"<h2 id=\"简介\">简介<a title=\"#简介\" href=\"#简介\"></a></h2>\n<blockquote>\n<p>RetroArch可以在Windows，Mac OS X和Linux等常用平台上运行，但它可以单独支持它，因此可以支持更多平台。</p>\n<p>我们支持甚至Microsoft和Apple本身都不支持的操作系统，例如PowerPC Mac上的macOS X，以及早于Windows 95的Windows OS上都可以使用RetroArch。</p>\n<p>最重要的是，RetroArch还可以在适用于平板电脑和手机的iOS和Android以及PS2，PS3，PSP，PS Vita，Wii，Wii U，2DS，3DS，Switch等游戏机上运行！</p>\n</blockquote>","link":"posts/RetroArch上手教程"},{"title":"巫师三干货收藏","date":"2020-01-23T14:35:55.000Z","date_formatted":{"ll":"Jan 23, 2020","L":"01/23/2020","MM-DD":"01-23"},"thumbnail":"/posts/巫师三干货收藏/20200125113805.jpg","excerpt":"<blockquote class=\"blockquote-center\"><p><strong>The wither 3</strong>：萝卜是狩魔猎人世界中最强大的生物。它可以瞬间移动到杰洛特的身边，并且不受任何魔法的影响。没有人能伤到萝卜，当萝卜受到攻击时，它会愤怒的抬起它那粗壮的后腿进行反击。在堕入悬崖时，萝卜会使用瞬间移动逃脱，并且在世界上消失，根本找不到一丝踪迹。而当杰洛特再次召唤萝卜时 萝卜会从某个地方突然蹿出来 慢慢悠悠的走向杰洛特。。<br>\n　　“要说萝卜有什么不足的话，大概是它不会打昆特牌吧”——利维亚的杰洛特</p>\n</blockquote>","link":"posts/巫师三干货收藏","tags":["巫师3"]},{"title":"new和malloc的区别","date":"2019-09-19T06:58:35.000Z","date_formatted":{"ll":"Sep 19, 2019","L":"09/19/2019","MM-DD":"09-19"},"excerpt":"<h2 id=\"1.-申请的内存所在位置\">1. 申请的内存所在位置<a title=\"#1.-申请的内存所在位置\" href=\"#1.-申请的内存所在位置\"></a></h2>\n<p>new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。</p>\n<p>自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。</p>\n<p>那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。</p>","link":"posts/new和malloc的区别","tags":["C++"],"categories":["C++"]},{"title":"Linux--awk命令","date":"2019-09-18T12:00:37.000Z","date_formatted":{"ll":"Sep 18, 2019","L":"09/18/2019","MM-DD":"09-18"},"excerpt":"<h2 id=\"一：awk简介\">一：awk简介<a title=\"#一：awk简介\" href=\"#一：awk简介\"></a></h2>\n<p>​        awk其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。实际上 AWK 的确拥有自己的语言： AWK 程序设计语言 ， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。</p>\n<p>​       awk 是一种很棒的语言，它适合文本处理和报表生成，其语法较为常见，借鉴了某些语言的一些精华，如 C 语言等。在 linux 系统日常处理工作中，发挥很重要的作用，掌握了 awk将会使你的工作变的高大上。 awk 是三剑客的老大，利剑出鞘，必会不同凡响。</p>","link":"posts/Linux-awk命令","tags":["Linux"],"categories":["awk"]},{"title":"编译器架构的王者LLVM——使用JIT引擎","date":"2019-09-11T12:15:43.000Z","date_formatted":{"ll":"Sep 11, 2019","L":"09/11/2019","MM-DD":"09-11"},"thumbnail":"/posts/编译器架构的王者LLVM——使用JIT引擎/c0c2f09d002c93057a08ccca749b0648.jpeg","excerpt":"<h1 id=\"使用jit引擎\">使用JIT引擎<a title=\"#使用jit引擎\" href=\"#使用jit引擎\"></a></h1>\n<p>LLVM从设计之初就考虑了解释执行的功能,这非常其作为一款跨平台的中间字节码来使用,可以方便地跨平台运行。又具有编译型语言的优势，非常的方便。</p>\n<p>我们使用的LLVM3.6版，移除了原版JIT，改换成了新版的MCJIT，性格有了不小的提升，本文就MCJIT的使用和注意事项，进行简要的介绍。</p>","link":"posts/编译器架构的王者LLVM——使用JIT引擎","tags":["C++"],"categories":["编译器"]},{"title":"源码解读Linux的limits.conf文件","date":"2019-09-09T12:19:38.000Z","date_formatted":{"ll":"Sep 9, 2019","L":"09/09/2019","MM-DD":"09-09"},"thumbnail":"/posts/源码解读Linux的limits-conf文件/20190910105208.png","excerpt":"<h1 id=\"前言\">前言<a title=\"#前言\" href=\"#前言\"></a></h1>\n<p>本文不一定适合比较老版本的Linux，如果只关心使用，请直接看“总结”，本文主要针对CentOS，其它Linux发行版本类似，但细节可能有出入，比如重启服务可能不是用systemctl，而是service等。</p>\n<p>当需要调整一个进程可打开的最多文件数或SOCKET连接数等，以CentOS为例，通常的做法是修改文件/etc/security/limits.conf，比如将最多可打开数调整为10万：</p>","link":"posts/源码解读Linux的limits-conf文件","tags":["Linux"],"categories":["Linux"]},{"title":"模版元编程应用","date":"2019-06-19T02:34:15.000Z","date_formatted":{"ll":"Jun 19, 2019","L":"06/19/2019","MM-DD":"06-19"},"thumbnail":"/posts/模版元编程应用/20190905201147.jpg","excerpt":"<h3 id=\"1.概述\">1.概述<a title=\"#1.概述\" href=\"#1.概述\"></a></h3>\n<p>关于C<ins>11模板元的基本用法和常用技巧，在常规编程中可能很少遇到，那么C</ins>11模版元编程用来解决什么实际问题呢，在实际工程中又该如何应用呢？本文将侧重介绍C++11模板的一些具体应用，向读者展示模版元编程的具体应用。</p>","link":"posts/模版元编程应用","tags":["C++"],"categories":["C++"]},{"title":"C++中优雅的异步操作","date":"2019-06-14T06:21:26.000Z","date_formatted":{"ll":"Jun 14, 2019","L":"06/14/2019","MM-DD":"06-14"},"thumbnail":"/posts/C++中优雅的异步操作/0341e046a16c2b9a2762a35c3cde7dbf.jpg","excerpt":"<p>c++11中增加了线程，使得我们可以非常方便的创建线程，它的基本用法是这样的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"function\">thread <span class=\"title\">t</span><span class=\"params\">(f, n + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">t.join();</span><br></pre></td></tr></table></figure>","link":"posts/C++中优雅的异步操作","tags":["C++"],"categories":["C++"]},{"title":"Mutex介绍","date":"2019-06-14T03:00:47.000Z","date_formatted":{"ll":"Jun 14, 2019","L":"06/14/2019","MM-DD":"06-14"},"thumbnail":"/posts/Mutex介绍/20190905201210.jpg","excerpt":"<p>Mutex 又称互斥量，C++ 11中与 Mutex 相关的类（包括锁类型）和函数都声明在 <mutex> 头文件中，所以如果你需要使用 std::mutex，就必须包含 <mutex> 头文件。</p>","link":"posts/Mutex介绍","tags":["C++"],"categories":["C++"]},{"title":"C++之Lambda研究","date":"2019-06-03T12:20:52.000Z","date_formatted":{"ll":"Jun 3, 2019","L":"06/03/2019","MM-DD":"06-03"},"excerpt":"<h1 id=\"1. 前言\">1. 前言<a title=\"#1. 前言\" href=\"#1. 前言\"></a></h1>\n<p>本文代码测试环境为“GCC-9.1.0”，有关编译器的安装请参考《<a href=\"https://blog.csdn.net/Aquester/article/details/89735466\" target=\"_blank\">安装GCC-8.3.0及其依赖</a>》，适用于“GCC-9.1.0”。</p>\n<p>本文试图揭露Lambda背后一面，以方便更好的理解和掌握Lambda。Lambda代码段实际为一个编译器生成的类的“operator ()”函数，编译器会为每一个Lambda函数生成一个匿名的类（在C++中，类和结构体实际一样，无本质区别，除了默认的访问控制）。</p>\n<p>对Lambda的最简单理解，是将它看作一个匿名类（或结构体），实际上也确实如此，编译器把Lambda编译成了匿名类。</p>","link":"posts/Lambda","tags":["C++"],"categories":["C++"]}]}