{"title":"C++中的万能引用和完美转发","date":"2019-05-29T02:05:19.000Z","date_formatted":{"ll":"May 29, 2019","L":"05/29/2019","MM-DD":"05-29"},"link":"posts/完美转发","comments":true,"tags":["C++"],"categories":["C++"],"updated":"2019-09-28T02:27:03.644Z","content":"<h2 id=\"C-中的万能引用和完美转发\">C++中的万能引用和完美转发<a href=\"posts/完美转发#C-中的万能引用和完美转发\"></a></h2><ul>\n<li>阅读这篇博文需要了解C++中的左值（lvalue）和右值（rvalue）的概念，详情参见我的另外一篇博文：C++移动语义及拷贝优化</li>\n<li>万能引用和完美转发多涉及到模板的使用，如若不是自己写模板，则可不用关心</li>\n</ul>\n<h3 id=\"左值与右值的区分\">左值与右值的区分<a href=\"posts/完美转发#左值与右值的区分\"></a></h3><p>首先理解什么是右值引用（下面是百度百科给出的解释）：</p>\n<p>   右值引用（及其支持的Move语意和完美转发）是C++0x将要加入的最重大语言特性之一，这点从该特性的提案在C++ - State of the Evolution列表上高居榜首也可以看得出来。从实践角度讲，它能够完美解决C++中长久以来为人所诟病的临时对象效率问题。从语言本身讲，它健全了C++中的引用类型在左值右值方面的缺陷。从库设计者的角度讲，它给库设计者又带来了一把利器。从库使用者的角度讲，不动一兵一卒便可以获得“免费的”效率提升… 　　在标准C++语言中，临时量（术语为右值，因其出现在赋值表达式的右边）可以被传给函数，但只能被接受为const &amp;类型。这样函数便无法区分传给const &amp;的是真实的右值还是常规变量。而且，由于类型为const &amp;，函数也无法改变所传对象的值。C++0x将增加一种名为右值引用的新的引用类型，记作typename &amp;&amp;。这种类型可以被接受为非const值，从而允许改变其值。</p>\n<a id=\"more\"></a>\n\n<p><strong>区分左值与右值：</strong></p>\n<p> C++ 11中引入的一个非常重要的概念就是右值引用。理解右值引用是学习“移动语义”（move semantics）的基础。而要理解右值引用，就必须先区分左值与右值。<br>       对左值和右值的一个最常见的误解是：等号左边的就是左值，等号右边的就是右值。</p>\n<p><strong>什么是左值引用：</strong><br>       区分清楚了左值与右值，我们再来看看左值引用。左值引用根据其修饰符的不同，可以分为非常量左值引用(<strong>eg.1 double &amp;r =i;</strong>)和常量左值引用(<strong>eg.1 const double &amp;r =i;</strong>)。<br>       非常量左值引用只能绑定到非常量左值，不能绑定到常量左值、非常量右值和常量右值。如果允许绑定到常量左值和常量右值，则非常量左值引用可以用于修改常量左值和常量右值，这明显违反了其常量的含义(<strong>eg.1中就是出现了非常量左值引用绑定到常量右值的情况</strong>)。如果允许绑定到非常量右值，则会导致非常危险的情况出现，因为非常量右值是一个临时对象，非常量左值引用可能会使用一个已经被销毁了的临时对象。<br>       <strong>常量左值引用可以绑定到所有类型的值，包括非常量左值、常量左值、非常量右值和常量右值。</strong></p>\n<p>如果同时包含左值和右值的函数重载，右值会优先匹配右值的重载版本，其次匹配常量左值重载版本。</p>\n<h3 id=\"万能引用（Universal-Reference）\">万能引用（Universal Reference）<a href=\"posts/完美转发#万能引用（Universal-Reference）\"></a></h3><p>首先，我们来看一个例子：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(T&amp; param)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; param &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num = <span class=\"number\">2019</span>;</span><br><span class=\"line\">    func(num);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>这样例子的编译输出都没有什么问题，但是如果我们修改成下面的调用方式呢？</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> main() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"number\">2019</span>)</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span><span class=\"comment\">;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>则会得到一个大大的编译错误。因为上面的模板函数只能接受左值或者左值引用（左值一般是有名字的变量，可以取到地址的），我们当然可以重载一个接受右值的模板函数，如下也可以达到效果。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(T&amp; param)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"传入的是左值\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"传入的是右值\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num = <span class=\"number\">2019</span>;</span><br><span class=\"line\">    func(num);</span><br><span class=\"line\">    func(<span class=\"number\">2019</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">传入的是左值</span><br><span class=\"line\">传入的是右值</span><br></pre></td></tr></table></div></figure>\n\n<p>第一次函数调用的是左值得版本，第二次函数调用的是右值版本。但是，有没有办法只写一个模板函数即可以接收左值又可以接收右值呢？</p>\n<p>​     <strong>C++ 11中有万能引用（Universal Reference）的概念：使用T&amp;&amp;类型的形参既能绑定右值，又能绑定左值。只有在模版中才生效，普通函数中左值引用（非常量）只接受左值，右值引用只接受右值，const 左值引用可以接受任何值，const 右值引用能接受任何右值，推导后的模版也同理。</strong></p>\n<p>但是注意了：<strong>只有发生类型推导的时候，T&amp;&amp;才表示万能引用；</strong> 否则，表示右值引用。</p>\n<p>所以，上面的案例我们可以修改为：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">void <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(T&amp;&amp; param)</span> &#123;</span></span><br><span class=\"line\">    cout &lt;&lt; param &lt;&lt; endl<span class=\"comment\">;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">int</span> main() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> num = <span class=\"number\">2019</span><span class=\"comment\">;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(num)</span>;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"number\">2019</span>)</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span><span class=\"comment\">;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"引用折叠（Universal-Collapse）\">引用折叠（Universal Collapse）<a href=\"posts/完美转发#引用折叠（Universal-Collapse）\"></a></h2><p>万能引用说完了，接着来聊引用折叠（Univers Collapse），因为完美转发（Perfect Forwarding）的概念涉及引用折叠。一个模板函数，根据定义的形参和传入的实参的类型，我们可以有下面四中组合：</p>\n<ul>\n<li>左值-左值 T&amp; &amp;        # 函数定义的形参类型是左值引用，传入的实参是左值引用</li>\n<li>左值-右值 T&amp; &amp;&amp;      # 函数定义的形参类型是左值引用，传入的实参是右值引用（必须const修饰）</li>\n<li>右值-左值 T&amp;&amp; &amp;      # 函数定义的形参类型是右值引用，传入的实参是左值引用</li>\n<li>右值-右值 T&amp;&amp; &amp;&amp;    # 函数定义的形参类型是右值引用，传入的实参是右值引用</li>\n</ul>\n<p>但是C++中不允许对引用再进行引用，对于上述情况的处理有如下的规则：</p>\n<p>所有的折叠引用最终都代表一个引用，要么是左值引用，要么是右值引用。规则是：如果任一引用为左值引用，则结果为左值引用。否则（即两个都是右值引用），结果为右值引用。</p>\n<p>即就是前面三种情况代表的都是左值引用，而第四种代表的右值引用。</p>\n<h2 id=\"完美转发（Perfect-Forwarding）\">完美转发（Perfect Forwarding）<a href=\"posts/完美转发#完美转发（Perfect-Forwarding）\"></a></h2><p>下面接着说完美转发（Perfect Forwarding），首先，看个例子：</p>\n<p>🌰[栗子]<br>要了解完美转发，先得清楚模板T的<strong>推导过程</strong>，<span class=\"label success\">在没有偏特化的模版前提下，模板总是根据最匹配的规则来推导参数，左值引用template函数推导出来总是左值引用函数，右值引用template函数能推导出左值引用和右值引用函数</span>，可以根据下面的例子来看出推导过程。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//auto is_lval = std::is_lvalue_reference&lt;T&gt;::value;</span></span><br><span class=\"line\">    <span class=\"comment\">//auto is_rval  = std::is_rvalue_reference&lt;T&gt;::value;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">std</span>::is_same&lt;T, <span class=\"keyword\">int</span>&gt;::value) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"'T' is type[int]\"</span>  &lt;&lt; <span class=\"string\">\" arg:\"</span> &lt;&lt; arg &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">std</span>::is_same&lt;T, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&gt;::value) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"'T' is type[const int]\"</span> &lt;&lt; <span class=\"string\">\" arg:\"</span> &lt;&lt; arg &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">std</span>::is_same&lt;T, <span class=\"keyword\">int</span>&amp;&gt;::value) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"'T' is type[int&amp;]\"</span> &lt;&lt; <span class=\"string\">\" arg:\"</span> &lt;&lt; arg &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">std</span>::is_same&lt;T, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;&gt;::value) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"'T' is type[const int&amp;]\"</span> &lt;&lt; <span class=\"string\">\" arg:\"</span> &lt;&lt; arg &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"-----------------\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; b = <span class=\"number\">2</span>;</span><br><span class=\"line\">  func(a);  <span class=\"comment\">//传入左值引用 T =&gt; int&amp;</span></span><br><span class=\"line\">  func(b);  <span class=\"comment\">//传入常量左值引用 T =&gt; const int&amp;</span></span><br><span class=\"line\">  func(<span class=\"number\">3</span>);  <span class=\"comment\">//传入右值引用 T =&gt; int</span></span><br><span class=\"line\">  func(<span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(a));        <span class=\"comment\">//传入转换后的右值引用 T =&gt; int</span></span><br><span class=\"line\">  func(<span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&amp;&gt;(a));       <span class=\"comment\">//传入转换后的左值引用 T =&gt; int&amp;</span></span><br><span class=\"line\">  func(<span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;&amp;&gt;(a));<span class=\"comment\">//传入转换后的常量右值 T =&gt; const int</span></span><br><span class=\"line\">  func&lt;<span class=\"keyword\">int</span>&gt;(a);  <span class=\"comment\">//错误❌ 显示指定模版形参，推导后只能接受右值引用，而a是左值</span></span><br><span class=\"line\">  func&lt;<span class=\"keyword\">int</span>&amp;&gt;(a); <span class=\"comment\">//示指定模版形参，推导后只可接受左值引用，a是左值</span></span><br><span class=\"line\">  func&lt;<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&gt;(<span class=\"number\">1</span>); <span class=\"comment\">//示指定模版形参，推导后只可接受右值，且不能修改，1是右值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>输出结果为：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$g++ -std=<span class=\"keyword\">c</span>++<span class=\"number\">11</span> -<span class=\"keyword\">o</span> main *.cpp</span><br><span class=\"line\">$main</span><br><span class=\"line\"><span class=\"string\">'T'</span> <span class=\"keyword\">is</span> <span class=\"built_in\">type</span>[<span class=\"keyword\">int</span>&amp;] <span class=\"keyword\">ar</span><span class=\"variable\">g:1</span></span><br><span class=\"line\">-----------------</span><br><span class=\"line\"><span class=\"string\">'T'</span> <span class=\"keyword\">is</span> <span class=\"built_in\">type</span>[const <span class=\"keyword\">int</span>&amp;] <span class=\"keyword\">ar</span><span class=\"variable\">g:2</span></span><br><span class=\"line\">-----------------</span><br><span class=\"line\"><span class=\"string\">'T'</span> <span class=\"keyword\">is</span> <span class=\"built_in\">type</span>[<span class=\"keyword\">int</span>] <span class=\"keyword\">ar</span><span class=\"variable\">g:3</span></span><br><span class=\"line\">-----------------</span><br><span class=\"line\"><span class=\"string\">'T'</span> <span class=\"keyword\">is</span> <span class=\"built_in\">type</span>[<span class=\"keyword\">int</span>] <span class=\"keyword\">ar</span><span class=\"variable\">g:1</span></span><br><span class=\"line\">-----------------</span><br><span class=\"line\"><span class=\"string\">'T'</span> <span class=\"keyword\">is</span> <span class=\"built_in\">type</span>[<span class=\"keyword\">int</span>&amp;] <span class=\"keyword\">ar</span><span class=\"variable\">g:1</span></span><br><span class=\"line\">-----------------</span><br><span class=\"line\"><span class=\"string\">'T'</span> <span class=\"keyword\">is</span> <span class=\"built_in\">type</span>[const <span class=\"keyword\">int</span>] <span class=\"keyword\">ar</span><span class=\"variable\">g:1</span></span><br><span class=\"line\">-----------------</span><br><span class=\"line\"><span class=\"string\">'T'</span> <span class=\"keyword\">is</span> <span class=\"built_in\">type</span>[<span class=\"keyword\">int</span>&amp;] <span class=\"keyword\">ar</span><span class=\"variable\">g:1</span></span><br><span class=\"line\">-----------------</span><br><span class=\"line\"><span class=\"string\">'T'</span> <span class=\"keyword\">is</span> <span class=\"built_in\">type</span>[const <span class=\"keyword\">int</span>] <span class=\"keyword\">ar</span><span class=\"variable\">g:1</span></span><br><span class=\"line\">-----------------</span><br></pre></td></tr></table></div></figure>\n\n<p>错误信息：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main.cpp:6:6: note:   template argument deduction/substitution failed:</span><br><span class=\"line\">main.cpp:35:14: note:   cannot convert ‘a’ (type ‘int’) <span class=\"keyword\">to</span><span class=\"built_in\"> type </span>‘int&amp;&amp;’</span><br><span class=\"line\">   func&lt;int&gt;(a);</span><br></pre></td></tr></table></div></figure>\n\n<span class=\"label success\">根据C++ Primer中文版(第五版) 18章第2节模板实参推断</span>\n<p><strong>Note:如果显示推导模版T的类型，可能会导致编译不过，因为会导致推到出来的函数实参和形参引用类型不一致</strong></p>\n<h2 id=\"std-forward\">std::forward()<a href=\"posts/完美转发#std-forward\"></a></h2><h3 id=\"std-forward完美转发解析\">std::forward完美转发解析<a href=\"posts/完美转发#std-forward完美转发解析\"></a></h3><blockquote>\n<p>完美转发实现了参数在传递过程中保持其值属性的功能，即若是左值，则传递之后仍然是左值，若是右值，则传递之后仍然是右值。</p>\n<p>C++11 lets us perform perfect forwarding, which means that we can forward the parameters passed to a function template to another function call inside it without losing their own qualifiers (const-ref, ref, value, rvalue, etc.).</p>\n</blockquote>\n<h3 id=\"std-forward-解析\">std::forward()解析<a href=\"posts/完美转发#std-forward-解析\"></a></h3><p>std::forward只有在它的参数绑定到一个右值上的时候，它才转换它的参数到一个右值。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> member;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">    Foo(T&amp;&amp; member): member&#123;<span class=\"built_in\">std</span>::forward&lt;T&gt;(member)&#125; &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p><strong>对于Foo函数中member变量，无论之前是什么，都变为左值了，因为他有名字了</strong>:smile:</p>\n<p>传递一个lvalue或者传递一个const lvaue</p>\n<ul>\n<li>传递一个lvalue，模板推导之后 <code>T = std::string&amp;</code></li>\n<li>传递一个const lvaue, 模板推导之后<code>T = const std::string&amp;</code></li>\n<li><code>T&amp; &amp;&amp;</code>将折叠为T&amp;，即<code>std::string&amp; &amp;&amp; 折叠为 std::string&amp;</code></li>\n<li>最终函数为: <code>Foo(string&amp; member): member{std::forward&lt;string&amp;&gt;(member)} {}</code></li>\n<li>std::forward&lt;string&amp;&gt;(member)将返回一个左值，最终调用拷贝构造函数</li>\n</ul>\n<p>传递一个rvalue</p>\n<ul>\n<li>传递一个rvalue，模板推导之后 <code>T = std::string</code></li>\n<li>最终函数为: <code>Foo(string&amp;&amp; member): member{std::forward&lt;string&gt;(member)} {}</code></li>\n<li>std::forward<string>(member) 将返回一个右值，最终调用移动构造函数；</string></li>\n</ul>\n<p>std::move和std::forward本质都是转换。std::move执行到右值的无条件转换。std::forward只有在它的参数绑定到一个右值上的时候，才转换它的参数到一个右值。</p>\n<p>std::move没有move任何东西，std::forward没有转发任何东西。在运行期，它们没有做任何事情。它们没有产生需要执行的代码，一byte都没有。</p>\n<h2 id=\"std-move\">std::move<a href=\"posts/完美转发#std-move\"></a></h2><h3 id=\"std-move的使用\">std::move的使用<a href=\"posts/完美转发#std-move的使用\"></a></h3><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> member;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Copy member.</span></span><br><span class=\"line\">    Foo(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; m): member(m) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Move member.</span></span><br><span class=\"line\">    Foo(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp;&amp; m): member(<span class=\"built_in\">std</span>::move(m)) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p>上述<code>Foo(std::string&amp;&amp; member)</code>中的member是rvalue reference，但是member却是一个左值lvalue，因此在初始化列表中需要使用std::move将其转换成rvalue。</p>\n<h3 id=\"std-move-解析\">std::move()解析<a href=\"posts/完美转发#std-move-解析\"></a></h3><p>标准库中move的定义如下：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">typename</span> remove_reference&lt;T&gt;::<span class=\"function\">type &amp;&amp; <span class=\"title\">move</span><span class=\"params\">(T&amp;&amp; t)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">typename</span> remove_reference&lt;T&gt;::type &amp;&amp;&gt;(t);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>move函数的参数T&amp;&amp;是一个指向模板类型参数的右值引用【规则2】，通过引用折叠，此参数可以和任何类型的实参匹配，因此move既可以传递一个左值，也可以传递一个右值；</li>\n<li>std::move(string(“hello”))调用解析：<ul>\n<li>首先，根据模板推断规则，确地T的类型为string;</li>\n<li>typename remove_reference<t>::type &amp;&amp; 的结果为 string &amp;&amp;;</t></li>\n<li>move函数的参数类型为string&amp;&amp;;</li>\n<li>static_cast&lt;string &amp;&amp;&gt;(t)，t已经是string&amp;&amp;，于是类型转换什么都不做，返回string &amp;&amp;;</li>\n</ul>\n</li>\n<li>string s1(“hello”); std::move(s1); 调用解析：<ul>\n<li>首先，根据模板推断规则，确定T的类型为string&amp;;</li>\n<li>typename remove_reference<t>::type &amp;&amp; 的结果为 string&amp;</t></li>\n<li>move函数的参数类型为string&amp; &amp;&amp;，引用折叠之后为string&amp;;</li>\n<li>static_cast&lt;string &amp;&amp;&gt;(t)，t是string&amp;，经过static_cast之后转换为string&amp;&amp;, 返回string &amp;&amp;;</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>从move的定义可以看出，move自身除了做一些参数的推断之外，返回右值引用本质上还是靠static_cast&lt;T&amp;&amp;&gt;完成的。</p>\n</blockquote>\n<p>因此下面两个调用是等价的，std::move就是个语法糖。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span>&amp;&amp; a)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">6</span>;</span><br><span class=\"line\">func(<span class=\"built_in\">std</span>::move(a));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\">func(<span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&amp;&amp;&gt;(b));</span><br></pre></td></tr></table></div></figure>\n\n<p>std::move执行到右值的无条件转换。就其本身而言，它没有move任何东西。</p>\n<h2 id=\"std-move-和std-forward-对比\">std::move()和std::forward()对比<a href=\"posts/完美转发#std-move-和std-forward-对比\"></a></h2><ul>\n<li>std::move执行到右值的无条件转换。就其本身而言，它没有move任何东西。</li>\n<li>std::forward只有在它的参数绑定到一个右值上的时候，它才转换它的参数到一个右值。</li>\n<li>std::move和std::forward只不过就是执行类型转换的两个函数；std::move没有move任何东西，std::forward没有转发任何东西。在运行期，它们没有做任何事情。它们没有产生需要执行的代码，一byte都没有。</li>\n<li>std::forward<t>()不仅可以保持左值或者右值不变，同时还可以保持const、Lreference、Rreference、validate等属性不变；</t></li>\n</ul>\n","prev":{"title":"C++ 模板偏特化－来自STL的思考","link":"posts/模板特化"},"next":{"title":"从4行代码看右值引用","link":"posts/右值引用"},"plink":"https://shuntan.github.io/posts/完美转发/","toc":[{"title":"C++中的万能引用和完美转发","id":"C-中的万能引用和完美转发","index":"1","children":[{"title":"左值与右值的区分","id":"左值与右值的区分","index":"1.1"},{"title":"万能引用（Universal Reference）","id":"万能引用（Universal-Reference）","index":"1.2"}]},{"title":"引用折叠（Universal Collapse）","id":"引用折叠（Universal-Collapse）","index":"2"},{"title":"完美转发（Perfect Forwarding）","id":"完美转发（Perfect-Forwarding）","index":"3"},{"title":"std::forward()","id":"std-forward","index":"4","children":[{"title":"std::forward完美转发解析","id":"std-forward完美转发解析","index":"4.1"},{"title":"std::forward()解析","id":"std-forward-解析","index":"4.2"}]},{"title":"std::move","id":"std-move","index":"5","children":[{"title":"std::move的使用","id":"std-move的使用","index":"5.1"},{"title":"std::move()解析","id":"std-move-解析","index":"5.2"}]},{"title":"std::move()和std::forward()对比","id":"std-move-和std-forward-对比","index":"6"}],"reward":true,"copyright":{"author":"Shawntan","link":"<a href=\"https://shuntan.github.io/posts/完美转发/\" title=\"C++中的万能引用和完美转发\">https://shuntan.github.io/posts/完美转发/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow noopener\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","published":"May 29, 2019","updated":"September 28, 2019"}}