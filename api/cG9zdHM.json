{"per_page":10,"total":2,"current":1,"data":[{"title":"模版元编程应用","date":"2019-06-19T02:34:15.000Z","thumbnail":null,"excerpt":"<h3 id=\"1-概述\">1.概述<a href=\"post/模版元编程应用#1-概述\"></a></h3>\n<p>关于C<ins>11模板元的基本用法和常用技巧，在常规编程中可能很少遇到，那么C</ins>11模版元编程用来解决什么实际问题呢，在实际工程中又该如何应用呢？本文将侧重介绍C++11模板的一些具体应用，向读者展示模版元编程的具体应用。</p>\n<p>我们将展示如何通过C++11模版元来实现function_traits、Vairant类型和泛型bind绑定器。function_traits侧重于如何萃取可调用对象的一些元信息，Variant则是一种能接受多种类型数据的“万能”类型，bind则是一个泛化的绑定器，下面来看看这些具体的例子。</p>","link":"post/模版元编程应用","tags":["C++"],"categories":["C++"]},{"title":"C++中优雅的异步操作","date":"2019-06-14T06:21:26.000Z","thumbnail":null,"excerpt":"<p>c++11中增加了线程，使得我们可以非常方便的创建线程，它的基本用法是这样的：</p>\n<figure class=\"highlight c++\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"function\">thread <span class=\"title\">t</span><span class=\"params\">(f, n + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">t.join();</span><br></pre></td></tr></table></div></figure>\n<p>但是线程毕竟是属于比较低层次的东西，有时候使用有些不便，比如我希望获取线程函数的返回结果的时候，我就不能直接通过thread.join()得到结果，这时就必须定义一个变量，在线程函数中去给这个变量赋值，然后join,最后得到结果，这个过程是比较繁琐的。c++11还提供了异步接口std::async，通过这个异步接口可以很方便的获取线程函数的执行结果。std::async会自动创建一个线程去调用线程函数，它返回一个std::future，这个future中存储了线程函数返回的结果，当我们需要线程函数的结果时，直接从future中获取，非常方便。但是我想说的是，<strong>其实std::async给我们提供的便利可不仅仅是这一点，它首先解耦了线程的创建和执行，使得我们可以在需要的时候获取异步操作的结果；其次它还提供了线程的创建策略（比如可以通过延迟加载的方式去创建线程）</strong>，使得我们可以以多种方式去创建线程。在介绍async具体用法以及为什么要用std::async代替线程的创建之前，我想先说一说std::future、std::promise和std::packaged_task。</p>","link":"post/C++中优雅的异步操作","tags":["C++"],"categories":["C++"]},{"title":"mutex头文件介绍","date":"2019-06-14T03:00:47.000Z","thumbnail":null,"excerpt":"<p>Mutex 又称互斥量，C++ 11中与 Mutex 相关的类（包括锁类型）和函数都声明在 <mutex> 头文件中，所以如果你需要使用 std::mutex，就必须包含 <mutex> 头文件。</mutex></mutex></p>\n<h3 id=\"mutex-头文件介绍\"><mutex> 头文件介绍</mutex><a href=\"post/Mutex介绍#mutex-头文件介绍\"></a></h3>\n<h4 id=\"mutex-系列类-四种\">Mutex 系列类(四种)<a href=\"post/Mutex介绍#mutex-系列类-四种\"></a></h4>\n<ul>\n<li>\n<p>std::mutex，最基本的 Mutex 类。</p>\n</li>\n<li>\n<p>std::recursive_mutex，递归 Mutex 类。</p>\n</li>\n<li>\n<p>std::time_mutex，定时 Mutex 类。</p>\n</li>\n<li>\n<p>std::recursive_timed_mutex，定时递归 Mutex 类。</p>\n</li>\n</ul>","link":"post/Mutex介绍","tags":["C++"],"categories":["C++"]},{"title":"C++之Lambda研究","date":"2019-06-03T12:20:52.000Z","thumbnail":null,"excerpt":"<h1>1. 前言<a href=\"post/Lambda#undefined\"></a></h1>\n<p>本文代码测试环境为“GCC-9.1.0”，有关编译器的安装请参考《<a href=\"https://blog.csdn.net/Aquester/article/details/89735466\" target=\"_blank\" rel=\"noopener\">安装GCC-8.3.0及其依赖</a>》，适用于“GCC-9.1.0”。</p>\n<p>本文试图揭露Lambda背后一面，以方便更好的理解和掌握Lambda。Lambda代码段实际为一个编译器生成的类的“operator ()”函数，编译器会为每一个Lambda函数生成一个匿名的类（在C++中，类和结构体实际一样，无本质区别，除了默认的访问控制）。</p>\n<p>对Lambda的最简单理解，是将它看作一个匿名类（或结构体），实际上也确实如此，编译器把Lambda编译成了匿名类。</p>","link":"post/Lambda","tags":["C++"],"categories":["C++"]},{"title":"C++ 模板偏特化－来自STL的思考","date":"2019-05-31T06:29:52.000Z","thumbnail":null,"excerpt":"<p>之前学习STL时接触过一段时间的模板，模板是C++泛型编程编程的基础<br>\nSTL从头到尾都是模板泛型编程，我觉得用的最巧妙的就是在traits萃取技巧时用到的模板偏特化</p>\n<hr>\n<ul>\n<li>先简要回顾一下模板吧，模板主要分为函数模板与类模板</li>\n</ul>\n<h2 id=\"函数模板\">函数模板<a href=\"post/模板特化#函数模板\"></a></h2>\n<figure class=\"highlight cpp\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">T</span> <span class=\"title\">add</span>(<span class=\"title\">T</span> <span class=\"title\">a</span>, <span class=\"title\">T</span> <span class=\"title\">b</span>) &#123;</span> <span class=\"keyword\">return</span> a + b;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>, b = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; add(a + b) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>","link":"post/模板特化","tags":["C++"],"categories":["C++"]},{"title":"C++中的万能引用和完美转发","date":"2019-05-29T02:05:19.000Z","thumbnail":null,"excerpt":"<h2 id=\"c-中的万能引用和完美转发\">C++中的万能引用和完美转发<a href=\"post/完美转发#c-中的万能引用和完美转发\"></a></h2>\n<ul>\n<li>\n<p>阅读这篇博文需要了解C<ins>中的左值（lvalue）和右值（rvalue）的概念，详情参见我的另外一篇博文：C</ins>移动语义及拷贝优化</p>\n</li>\n<li>\n<p>万能引用和完美转发多涉及到模板的使用，如若不是自己写模板，则可不用关心</p>\n</li>\n</ul>\n<h3 id=\"万能引用-universal-reference\">万能引用（Universal Reference）<a href=\"post/完美转发#万能引用-universal-reference\"></a></h3>\n<p>首先，我们来看一个例子：</p>","link":"post/完美转发","tags":["C++"],"categories":["C++"]},{"title":"从4行代码看右值引用","date":"2019-05-23T06:50:40.000Z","thumbnail":null,"excerpt":"<h2 id=\"概述\">概述<a href=\"post/右值引用#概述\"></a></h2>\n<p>右值引用的概念有些读者可能会感到陌生，其实他和C<ins>98/03中的左值引用有些类似，例如，c</ins>98/03中的左值引用是这样的：</p>\n<figure class=\"highlight matlab\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int <span class=\"built_in\">i</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">int&amp; <span class=\"built_in\">j</span> = <span class=\"built_in\">i</span>;</span><br></pre></td></tr></table></div></figure>\n<p>这里的int&amp;是对左值进行绑定（但是int&amp;却不能绑定右值），相应的，对右值进行绑定的引用就是右值引用，他的语法是这样的A&amp;&amp;，通过双引号来表示绑定类型为A的右值。通过&amp;&amp;我们就可以很方便的绑定右值了，比如我们可以这样绑定一个右值：</p>","link":"post/右值引用","tags":["C++"],"categories":["C++"]},{"title":"squid介绍及其简单配置","date":"2019-05-15T07:15:30.000Z","thumbnail":null,"excerpt":"<h1>squid的概念<a href=\"post/squid#undefined\"></a></h1>\n<p>squid是一种用来缓存Internet数据的软件。接受来自人们需要下载的目标（object）的请求并适当的处理这些请求。也就是说，如果一个人想下载一web界面，他请求squid为他取得这个页面。squid随之连接到远程服务器并向这个页面发出请求。然后，squid显式地聚集数据到客户端机器，而且同时复制一份。当下一次有人需要同一页面时， squid可以简单的从磁盘中读到它，那样数据会立即传输到客户机上。</p>","link":"post/squid","tags":["proxy","squid"],"categories":["Linux"]},{"title":"科学上网：用 VPS 搭建 shadowsocks 服务器","date":"2019-05-15T06:38:46.000Z","thumbnail":null,"excerpt":"<h2 id=\"shadowsocks-简介\">shadowsocks 简介<a href=\"post/shadowsocks#shadowsocks-简介\"></a></h2>\n<p>shadowsocks 是一款自定义协议的代理软件，由于其流量特征不明显，（直到不久前）一直可以稳定提供上网代理。</p>\n<p>shadowsocks 客户端会在本地开启一个 socks5 代理，通过此代理的网络访问请求由客户端发送至服务端，服务端发出请求，收到响应数据后再发回客户端。</p>\n<p>因此使用 shadowsocks 需要一台墙外的服务器来部署 shadowsocks 服务端。</p>","link":"post/shadowsocks","tags":["VPS","shadowsocks"],"categories":["Linux"]},{"title":"Tag Plugins","date":"2019-05-10T04:35:58.000Z","thumbnail":null,"excerpt":"<div class=\"note info\">\n            <h3 id=\"faq\">FAQ</h3><p><strong>Welcome</strong> to <a href=\"https://theme-next.org/docs/tag-plugins/\" target=\"_blank\" rel=\"noopener\">tag-plugins</a></p>\n          </div>\n<p>Tag Plugin is a way to make special style contents supported by Hexo. For example, we cannot show a image with custom size in standard Markdown. And then we can use tag plugins to solve it. <a href=\"https://hexo.io/docs/tag-plugins\" target=\"_blank\" rel=\"noopener\">Hexo has a lot of tags</a> which can help user. And Hexo also have interfaces to themes which make themes able to create their own tags. Following tags is provided by NexT:</p>","link":"post/Tag Plugins","tags":["Hexo","Next"],"categories":["Hexo"]}]}