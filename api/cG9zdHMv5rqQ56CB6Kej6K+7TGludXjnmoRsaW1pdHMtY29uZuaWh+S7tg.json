{"title":"源码解读Linux的limits.conf文件","date":"2019-09-09T12:19:38.000Z","date_formatted":{"ll":"Sep 9, 2019","L":"09/09/2019","MM-DD":"09-09"},"thumbnail":"/posts/源码解读Linux的limits-conf文件/20190910105208.png","link":"posts/源码解读Linux的limits-conf文件","comments":true,"tags":["Linux"],"categories":["Linux"],"updated":"2019-09-10T03:01:00.463Z","content":"<p>目录 </p>\n<ol>\n<li><p>前言 1</p>\n</li>\n<li><p>PAM 2</p>\n</li>\n<li><p>pam_limits 2</p>\n</li>\n<li><p>limits.conf的由来 3</p>\n</li>\n<li><p>模块入口函数 4</p>\n</li>\n<li><p>解析limits.conf 6</p>\n</li>\n<li><p>生效limits.conf 7</p>\n</li>\n<li><p>systemctl和systemd 8</p>\n</li>\n<li><p>总结 10</p>\n</li>\n</ol>\n<p>附1：资源 11</p>\n<p>附2：编译ninja 11</p>\n<p>附3：使用meson编译systemd 11</p>\n<p>附4：安装Python-3.7.2 12</p>\n<p>附5：安装libcap 12</p>\n <a id=\"more\"></a>\n\n<h1 id=\"前言\">前言<a href=\"posts/源码解读Linux的limits-conf文件#前言\"></a></h1><p>本文不一定适合比较老版本的Linux，如果只关心使用，请直接看“总结”，本文主要针对CentOS，其它Linux发行版本类似，但细节可能有出入，比如重启服务可能不是用systemctl，而是service等。</p>\n<p>当需要调整一个进程可打开的最多文件数或SOCKET连接数等，以CentOS为例，通常的做法是修改文件/etc/security/limits.conf，比如将最多可打开数调整为10万：</p>\n<h2 id=\"vi-etc-security-limits-conf\">vi /etc/security/limits.conf<a href=\"posts/源码解读Linux的limits-conf文件#vi-etc-security-limits-conf\"></a></h2><ul>\n<li>soft nofile 100000</li>\n<li>hard nofile 100000</li>\n</ul>\n<p>读取limit.conf文件的并不是Linux内核，而是一个内核模块PAM，对应的模块文件为：</p>\n<p>/usr/lib64/security/pam_limits.so<br>/usr/lib/security/pam_limits.so</p>\n<p>而/etc/pam.d目录下的配置文件，则由libpam.so读取，实际上所有的模块均由libpam.so加载，可将libpam.so看成是所有PAM模块的框架或容器，而且libpam.so本身也不是内核的组成部分。</p>\n<p>多个不同Linux版本上查看，并没有叫libpam.so的文件名，均是libpam.so.0（不清楚是否所有都这样），但是编译Linux-PAM-1.3.1源代码有名为libpam.so软链接，指向libpam.so.0.84.2。</p>\n<p>/usr/lib64/libpam.so.0 -&gt; libpam.so.0.83.1<br>/usr/lib64/libpam.so.0.83.1<br>/usr/lib64/libpam_misc.so.0.82.0</p>\n<p>/usr/lib/libpam.so.0 -&gt; libpam.so.0.83.1<br>/usr/lib/libpam.so.0.83.1<br>/usr/lib/libpam_misc.so.0.82.0</p>\n<p>libpam.so会被加载到crond等进程空间（那当然也可以不加载），如果没有加载libpam.so，则limits.conf不会生效。crond等不会主动加载libpam.so，那么是谁让libpam.so进入crond等进程空间的了？（执行“grep libpam /proc/<code>pidof crond</code>/maps”可查看libpam是否在crond的进程空间）。</p>\n<p>在CentOS，可用service来启动或重启crond，所以跟它应当是相关的，而service实际调用的是systemctl这一系统工具（非Shell脚本，service为老版本使用方式，使用systemctl启动和重启服务，使用方式和service相同）。</p>\n<h2 id=\"service-crond-restart\">service crond restart<a href=\"posts/源码解读Linux的limits-conf文件#service-crond-restart\"></a></h2><p>Redirecting to /bin/systemctl restart  crond.service</p>\n<h2 id=\"file-bin-systemctl\">file /bin/systemctl<a href=\"posts/源码解读Linux的limits-conf文件#file-bin-systemctl\"></a></h2><p>/bin/systemctl: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV)</p>\n<h2 id=\"systemctl-crond-restart-重启crontab服务进程crond\">systemctl crond restart # 重启crontab服务进程crond<a href=\"posts/源码解读Linux的limits-conf文件#systemctl-crond-restart-重启crontab服务进程crond\"></a></h2><h1 id=\"PAM\">PAM<a href=\"posts/源码解读Linux的limits-conf文件#PAM\"></a></h1><p>PAM的全称为“Pluggable Authentication Modules”，即可插入认证模块。最初由太阳微系统公司（Sun Microsystems，已于2009年被甲骨文收购）于1995年在Solaris开发。PAM代码不包含在Linux内核中，并有专门的网站：<a href=\"http://linux-pam.org/，源代码托管在Github上（https://github.com/linux-pam/linux-pam/releases）。\" target=\"_blank\" rel=\"noopener\">http://linux-pam.org/，源代码托管在Github上（https://github.com/linux-pam/linux-pam/releases）。</a></p>\n<h1 id=\"pam-limits\">pam_limits<a href=\"posts/源码解读Linux的limits-conf文件#pam-limits\"></a></h1><p>pam_limits是PAM其中的一个模块（模块文件名为pam_limits.so），也是程序员接触较多的模型之一，对应的源代码文件为pam_limits.c，代码规模为几百行，加上所有注释和空格有1100多行：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> !defined(linux) &amp;&amp; !defined(__linux)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">warning</span> THIS CODE IS KNOWN TO WORK ONLY ON LINUX !!!</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></div></figure>\n\n<p>源代码提供autoconf编译，尝试在Linux-3.10上可编译成功：</p>\n<p>~/Linux-PAM-1.3.1]$ ./configure –prefix=/usr/local/Linux-PAM-1.3.1<br>make</p>\n<h1 id=\"limits-conf的由来\">limits.conf的由来<a href=\"posts/源码解读Linux的limits-conf文件#limits-conf的由来\"></a></h1><p>确定模块pam_limits的配置文件，由宏CONF_FILE决定：</p>\n<p>// pam_limits.c</p>\n<p>#define CONF_FILE (pl-&gt;conf_file != NULL)?pl-&gt;conf_file:LIMITS_FILE</p>\n<p>使用的地方：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pam_limits.c</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span></span><br><span class=\"line\">parse_config_file(<span class=\"keyword\">pam_handle_t</span> *pamh, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *uname, <span class=\"keyword\">uid_t</span> uid, <span class=\"keyword\">gid_t</span> gid,</span><br><span class=\"line\">     <span class=\"keyword\">int</span> ctrl, struct pam_limit_s *pl)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    FILE *fil;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[LINE_LENGTH];</span><br><span class=\"line\"><span class=\"comment\">/* check for the LIMITS_FILE */</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (ctrl &amp; PAM_DEBUG_ARG)</span><br><span class=\"line\">    pam_syslog(pamh, LOG_DEBUG, <span class=\"string\">\"reading settings from '%s'\"</span>, CONF_FILE);</span><br><span class=\"line\">fil = fopen(CONF_FILE, <span class=\"string\">\"r\"</span>); <span class=\"comment\">// 打开配置文件，跟参数“pl”有关系</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (fil == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    pam_syslog (pamh, LOG_WARNING,</span><br><span class=\"line\"><span class=\"string\">\"cannot read settings from %s: %m\"</span>, CONF_FILE);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> PAM_SERVICE_ERR;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>如果函数parse_config_file的参数“pl”值为NULL，则配置文件名在编译时决定，这种情况下，配置文件名被固定为limits.conf：</p>\n<h2 id=\"Makefile-am\">Makefile.am<a href=\"posts/源码解读Linux的limits-conf文件#Makefile-am\"></a></h2><p>modules/pam_limits/Makefile.am: -DLIMITS_FILE_DIR=&quot;$(limits_conf_dir)/*.conf&quot; <br>modules/pam_limits/Makefile.am: -DLIMITS_FILE=&quot;$(SCONFIGDIR)/limits.conf&quot;</p>\n<p>只是limits.conf所在目录可由编译时决定，也就是看SCONFIGDIR，决定在automake的configure.ac文件：</p>\n<h2 id=\"configure-ac\">configure.ac<a href=\"posts/源码解读Linux的limits-conf文件#configure-ac\"></a></h2><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AC_ARG_ENABLE(sconfigdir,</span><br><span class=\"line\">        AS_HELP_STRING([--enable-sconfigdir=DIR],[path to <span class=\"keyword\">module</span> conf files @&lt;:@<span class=\"keyword\">default</span>=$sysconfdir/security@:&gt;@]),</span><br><span class=\"line\">        SCONFIGDIR=$enableval, SCONFIGDIR=$sysconfdir/security)</span><br><span class=\"line\">AC_SUBST(SCONFIGDIR)</span><br><span class=\"line\"></span><br><span class=\"line\">dnl <span class=\"keyword\">and</span> some hacks to use /etc <span class=\"keyword\">and</span> /lib</span><br><span class=\"line\">test <span class=\"string\">\"$&#123;prefix&#125;\"</span> = <span class=\"string\">\"NONE\"</span> &amp;&amp; prefix=<span class=\"string\">\"/usr\"</span></span><br><span class=\"line\">if test $&#123;prefix&#125; = '/usr'</span><br><span class=\"line\">then</span><br><span class=\"line\">dnl If we use /usr as prefix, use /etc <span class=\"keyword\">for</span> config files</span><br><span class=\"line\">        if test $&#123;sysconfdir&#125; = '$&#123;prefix&#125;/etc'</span><br><span class=\"line\">        then</span><br><span class=\"line\">                sysconfdir=<span class=\"string\">\"/etc\"</span></span><br><span class=\"line\">        fi</span><br></pre></td></tr></table></div></figure>\n\n<p>推导出默认为“/etc/security/limits.conf”，但从前面的分析，可看到实际还可参数动态指定，这个参数怎么来？可进入Linux的/etc/pam.d目录，找一个看一看：</p>\n<h2 id=\"vi-etc-pam-d-login\">vi /etc/pam.d/login<a href=\"posts/源码解读Linux的limits-conf文件#vi-etc-pam-d-login\"></a></h2><p>session    required     pam_selinux.so close<br>session    required     pam_selinux.so open</p>\n<p>上述最后一个配置项即为模型的参数值，参数值可有0、一个或多个。通常pam_limits.so使用默认参数值，因此它的配置文件limits.conf完整路径为：/etc/security/limits.conf。</p>\n<h1 id=\"模块入口函数\">模块入口函数<a href=\"posts/源码解读Linux的limits-conf文件#模块入口函数\"></a></h1><p>会话（Session）类的PAM模块的入口函数均为pam_sm_open_session（授权类的为pam_sm_authenticate，密码类的为pam_sm_chauthtok），意为创建（打开）一个会话：</p>\n<p>int<br>pam_sm_open_session (pam_handle_t <em>pamh, int flags UNUSED, int argc, const char *</em>argv);<br>// libpam/pam_handlers.c:  sym = “pam_sm_open_session”;</p>\n<p>加载模块在pam_handlers.c中完成，实际上一个模块可加载多次（可在/etc/security下看到有些配置文件中同一模型有多行）。类似于iptables，每加载一次创建一个handler，依次组成一个handler调用链（实际由配置文件中的每一行配置组成链）：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pam_handlers.c</span></span><br><span class=\"line\"><span class=\"comment\">// 被_pam_parse_conf_file直接调用，</span></span><br><span class=\"line\"><span class=\"comment\">// 和被_pam_init_handlers、_pam_load_conf_file一级间接调用</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> _pam_add_handler(<span class=\"keyword\">pam_handle_t</span> *pamh</span><br><span class=\"line\">     , <span class=\"keyword\">int</span> handler_type, <span class=\"keyword\">int</span> other, <span class=\"keyword\">int</span> stack_level, <span class=\"keyword\">int</span> type</span><br><span class=\"line\">     , <span class=\"keyword\">int</span> *actions, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *mod_path</span><br><span class=\"line\">     , <span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> **argv, <span class=\"keyword\">int</span> argvlen)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">loaded_module</span> *<span class=\"title\">mod</span> = <span class=\"title\">NULL</span>;</span></span><br><span class=\"line\">    。。。。。。</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((handler_type == PAM_HT_MODULE ||</span><br><span class=\"line\">         handler_type == PAM_HT_SILENT_MODULE) &amp;&amp;</span><br><span class=\"line\">        mod_path != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (mod_path[<span class=\"number\">0</span>] == <span class=\"string\">'/'</span>) &#123;</span><br><span class=\"line\">    mod = _pam_load_module(pamh, mod_path, handler_type);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (asprintf(&amp;mod_full_path, <span class=\"string\">\"%s%s\"</span>,</span><br><span class=\"line\">     DEFAULT_MODULE_PATH, mod_path) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    mod = _pam_load_module(pamh, mod_full_path, handler_type);</span><br><span class=\"line\">    _pam_drop(mod_full_path);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    pam_syslog(pamh, LOG_CRIT, <span class=\"string\">\"cannot malloc full mod path\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> PAM_ABORT;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (mod == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* if we get here with NULL it means allocation error */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> PAM_ABORT;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    。。。。。。</span><br><span class=\"line\">        <span class=\"comment\">/* point handler_p's at the root addresses of the function stacks */</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (type) &#123;</span><br><span class=\"line\">        。。。。。。</span><br><span class=\"line\">        <span class=\"keyword\">case</span> PAM_T_SESS:</span><br><span class=\"line\">            handler_p = &amp;the_handlers-&gt;open_session;</span><br><span class=\"line\">            sym = <span class=\"string\">\"pam_sm_open_session\"</span>;</span><br><span class=\"line\">            handler_p2 = &amp;the_handlers-&gt;close_session;</span><br><span class=\"line\">            sym2 = <span class=\"string\">\"pam_sm_close_session\"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        。。。。。。</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> ((mod_type == PAM_MT_DYNAMIC_MOD) &amp;&amp;</span><br><span class=\"line\">    !(func = _pam_dlsym(mod-&gt;dl_handle, sym)) ) &#123;</span><br><span class=\"line\">    pam_syslog(pamh, LOG_ERR, <span class=\"string\">\"unable to resolve symbol: %s\"</span>, sym);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">。。。。。。</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>每个模块的结果可能是成功PAM_SUCCESS(0)，全定义在文件libpam/include/security/_pam_types.h中，下列展示小部分：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* ----------------- The Linux-PAM return values ------------------ */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PAM_SUCCESS 0 <span class=\"comment\">/* Successful function return */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PAM_OPEN_ERR 1 <span class=\"comment\">/* dlopen() failure when dynamically */</span></span></span><br><span class=\"line\"><span class=\"comment\">/* loading a service module */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PAM_SYMBOL_ERR 2 <span class=\"comment\">/* Symbol not found */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PAM_SERVICE_ERR 3 <span class=\"comment\">/* Error in service module */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PAM_SYSTEM_ERR 4 <span class=\"comment\">/* System error */</span></span></span><br></pre></td></tr></table></div></figure>\n\n<h1 id=\"解析limits-conf\">解析limits.conf<a href=\"posts/源码解读Linux的limits-conf文件#解析limits-conf\"></a></h1><p>重聚焦到pam_limits模块，看看它的配置文件解析，这发生在函数pam_limits.c中的parse_config_file函数。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pam_limits.c</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span></span><br><span class=\"line\">parse_config_file(<span class=\"keyword\">pam_handle_t</span> *pamh, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *uname, <span class=\"keyword\">uid_t</span> uid, <span class=\"keyword\">gid_t</span> gid,</span><br><span class=\"line\">     <span class=\"keyword\">int</span> ctrl, struct pam_limit_s *pl)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    FILE *fil;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[LINE_LENGTH]; <span class=\"comment\">// #define LINE_LENGTH 1024</span></span><br><span class=\"line\">    <span class=\"comment\">// 以只读方式打开limits.conf</span></span><br><span class=\"line\">\t\tfil = fopen(CONF_FILE, <span class=\"string\">\"r\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (fil == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    pam_syslog (pamh, LOG_WARNING,</span><br><span class=\"line\"><span class=\"string\">\"cannot read settings from %s: %m\"</span>, CONF_FILE);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> PAM_SERVICE_ERR;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* start the show */</span></span><br><span class=\"line\"><span class=\"comment\">// 一行行遍历limits.conf</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (fgets(buf, LINE_LENGTH, fil) != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    line = buf;</span><br><span class=\"line\">    <span class=\"comment\">/* skip the leading white space */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (*line &amp;&amp; <span class=\"built_in\">isspace</span>(*line)) <span class=\"comment\">// 跳过空行</span></span><br><span class=\"line\">        line++;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\">/* Rip off the comments */</span></span><br><span class=\"line\">    tptr = <span class=\"built_in\">strchr</span>(line,<span class=\"string\">'#'</span>); <span class=\"comment\">// 去掉注释</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tptr)</span><br><span class=\"line\">        *tptr = <span class=\"string\">'\\0'</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* Rip off the newline char */</span></span><br><span class=\"line\">    tptr = <span class=\"built_in\">strchr</span>(line,<span class=\"string\">'\\n'</span>); <span class=\"comment\">// 删除换行符，注意并不包括回车符</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tptr)</span><br><span class=\"line\">        *tptr = <span class=\"string\">'\\0'</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* Anything left ? */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">strlen</span>(line)) <span class=\"comment\">// 经过上面几步折腾，可能成了空行</span></span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 直接调用sscanf解析配置项</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// 配置行示例：</span></span><br><span class=\"line\">    <span class=\"comment\">// * soft nofile 100000</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// domain：作用域名，“*”表示对所有用户有效</span></span><br><span class=\"line\">    i = <span class=\"built_in\">sscanf</span>(line,<span class=\"string\">\"%s%s%s%s\"</span>, domain, ltype, item, value);</span><br><span class=\"line\">    。。。。。。</span><br><span class=\"line\">    <span class=\"comment\">// 下面只看两个常用配置：domain配置为“*”或指定的用户名</span></span><br><span class=\"line\">    <span class=\"comment\">// 可以看到在加载limits.conf，主要是设置输出参数pl的值。</span></span><br><span class=\"line\">    <span class=\"comment\">// 而parse_config_file由pam_sm_open_session调用，亦即模块被加载时被调用。</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// 也因此修改limits.conf是不能立即生效的，</span></span><br><span class=\"line\">    <span class=\"comment\">// 除非重启该进程，而子进程又继承父进程的设置。</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// 假设程序跑在crontab中，则应重启crond进程，</span></span><br><span class=\"line\">    <span class=\"comment\">// 比如CentOS中重启crond：service crond restart</span></span><br><span class=\"line\">    <span class=\"comment\">// 虽然crontab中的进程是由crond拉起来的，但它并加载PAM模块，</span></span><br><span class=\"line\">    <span class=\"comment\">// 原因是crond在拉起子进程时，对子进程关闭了所有描述符。</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// process_limit针对当前调用进程进行limit设置</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(domain, <span class=\"string\">\"*\"</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// limit was set by a default entry</span></span><br><span class=\"line\">        process_limit(pamh, LIMITS_DEF_DEFAULT, ltype, item, value, ctrl, pl);</span><br><span class=\"line\">    。。。。。。        </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(uname, domain) == <span class=\"number\">0</span>) <span class=\"comment\">/* this user have a limit */</span></span><br><span class=\"line\">        <span class=\"comment\">// limit was set by an user entry</span></span><br><span class=\"line\">        process_limit(pamh, LIMITS_DEF_USER, ltype, item, value, ctrl, pl);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h1 id=\"生效limits-conf\">生效limits.conf<a href=\"posts/源码解读Linux的limits-conf文件#生效limits-conf\"></a></h1><p>加载PAM模块时，即会生效limits.conf，因为这个在pam_sm_open_session就已执行了：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* now the session stuff */</span></span><br><span class=\"line\"><span class=\"keyword\">int</span></span><br><span class=\"line\">pam_sm_open_session (<span class=\"keyword\">pam_handle_t</span> *pamh, <span class=\"keyword\">int</span> flags UNUSED,</span><br><span class=\"line\">     <span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **argv)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pam_limit_s</span> <span class=\"title\">plstruct</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pam_limit_s</span> *<span class=\"title\">pl</span> = &amp;<span class=\"title\">plstruct</span>;</span></span><br><span class=\"line\">    。。。。。。</span><br><span class=\"line\">    <span class=\"comment\">// 调用parse_config_file解析limits.conf，</span></span><br><span class=\"line\">    <span class=\"comment\">// 配置行解析结果存储在pl中（亦即plstruct）</span></span><br><span class=\"line\">    retval = parse_config_file(pamh, pwd-&gt;pw_name, pwd-&gt;pw_uid, pwd-&gt;pw_gid, ctrl, pl);</span><br><span class=\"line\">    。。。。。。</span><br><span class=\"line\">    <span class=\"comment\">// 使配置立即生效（setup_limits调用系统函数setrlimit）</span></span><br><span class=\"line\">    retval = setup_limits(pamh, pwd-&gt;pw_name, pwd-&gt;pw_uid, ctrl, pl);</span><br><span class=\"line\">    。。。。。。</span><br><span class=\"line\">    <span class=\"keyword\">return</span> PAM_SUCCESS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>模块pam_limits.so是由PAM模块libpam.so加载的，crond加载的只是libpam.so。“/etc/pam.d”目录下的文件什么时候生效？加载libpam.so时生效：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pam_start.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pam_start</span> <span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *service_name,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *user,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">const</span> struct pam_conv *pam_conversation,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">pam_handle_t</span> **pamh)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    。。。。。。</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( _pam_init_handlers(*pamh) != PAM_SUCCESS ) &#123;</span><br><span class=\"line\">    。。。。。。</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// pam_handlers.c</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> _pam_init_handlers(<span class=\"keyword\">pam_handle_t</span> *pamh)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    。。。。。。</span><br><span class=\"line\">    <span class=\"comment\">// 函数_pam_parse_conf_file负责解析libpam.so的配置文件，</span></span><br><span class=\"line\">    <span class=\"comment\">// 这些配置文件一般位于目录/etc/pam.d下，如：</span></span><br><span class=\"line\">    <span class=\"comment\">// # ls -l /etc/pam.d/pass*</span></span><br><span class=\"line\">    <span class=\"comment\">// -rw-r--r-- 1 root root 188 6月  10 2014 /etc/pam.d/passwd</span></span><br><span class=\"line\">    <span class=\"comment\">// -rw-r--r-- 1 root root 974 12月 29 2016 /etc/pam.d/password-auth</span></span><br><span class=\"line\">    retval = _pam_parse_conf_file(pamh, f, <span class=\"literal\">NULL</span>, PAM_T_ANY, <span class=\"number\">0</span>);</span><br><span class=\"line\">    。。。。。。</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h1 id=\"systemctl和systemd\">systemctl和systemd<a href=\"posts/源码解读Linux的limits-conf文件#systemctl和systemd\"></a></h1><p>CentOS上的systemctl（CentOS-7.X之前为service脚本）类似于Windows平台的服务管理器，替代老版本中的service脚本来管理服务。Systemctl功能非常多，有关systemctl的功能不在本文过多描述。</p>\n<p>sytemctl的工作原理是通过与服务systemd交互，来完成各项工作，比如重启crond进程。在CentOS，systemctl替代了inittab。</p>\n<p>可以看到正是systemd加载了pam，从ldd结果可以看出systemd也不是动态加载pam模块，而是编译时就绑定了，因此libpam.so成了系统的必须部分（但pam_limits.so仍然不是，总是可插拔）：</p>\n<h2 id=\"ldd-usr-lib-systemd-systemd\">ldd /usr/lib/systemd/systemd<a href=\"posts/源码解读Linux的limits-conf文件#ldd-usr-lib-systemd-systemd\"></a></h2><pre><code>linux-vdso.so.1 =&gt;  (0x00007ffce5b72000)\n/$LIB/libonion.so =&gt; /lib64/libonion.so (0x00007f2430f56000)\nlibselinux.so.1 =&gt; /lib64/libselinux.so.1 (0x00007f2430d31000)\nlibcap.so.2 =&gt; /lib64/libcap.so.2 (0x00007f2430b2c000)\nlibpam.so.0 =&gt; /lib64/libpam.so.0 (0x00007f243091d000)\nlibaudit.so.1 =&gt; /lib64/libaudit.so.1 (0x00007f24306f5000)\nlibkmod.so.2 =&gt; /lib64/libkmod.so.2 (0x00007f24304df000)\nlibmount.so.1 =&gt; /lib64/libmount.so.1 (0x00007f24302a0000)\nlibrt.so.1 =&gt; /lib64/librt.so.1 (0x00007f2430098000)\nlibgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00007f242fe82000)\nlibpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007f242fc66000)\nlibc.so.6 =&gt; /lib64/libc.so.6 (0x00007f242f8a2000)\n/lib64/ld-linux-x86-64.so.2 (0x00007f243105c000)\nlibdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f242f69e000)\nlibpcre.so.1 =&gt; /lib64/libpcre.so.1 (0x00007f242f43d000)\nliblzma.so.5 =&gt; /lib64/liblzma.so.5 (0x00007f242f218000)\nlibattr.so.1 =&gt; /lib64/libattr.so.1 (0x00007f242f013000)\nlibcap-ng.so.0 =&gt; /lib64/libcap-ng.so.0 (0x00007f242ee0d000)\nlibz.so.1 =&gt; /lib64/libz.so.1 (0x00007f242ebf7000)\nlibblkid.so.1 =&gt; /lib64/libblkid.so.1 (0x00007f242e9ba000)\nlibuuid.so.1 =&gt; /lib64/libuuid.so.1 (0x00007f242e7b5000)</code></pre><h2 id=\"ldd-usr-sbin-crond\">ldd /usr/sbin/crond<a href=\"posts/源码解读Linux的limits-conf文件#ldd-usr-sbin-crond\"></a></h2><pre><code>linux-vdso.so.1 =&gt;  (0x00007ffef31a5000)\n/$LIB/libonion.so =&gt; /lib64/libonion.so (0x00007f87b89e5000)\nlibselinux.so.1 =&gt; /lib64/libselinux.so.1 (0x00007f87b8416000)\nlibpam.so.0 =&gt; /lib64/libpam.so.0 (0x00007f87b8207000)\nlibdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f87b8003000)\nlibaudit.so.1 =&gt; /lib64/libaudit.so.1 (0x00007f87b7ddb000)\nlibc.so.6 =&gt; /lib64/libc.so.6 (0x00007f87b7a17000)\nlibpcre.so.1 =&gt; /lib64/libpcre.so.1 (0x00007f87b77b6000)\nliblzma.so.5 =&gt; /lib64/liblzma.so.5 (0x00007f87b7591000)\n/lib64/ld-linux-x86-64.so.2 (0x00007f87b88cc000)\nlibcap-ng.so.0 =&gt; /lib64/libcap-ng.so.0 (0x00007f87b738b000)\nlibpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007f87b716f000)</code></pre><p>实际上，systemd为Linux系统（CentOS如此，像Ubuntu未必）的第一个进程，取代了以前的init进程，可以看到systemd进程和init进程不会同时存在，低版本为init，高版本为systemd。Ubuntu使用的是upstart，但也可能用systemd替代upstart。</p>\n<p>在systemd源代码的编译文件meson.build（类似于CMake的CMakeLists.txt文件，或bazel的BUILD文件）中可以看到systemd对libpam的依赖。</p>\n<p>systemctl部分用法：</p>\n<p>1) 重启crond</p>\n<h2 id=\"systemctl-restart-crond\">systemctl restart crond<a href=\"posts/源码解读Linux的limits-conf文件#systemctl-restart-crond\"></a></h2><p>2) 显示系统状态</p>\n<h2 id=\"systemctl-status\">systemctl status<a href=\"posts/源码解读Linux的limits-conf文件#systemctl-status\"></a></h2><p>● Jian.mooon<br>    State: degraded<br>     Jobs: 0 queued<br>   Failed: 2 units<br>    Since: 二 2017-10-24 02:38:50 CST; 1 years 3 months ago<br>   CGroup: /<br>   。。。。。。</p>\n<p>3) 重启系统</p>\n<h2 id=\"systemctl-reboot\">systemctl reboot<a href=\"posts/源码解读Linux的limits-conf文件#systemctl-reboot\"></a></h2><p>4) 关闭电源</p>\n<h2 id=\"systemctl-poweroff\">systemctl poweroff<a href=\"posts/源码解读Linux的limits-conf文件#systemctl-poweroff\"></a></h2><p>5) 待机</p>\n<h2 id=\"systemctl-suspend\">systemctl suspend<a href=\"posts/源码解读Linux的limits-conf文件#systemctl-suspend\"></a></h2><p>6) 休眠</p>\n<h2 id=\"systemctl-hibernate\">systemctl hibernate<a href=\"posts/源码解读Linux的limits-conf文件#systemctl-hibernate\"></a></h2><p>有关systemctl的更多信息，可浏览：</p>\n<p><a href=\"https://wiki.archlinux.org/index.php/systemd_(简体中文)。\" target=\"_blank\" rel=\"noopener\">https://wiki.archlinux.org/index.php/systemd_(简体中文)。</a></p>\n<h1 id=\"总结\">总结<a href=\"posts/源码解读Linux的limits-conf文件#总结\"></a></h1><p>修改limits.conf不会立即生效，除非重启相关的父进程，比如crontab的crond，而有些老版本的Linux可能只能重启以生效。</p>\n<p>1) 系统启动 -&gt; 启动初始化进程systemd -&gt; 进程sytemd加载libpam.so模块<br>2) libpam.so根据/etc/pam.d决定是否加载pam_limits.so等<br>3) 在加载pam_limits.so时，会读取/etc/security/limits.conf<br>4) 重启crond等，实际是向systemd发重启指令<br>5) 一句话：如果要使用limits.conf生效，一定要有加载pam_limits.so，如果修改limits.conf，至少要让pam_limits.so重读limits.conf。<br>附1：资源</p>\n<p>1) PAM官方</p>\n<p><a href=\"http://linux-pam.org/\" target=\"_blank\" rel=\"noopener\">http://linux-pam.org/</a></p>\n<p>2) PAM源代码</p>\n<p><a href=\"https://github.com/linux-pam/linux-pam/releases\" target=\"_blank\" rel=\"noopener\">https://github.com/linux-pam/linux-pam/releases</a></p>\n<p>3) systemd源代码</p>\n<p><a href=\"https://github.com/systemd/systemd（使用meson编译，Meson\" target=\"_blank\" rel=\"noopener\">https://github.com/systemd/systemd（使用meson编译，Meson</a> is an open source build system，依赖ninja）</p>\n<p>4) Vixie-cron源代码</p>\n<p><a href=\"http://ftp.isc.org/isc/cron/\" target=\"_blank\" rel=\"noopener\">http://ftp.isc.org/isc/cron/</a></p>\n<p><a href=\"https://github.com/svagner/vixie-cron\" target=\"_blank\" rel=\"noopener\">https://github.com/svagner/vixie-cron</a></p>\n<p><a href=\"ftp://ftp.riken.jp/Linux/cern/updates/slc52/SRPMS/repoview/vixie-cron.html\" target=\"_blank\" rel=\"noopener\">ftp://ftp.riken.jp/Linux/cern/updates/slc52/SRPMS/repoview/vixie-cron.html</a></p>\n<p>附2：编译ninja</p>\n<p>ninja类似于make，使用meson之前必须先准备好ninja。</p>\n<p>1) 从<a href=\"https://github.com/ninja-build/ninja下载ninja源代码\" target=\"_blank\" rel=\"noopener\">https://github.com/ninja-build/ninja下载ninja源代码</a></p>\n<p>2) 解压源代码包，然后进入解压后的目录</p>\n<p>3) 执行“./configure.py –bootstrap”</p>\n<p>4) 成功后会在目录下生成名为ninja的可执行程序文件</p>\n<p>5) 将可执行程序文件复制到PATH目录下，比如：/usr/local/bin或/usr/bin等目录</p>\n<p>6) 完成。</p>\n<p>附3：使用meson编译systemd</p>\n<p>Meson-0.49.1要求3.5或更高版本的Python（<a href=\"https://www.python.org/），和1.5或更高版本的Ninja，还依赖gperf（简单安装：yum\" target=\"_blank\" rel=\"noopener\">https://www.python.org/），和1.5或更高版本的Ninja，还依赖gperf（简单安装：yum</a> install -y gperf），还依赖libcap-dev（执行yum install -y libcap安装，如果仍然不行，从<a href=\"https://git.kernel.org/pub/scm/linux/kernel/git/morgan/libcap.git/下载源代码安装），除此之外还有一些其它的依赖，需逐个解决。\" target=\"_blank\" rel=\"noopener\">https://git.kernel.org/pub/scm/linux/kernel/git/morgan/libcap.git/下载源代码安装），除此之外还有一些其它的依赖，需逐个解决。</a></p>\n<p>1) 从<a href=\"https://github.com/mesonbuild/meson下载meson源代码\" target=\"_blank\" rel=\"noopener\">https://github.com/mesonbuild/meson下载meson源代码</a></p>\n<p>2) 解压后，将meson目录添加到PATH中，比如：export PATH=/root/X/meson-0.49.1:$PATH</p>\n<p>3) 进入systemd源代码目录</p>\n<p>4) 执行“meson.py build”（如果出错，可能是Python版本不够）</p>\n<p>5) 成功后会生成build子目录</p>\n<p>6) 进入build目录，执行ninja开始编译（ninja类似于make）</p>\n<p>附4：安装Python-3.7.2</p>\n<p>Python-3.7.2采用automake编译：</p>\n<p>1) 执行configure生成Makefile文件：./configure –prefix=/usr/local/Python-3.7.2</p>\n<p>2) 执行make开始编译Python（编译时间会有点长）</p>\n<p>3) 执行make install，安装Python（安装时间稍有点长）</p>\n<p>4) 将Python的bin目录加入到PATH中，如：export PATH=/usr/local/Python-3.7.2/bin:$PATH</p>\n<p>5) 可以开始使用Python-3.7.2了。</p>\n<p>如果遇到错误“ModuleNotFoundError: No module named ‘_ctypes’”，是因为依赖的libffi-devel版本不够（可执行“yum install -y libffi-devel”安装libffi，或源码方式安装libffi）。</p>\n<p>附5：安装libcap</p>\n<p>1) 从<a href=\"https://git.kernel.org/pub/scm/linux/kernel/git/morgan/libcap.git/下载源代码包\" target=\"_blank\" rel=\"noopener\">https://git.kernel.org/pub/scm/linux/kernel/git/morgan/libcap.git/下载源代码包</a></p>\n<p>2) 解压后进入解压目录</p>\n<p>3) 执行make编译</p>\n<p>4) 执行make install安装</p>\n<p>5) 完成。</p>\n<hr>\n<p>版权声明：本文为CSDN博主「一见」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/Aquester/article/details/86694644\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/Aquester/article/details/86694644</a></p>\n","prev":{"title":"编译器架构的王者LLVM——使用JIT引擎","link":"posts/编译器架构的王者LLVM——使用JIT引擎"},"next":{"title":"模版元编程应用","link":"posts/模版元编程应用"},"plink":"https://shuntan.github.io/posts/源码解读Linux的limits-conf文件/","toc":[{"title":"前言","id":"前言","index":"1","children":[{"title":"vi /etc/security/limits.conf","id":"vi-etc-security-limits-conf","index":"1.1"},{"title":"service crond restart","id":"service-crond-restart","index":"1.2"},{"title":"file /bin/systemctl","id":"file-bin-systemctl","index":"1.3"},{"title":"systemctl crond restart # 重启crontab服务进程crond","id":"systemctl-crond-restart-重启crontab服务进程crond","index":"1.4"}]},{"title":"PAM","id":"PAM","index":"2"},{"title":"pam_limits","id":"pam-limits","index":"3"},{"title":"limits.conf的由来","id":"limits-conf的由来","index":"4","children":[{"title":"Makefile.am","id":"Makefile-am","index":"4.1"},{"title":"configure.ac","id":"configure-ac","index":"4.2"},{"title":"vi /etc/pam.d/login","id":"vi-etc-pam-d-login","index":"4.3"}]},{"title":"模块入口函数","id":"模块入口函数","index":"5"},{"title":"解析limits.conf","id":"解析limits-conf","index":"6"},{"title":"生效limits.conf","id":"生效limits-conf","index":"7"},{"title":"systemctl和systemd","id":"systemctl和systemd","index":"8","children":[{"title":"ldd /usr/lib/systemd/systemd","id":"ldd-usr-lib-systemd-systemd","index":"8.1"},{"title":"ldd /usr/sbin/crond","id":"ldd-usr-sbin-crond","index":"8.2"},{"title":"systemctl restart crond","id":"systemctl-restart-crond","index":"8.3"},{"title":"systemctl status","id":"systemctl-status","index":"8.4"},{"title":"systemctl reboot","id":"systemctl-reboot","index":"8.5"},{"title":"systemctl poweroff","id":"systemctl-poweroff","index":"8.6"},{"title":"systemctl suspend","id":"systemctl-suspend","index":"8.7"},{"title":"systemctl hibernate","id":"systemctl-hibernate","index":"8.8"}]},{"title":"总结","id":"总结","index":"9"}],"reward":true,"copyright":{"author":"Shawntan","link":"<a href=\"https://shuntan.github.io/posts/源码解读Linux的limits-conf文件/\" title=\"源码解读Linux的limits.conf文件\">https://shuntan.github.io/posts/源码解读Linux的limits-conf文件/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow noopener\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","published":"September 9, 2019","updated":"September 10, 2019"}}