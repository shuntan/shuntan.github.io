{"title":"C++中优雅的异步操作","date":"2019-06-14T06:21:26.000Z","date_formatted":{"ll":"Jun 14, 2019","L":"06/14/2019","MM-DD":"06-14"},"thumbnail":"/posts/C++中优雅的异步操作/0341e046a16c2b9a2762a35c3cde7dbf.jpg","link":"posts/C++中优雅的异步操作","comments":true,"tags":["C++"],"categories":["C++"],"updated":"2020-04-14T14:01:48.616Z","content":"<p>c++11中增加了线程，使得我们可以非常方便的创建线程，它的基本用法是这样的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"function\">thread <span class=\"title\">t</span><span class=\"params\">(f, n + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">t.join();</span><br></pre></td></tr></table></figure>\n<p>但是线程毕竟是属于比较低层次的东西，有时候使用有些不便，比如我希望获取线程函数的返回结果的时候，我就不能直接通过thread.join()得到结果，这时就必须定义一个变量，在线程函数中去给这个变量赋值，然后join,最后得到结果，这个过程是比较繁琐的。c++11还提供了异步接口std::async，通过这个异步接口可以很方便的获取线程函数的执行结果。std::async会自动创建一个线程去调用线程函数，它返回一个std::future，这个future中存储了线程函数返回的结果，当我们需要线程函数的结果时，直接从future中获取，非常方便。但是我想说的是，<strong>其实std::async给我们提供的便利可不仅仅是这一点，它首先解耦了线程的创建和执行，使得我们可以在需要的时候获取异步操作的结果；其次它还提供了线程的创建策略（比如可以通过延迟加载的方式去创建线程）</strong>，使得我们可以以多种方式去创建线程。在介绍async具体用法以及为什么要用std::async代替线程的创建之前，我想先说一说std::future、std::promise和std::packaged_task。</p>\n<a id=\"more\"></a>\n<h2 id=\"std::futur\">std::futur<a title=\"#std::futur\" href=\"#std::futur\"></a></h2>\n<p>std::future是一个非常有用也很有意思的东西，简单说std::future提供了一种访问异步操作结果的机制。从字面意思来理解，它表示未来，我觉得这个名字非常贴切，因为一个异步操作我们是不可能马上就获取操作结果的，只能在未来某个时候获取，但是我们可以以同步等待的方式来获取结果，可以通过查询future的状态（future_status）来获取异步操作的结果。future_status有三种状态：</p>\n<ul>\n<li>deferred：异步操作还没开始</li>\n<li>ready：异步操作已经完成</li>\n<li>timeout：异步操作超时</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询future的状态</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::future_status status;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        status = future.wait_for(<span class=\"built_in\">std</span>::chrono::seconds(<span class=\"number\">1</span>));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (status == <span class=\"built_in\">std</span>::future_status::deferred) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"deferred\\n\"</span>; <span class=\"comment\">//代表延迟执行</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (status == <span class=\"built_in\">std</span>::future_status::timeout) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"timeout\\n\"</span>;  <span class=\"comment\">//代表执行中</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (status == <span class=\"built_in\">std</span>::future_status::ready) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"ready!\\n\"</span>;   <span class=\"comment\">//代表已经执行完成</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (status != <span class=\"built_in\">std</span>::future_status::ready);</span><br></pre></td></tr></table></figure>\n<p>获取future结果有三种方式：get、wait、wait_for，其中get等待异步操作结束并返回结果，wait只是等待异步操作完成，没有返回值，wait_for是超时等待返回结果。</p>\n<h2 id=\"std::promise\">std::promise<a title=\"#std::promise\" href=\"#std::promise\"></a></h2>\n<p>std::promise为获取线程函数中的某个值提供便利，在线程函数中给外面传进来的promise赋值，当线程函数执行完成之后就可以通过promis获取该值了，值得注意的是取值是间接的通过promise内部提供的future来获取的。它的基本用法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::promise&lt;<span class=\"keyword\">int</span>&gt; pr;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"function\">thread <span class=\"title\">t</span><span class=\"params\">([](<span class=\"built_in\">std</span>::promise&lt;<span class=\"keyword\">int</span>&gt;&amp; p)&#123; p.set_value_at_thread_exit(<span class=\"number\">9</span>); &#125;,<span class=\"built_in\">std</span>::ref(pr))</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::future&lt;<span class=\"keyword\">int</span>&gt; f = pr.get_future();</span><br><span class=\"line\"><span class=\"keyword\">auto</span> r = f.get();</span><br></pre></td></tr></table></figure>\n<h2 id=\"std::packaged_task\">std::packaged_task<a title=\"#std::packaged_task\" href=\"#std::packaged_task\"></a></h2>\n<p>std::packaged_task它包装了一个可调用的目标（如function, lambda expression, bind expression, or another function object）,以便异步调用，它和promise在某种程度上有点像，promise保存了一个共享状态的值，而packaged_task保存的是一个函数。它的基本用法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::packaged_task&lt;<span class=\"keyword\">int</span>()&gt; task([]()&#123; <span class=\"keyword\">return</span> <span class=\"number\">7</span>; &#125;);</span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"function\">thread <span class=\"title\">t1</span><span class=\"params\">(<span class=\"built_in\">std</span>::ref(task))</span></span>; </span><br><span class=\"line\"><span class=\"built_in\">std</span>::future&lt;<span class=\"keyword\">int</span>&gt; f1 = task.get_future(); </span><br><span class=\"line\"><span class=\"keyword\">auto</span> r1 = f1.get();</span><br></pre></td></tr></table></figure>\n<h2 id=\"std::promise、std::packaged_task和std::future的关系\">std::promise、std::packaged_task和std::future的关系<a title=\"#std::promise、std::packaged_task和std::future的关系\" href=\"#std::promise、std::packaged_task和std::future的关系\"></a></h2>\n<p>至此, 我们介绍了std::async相关的几个对象std::future、std::promise和std::packaged_task，其中std::promise和std::packaged_task的结果最终都是通过其内部的future返回出来的，不知道读者有没有搞糊涂，为什么有这么多东西出来，他们之间的关系到底是怎样的？且听我慢慢道来，std::future提供了一个访问异步操作结果的机制，它和线程是一个级别的属于低层次的对象，在它之上高一层的是std::packaged_task和std::promise，他们内部都有future以便访问异步操作结果，<strong>std::packaged_task包装的是一个异步操作，而std::promise包装的是一个值，都是为了方便异步操作的，因为有时我需要获取线程中的某个值，这时就用std::promise，而有时我需要获一个异步操作的返回值，这时就用std::packaged_task。</strong>那std::promise和std::packaged_task之间又是什么关系呢？说他们没关系也关系，说他们有关系也有关系，都取决于你了，因为我可以将一个异步操作的结果保存到std::promise中。如果读者还没搞清楚他们的关系的话，我就用更通俗的话来解释一下。比如，一个小伙子给一个姑娘表白真心的时候也许会说：”我许诺会给你一个美好的未来“或者”我会努力奋斗为你创造一个美好的未来“。姑娘往往会说：”我等着“。现在我来将这三句话用c++11来翻译一下：</p>\n<p>小伙子说：我许诺会给你一个美好的未来等于c<ins>11中&quot;std::promise a std::future&quot;;<br>\n小伙子说：我会努力奋斗为你创造一个美好的未来等于c</ins>11中&quot;std::packaged_task a future&quot;;<br>\n姑娘说：我等着等于c++11中&quot;future.get()/wait()&quot;;</p>\n<p>小伙子两句话的个中差异，自己琢磨一下，这点差异也是std::promise和std::packaged_task的差异。现实中的山盟海誓靠不靠得住我不知道，但是c<ins>11中的许诺和未来是一定可靠的，发起来了许诺就一定有未来。细想起来c</ins>11标准的制定者选定的关键字真是贴切而有意思！好了，插科打诨到此了，现在言归正传，回过头来说说std::async。</p>\n<h2 id=\"为什么要用std::async代替线程的创建\">为什么要用std::async代替线程的创建<a title=\"#为什么要用std::async代替线程的创建\" href=\"#为什么要用std::async代替线程的创建\"></a></h2>\n<p>std::async又是干啥的，已经有了td::future、std::promise和std::packaged_task，够多的了，真的还要一个std::async来凑热闹吗，std::async表示很委屈：我不是来凑热闹的，我是来帮忙的。是的，std::async是为了让用户的少费点脑子的，它让这三个对象默契的工作。大概的工作过程是这样的：std::async先将异步操作用std::packaged_task包装起来，然后将异步操作的结果放到std::promise中，这个过程就是创造未来的过程。外面再通过future.get/wait来获取这个未来的结果，怎么样，std::async真的是来帮忙的吧，你不用再想到底该怎么用std::future、std::promise和std::packaged_task了，std::async已经帮你搞定一切了！</p>\n<p>现在来看看std::async的原型async(std::launch::async | std::launch::deferred, f, args…)，第一个参数是线程的创建策略，有两种策略，默认的策略是立即创建线程：</p>\n<ul>\n<li>std::launch::async：在调用async就开始创建线程。</li>\n<li>std::launch::deferred：延迟加载方式创建线程。调用async时不创建线程，直到调用了future的get或者wait时才创建线程。可能在这里会阻塞住主线程。</li>\n</ul>\n<p>第二个参数是线程函数，第三个参数是线程函数的参数。</p>\n<p><strong>std::async基本用法：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::future&lt;<span class=\"keyword\">int</span>&gt; f1 = <span class=\"built_in\">std</span>::async(<span class=\"built_in\">std</span>::launch::async, []()&#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">8</span>;  </span><br><span class=\"line\">    &#125;); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;f1.get()&lt;&lt;<span class=\"built_in\">endl</span>; <span class=\"comment\">//output: 8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">std</span>::future&lt;<span class=\"keyword\">int</span>&gt; f2 = <span class=\"built_in\">std</span>::async(<span class=\"built_in\">std</span>::launch::async, []()&#123; </span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"number\">8</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;); </span><br><span class=\"line\"></span><br><span class=\"line\">f2.wait(); <span class=\"comment\">//output: 8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">std</span>::future&lt;<span class=\"keyword\">int</span>&gt; future = <span class=\"built_in\">std</span>::async(<span class=\"built_in\">std</span>::launch::async, []()&#123; </span><br><span class=\"line\">        <span class=\"built_in\">std</span>::this_thread::sleep_for(<span class=\"built_in\">std</span>::chrono::seconds(<span class=\"number\">3</span>));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">8</span>;  </span><br><span class=\"line\">    &#125;); </span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"waiting...\\n\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::future_status status;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        status = future.wait_for(<span class=\"built_in\">std</span>::chrono::seconds(<span class=\"number\">1</span>));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (status == <span class=\"built_in\">std</span>::future_status::deferred) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"deferred\\n\"</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (status == <span class=\"built_in\">std</span>::future_status::timeout) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"timeout\\n\"</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (status == <span class=\"built_in\">std</span>::future_status::ready) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"ready!\\n\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (status != <span class=\"built_in\">std</span>::future_status::ready); </span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"result is \"</span> &lt;&lt; future.get() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">可能的结果：</span><br><span class=\"line\">waiting...</span><br><span class=\"line\">timeout</span><br><span class=\"line\">timeout</span><br><span class=\"line\">ready!</span><br><span class=\"line\">result is <span class=\"number\">8</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"总结：\">总结：<a title=\"#总结：\" href=\"#总结：\"></a></h2>\n<p>std::async是更高层次上的异步操作，使我们不用关注线程创建内部细节，就能方便的获取异步执行状态和结果，还可以指定线程创建策略，应该用std::async替代线程的创建，让它成为我们做异步操作的首选。</p>\n","prev":{"title":"模版元编程应用","link":"posts/模版元编程应用"},"next":{"title":"Mutex介绍","link":"posts/Mutex介绍"},"plink":"https://shuntan.github.io/posts/C++中优雅的异步操作/","toc":[{"id":"std::futur","title":"std::futur","index":"1"},{"id":"std::promise","title":"std::promise","index":"2"},{"id":"std::packaged_task","title":"std::packaged_task","index":"3"},{"id":"std::promise、std::packaged_task和std::future的关系","title":"std::promise、std::packaged_task和std::future的关系","index":"4"},{"id":"为什么要用std::async代替线程的创建","title":"为什么要用std::async代替线程的创建","index":"5"},{"id":"总结：","title":"总结：","index":"6"}],"reward":true,"copyright":{"author":"Shawntan","link":"<a href=\"https://shuntan.github.io/posts/C++中优雅的异步操作/\" title=\"C++中优雅的异步操作\">https://shuntan.github.io/posts/C++中优雅的异步操作/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow noopener\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","published":"June 14, 2019","updated":"April 14, 2020"}}