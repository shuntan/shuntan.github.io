{"title":"编译器架构的王者LLVM——使用JIT引擎","date":"2019-09-11T12:15:43.000Z","link":"posts/编译器架构的王者LLVM——使用JIT引擎","comments":true,"tags":["C++"],"categories":["编译器"],"updated":"2019-09-16T11:32:20.010Z","content":"<h1 id=\"使用JIT引擎\">使用JIT引擎<a href=\"posts/编译器架构的王者LLVM——使用JIT引擎#使用JIT引擎\"></a></h1><p>LLVM从设计之初就考虑了解释执行的功能,这非常其作为一款跨平台的中间字节码来使用,可以方便地跨平台运行。又具有编译型语言的优势，非常的方便。</p>\n<p>我们使用的LLVM3.6版，移除了原版JIT，改换成了新版的MCJIT，性格有了不小的提升，本文就MCJIT的使用和注意事项，进行简要的介绍。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"JIT技术\">JIT技术<a href=\"posts/编译器架构的王者LLVM——使用JIT引擎#JIT技术\"></a></h1><p>Just-In-Time Compiler，是一种动态编译中间代码的方式，根据需要，在程序中编译并执行生成的机器码，能够大幅提升动态语言的执行速度。</p>\n<p>像Java语言，.net平台，luajit等，广泛使用jit技术，使得程序达到了非常高的执行效率，逐渐接近原生机器语言代码的性能了。</p>\n<p>JIT引擎的工作原理并没有那么复杂，本质上是将原来编译器要生成机器码的部分要直接写入到当前的内存中，然后通过函数指针的转换，找到对应的机器码并进行执行。</p>\n<p>但实践中往往需要处理许多头疼的问题，例如内存的管理，符号的重定向，处理外部符号，相当于要处理编译器后端的诸多复杂的事情，真正要设计一款能用的JIT引擎还是非常困难的。</p>\n<p>使用LLVM的MCJIT能开发什么<br>当然基本的功能是提供一款解释器的底层工具，将LLVM字节码解释执行，具体能够做的事，例如可以制作一款跨平台的C++插件系统，使用clang将C/C++代码一次编译到.bc字节码，然后在各个平台上解释运行。也可以制作一款云调试系统，联网远程向系统注册方法，获取C++客户端的debug信息等等。当然，还有很多其他的用法等着大家来开发。</p>\n<h1 id=\"使用MCJIT做一款解释器\">使用MCJIT做一款解释器<a href=\"posts/编译器架构的王者LLVM——使用JIT引擎#使用MCJIT做一款解释器\"></a></h1><p>制作LLVM字节码的解释器还是非常简单的，最棒的示例应该是LLVM源码中的工具：lli</p>\n<p>一共700行左右的C++代码，调用LLVM工具集实现了LLVM字节码JIT引擎，如果想很好的学习llvm中的解释器和JIT，可以参考其在<a href=\"https://github.com/llvm-mirror/llvm/blob/master/tools/lli/lli.cpp\" target=\"_blank\" rel=\"noopener\">github</a>上的源码。</p>\n<p>初始化系统<br>使用LLVM的JIT功能，需要调用几条初始化语句，可以放在main函数开始时。</p>\n<figure class=\"highlight abnf\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InitializeNativeTarget()<span class=\"comment\">;</span></span><br><span class=\"line\">InitializeNativeTargetAsmPrinter()<span class=\"comment\">;</span></span><br><span class=\"line\">InitializeNativeTargetAsmParser()<span class=\"comment\">;</span></span><br></pre></td></tr></table></div></figure>\n\n<p>这几句调用，主要是在处理JIT的TargetMachine，初始化机器相关编译目标。</p>\n<h1 id=\"引用相关的头文件\">引用相关的头文件<a href=\"posts/编译器架构的王者LLVM——使用JIT引擎#引用相关的头文件\"></a></h1><p>这里的稍稍有点多余的，不去管了。，llvm的头文件是层次组织的，像执行引擎，都在llvm/ExecutionEngine/下，而IR相关的，也都在llvm/IR/下，初用LLVM往往搞不清需要哪些，这时就需要多查相关的文档，了解LLVM的各个模块的功能。</p>\n<figure class=\"highlight c++\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"llvm/ExecutionEngine/GenericValue.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"llvm/ExecutionEngine/MCJIT.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"llvm/ExecutionEngine/Interpreter.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"llvm/ExecutionEngine/SectionMemoryManager.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"llvm/IR/Verifier.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"llvm/IR/Constants.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"llvm/IR/DerivedTypes.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"llvm/IR/IRBuilder.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"llvm/IR/Instructions.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"llvm/IR/LLVMContext.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"llvm/IR/Module.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;llvm/IRReader/IRReader.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;llvm/Support/SourceMgr.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"llvm/Support/ManagedStatic.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"llvm/Support/TargetSelect.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;llvm/Support/MemoryBuffer.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"llvm/Support/raw_ostream.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;llvm/Support/DynamicLibrary.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"llvm/Support/Debug.h\"</span></span></span><br></pre></td></tr></table></div></figure>\n\n<p>主要说要注意的几个细节，首先是</p>\n<figure class=\"highlight autoit\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"string\">\"llvm/ExecutionEngine/MCJIT.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"string\">\"llvm/ExecutionEngine/Interpreter.h\"</span></span></span><br></pre></td></tr></table></div></figure>\n\n<p>C++编译时，这两个头文件居然不是必须的，如果你不注意时，编译不会报错。因为执行引擎是一个接口的模式，不对外暴露子类的细节，我们必须注意引用其中一个或两个都引用，否则会链接不到对应的引擎。</p>\n<p>会报如下错误：</p>\n<p>Create Engine Error<br>JIT has not been linked in.</p>\n<p><img src=\"https://img-blog.csdn.net/20160108201207936\" alt=\"ç±»ç»æ\" class=\"article-img\"></p>\n<h1 id=\"使用EngineBuilder构建JIT引擎\">使用EngineBuilder构建JIT引擎<a href=\"posts/编译器架构的王者LLVM——使用JIT引擎#使用EngineBuilder构建JIT引擎\"></a></h1><p>由于JIT引擎我们不需要创建多个，我们这里使用单例类的方式，使用一个LLVM中的Module进行初始化，如果引擎已经创建过，我们可以使用addModule方法，将LLVM的Module添加到引擎的Module集合中。</p>\n<p>finalizeObject函数，是一个关键的函数，对应JIT引擎很重要，我们要保障我们在调用JIT编译后的代码前，要调用过该函数</p>\n<figure class=\"highlight c++\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutionEngine* EE = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">RTDyldMemoryManager* RTDyldMM = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">initEE</span><span class=\"params\">(<span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;Module&gt; Owner)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> ErrStr;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (EE == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        RTDyldMM = <span class=\"keyword\">new</span> SectionMemoryManager();</span><br><span class=\"line\">        EE = EngineBuilder(<span class=\"built_in\">std</span>::move(Owner))</span><br><span class=\"line\">            .setEngineKind(EngineKind::JIT)</span><br><span class=\"line\">            .setErrorStr(&amp;ErrStr)</span><br><span class=\"line\">            .setVerifyModules(<span class=\"literal\">true</span>)</span><br><span class=\"line\">            .setMCJITMemoryManager(<span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;RTDyldMemoryManager&gt;(RTDyldMM))</span><br><span class=\"line\">            .setOptLevel(CodeGenOpt::Default)</span><br><span class=\"line\">            .create();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">    EE-&gt;addModule(<span class=\"built_in\">std</span>::move(Owner));</span><br><span class=\"line\"><span class=\"keyword\">if</span> (ErrStr.length() != <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"built_in\">cerr</span> &lt;&lt; <span class=\"string\">\"Create Engine Error\"</span> &lt;&lt; <span class=\"built_in\">endl</span> &lt;&lt; ErrStr &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">EE-&gt;finalizeObject();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>这里是finalizeObject的文档解释：</p>\n<p>finalizeObject - ensure the module is fully processed and is usable.</p>\n<p>It is the user-level function for completing the process of making the object usable for execution. It should be called after sections within an object have been relocated using mapSectionAddress. When this method is called the MCJIT execution engine will reapply relocations for a loaded object. This method has no effect for the interpeter.</p>\n<p>setEngineKind可选的有JIT和Interpreter，如果默认的话，则是优先JIT，检测到哪个引擎能用就用哪个。</p>\n<p>setMCJITMemoryManager是一个关键的管理器，当然貌似默认不写也会构建，这里我们为了清晰所见，还是添加了这条配置，这个内存管理器在执行引擎中很重要，一般本地的应用我们要选择SectionMemoryManager类，而lli中甚至还包含着远程调用的相关类。</p>\n<p>setOptLevel是设置代码的优化等级，默认是O2，可以修改为下面枚举值：</p>\n<p>None<br>Less<br>Default<br>Aggressive<br>MCJIT架构图</p>\n<h1 id=\"编写核心的调用方法\">编写核心的调用方法<a href=\"posts/编译器架构的王者LLVM——使用JIT引擎#编写核心的调用方法\"></a></h1><figure class=\"highlight c++\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(*func_type)</span><span class=\"params\">(<span class=\"keyword\">void</span>*)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// path是bc文件的路径，func_name是要执行的函数名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Run</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; path, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; func_name)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// 首先要读取要执行的bc字节码</span></span><br><span class=\"line\">SMDiagnostic error;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;Module&gt; Owner = parseIRFile(path, error, context);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(Owner == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Load Error: \"</span> &lt;&lt; path &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    Owner-&gt;dump();</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 单例的方法进行初始化，暂未考虑多线程</span></span><br><span class=\"line\">initEE(<span class=\"built_in\">std</span>::move(Owner));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取编译后的函数指针并执行</span></span><br><span class=\"line\"><span class=\"keyword\">uint64_t</span> func_addr = EE-&gt;getFunctionAddress(func_name.c_str());</span><br><span class=\"line\"><span class=\"keyword\">if</span> (func_addr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"错误, 找不到函数: %s\\n\"</span>, func_name.c_str());</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func_type func = (func_type) func_addr;</span><br><span class=\"line\">func(<span class=\"literal\">NULL</span>); <span class=\"comment\">// 需要传参数时可以从这里传递</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h1 id=\"解释器版本\">解释器版本<a href=\"posts/编译器架构的王者LLVM——使用JIT引擎#解释器版本\"></a></h1><p>解释器效率稍低一下，不过能够做到惰性的一下代码载入和执行工作，有时也很有用途。下面我们就在jit的基础上，介绍一下简单的解释器功能。介绍器最主要需要做的就是将生成引擎改变：</p>\n<figure class=\"highlight c++\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EE = EngineBuilder(<span class=\"built_in\">std</span>::move(Owner))</span><br><span class=\"line\">    <span class=\"comment\">// 这里改完解释器</span></span><br><span class=\"line\">    .setEngineKind(EngineKind::Interpreter)</span><br><span class=\"line\">    .setErrorStr(&amp;ErrStr)</span><br><span class=\"line\">    .setVerifyModules(<span class=\"literal\">true</span>)</span><br><span class=\"line\">    .setMCJITMemoryManager(<span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;RTDyldMemoryManager&gt;(RTDyldMM))</span><br><span class=\"line\">    .setOptLevel(CodeGenOpt::Default)</span><br><span class=\"line\">    .create();</span><br></pre></td></tr></table></div></figure>\n\n<p>另外解释器可以使用getLazyIRFileModule函数可以替换parseIRFile实现.bc文件的惰性加载。</p>\n<p>解释器的执行方式和JIT有一些不同，要使用FindFunctionNamed函数来寻找对应的函数对象，解释器能够获取更全的LLVM字节码的中间信息，例如一些属性和元数据，在做一些灵活的动态语言解释器时是非常有用的。</p>\n<figure class=\"highlight c++\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 给解释器使用的部分</span></span><br><span class=\"line\">Function* func = EE-&gt;FindFunctionNamed(func_name.c_str());</span><br><span class=\"line\"><span class=\"keyword\">if</span> (func == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"忽略, 找不到函数: %s\\n\"</span>, func_name.c_str());</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 如果需要传参数的话</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;GenericValue&gt; args;</span><br><span class=\"line\">args.push_back(GenericValue(<span class=\"literal\">NULL</span>));</span><br><span class=\"line\">EE-&gt;runFunction(func, args);</span><br><span class=\"line\">创建测试的C代码</span><br><span class=\"line\">我在是Elite编译器工程下开发的，所以会有接口调用的测试，大家可以，创建简单的C函数进行调用测试：</span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span></span><br><span class=\"line\">test２_elite_plugin_init(CodeGenContext* context) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"test２_elite_plugin_init\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (context == <span class=\"literal\">NULL</span>) <span class=\"built_in\">printf</span>(<span class=\"string\">\"Error for context\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> context-&gt;AddOrReplaceMacros(macro_funcs);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">执行结果：</span><br></pre></td></tr></table></div></figure>\n\n<p>最近研究的LLVM技术，大部分应用于正在进行的ELite编译器开发，欢迎朋友们关注和参与。<br>github: <a href=\"https://github.com/elite-lang/Elite\" target=\"_blank\" rel=\"noopener\">https://github.com/elite-lang/Elite</a><br>文档: <a href=\"http://elite-lang.org/doc/zh-cn/\" target=\"_blank\" rel=\"noopener\">http://elite-lang.org/doc/zh-cn/</a></p>\n<hr>\n<p>版权声明：本文为CSDN博主「西风逍遥游」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/xfxyy_sxfancy/article/details/50485090\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xfxyy_sxfancy/article/details/50485090</a></p>\n","next":{"title":"源码解读Linux的limits.conf文件","link":"posts/源码解读Linux的limits-conf文件"},"plink":"https://shuntan.github.io/posts/编译器架构的王者LLVM——使用JIT引擎/","toc":[{"title":"使用JIT引擎","id":"使用JIT引擎","index":"1"},{"title":"JIT技术","id":"JIT技术","index":"2"},{"title":"使用MCJIT做一款解释器","id":"使用MCJIT做一款解释器","index":"3"},{"title":"引用相关的头文件","id":"引用相关的头文件","index":"4"},{"title":"使用EngineBuilder构建JIT引擎","id":"使用EngineBuilder构建JIT引擎","index":"5"},{"title":"编写核心的调用方法","id":"编写核心的调用方法","index":"6"},{"title":"解释器版本","id":"解释器版本","index":"7"}],"reward":true,"copyright":{"author":"Shawntan","link":"<a href=\"https://shuntan.github.io/posts/编译器架构的王者LLVM——使用JIT引擎/\" title=\"编译器架构的王者LLVM——使用JIT引擎\">https://shuntan.github.io/posts/编译器架构的王者LLVM——使用JIT引擎/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow noopener\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","published":"September 11, 2019","updated":"September 16, 2019"}}