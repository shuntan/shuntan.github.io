{"title":"C++中的万能引用和完美转发","date":"2019-05-29T02:05:19.000Z","thumbnail":null,"link":"post/完美转发","comments":true,"tags":["C++"],"categories":["C++"],"updated":"2019-07-14T01:22:44.423Z","content":"<h2 id=\"c-中的万能引用和完美转发\">C++中的万能引用和完美转发<a href=\"post/完美转发#c-中的万能引用和完美转发\"></a></h2>\n<ul>\n<li>\n<p>阅读这篇博文需要了解C<ins>中的左值（lvalue）和右值（rvalue）的概念，详情参见我的另外一篇博文：C</ins>移动语义及拷贝优化</p>\n</li>\n<li>\n<p>万能引用和完美转发多涉及到模板的使用，如若不是自己写模板，则可不用关心</p>\n</li>\n</ul>\n<h3 id=\"万能引用-universal-reference\">万能引用（Universal Reference）<a href=\"post/完美转发#万能引用-universal-reference\"></a></h3>\n<p>首先，我们来看一个例子：</p>\n<a id=\"more\"></a>\n<figure class=\"highlight cpp\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(T&amp; param)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; param &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num = <span class=\"number\">2019</span>;</span><br><span class=\"line\">    func(num);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这样例子的编译输出都没有什么问题，但是如果我们修改成下面的调用方式呢？</p>\n<figure class=\"highlight autoit\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> main() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"number\">2019</span>)</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span><span class=\"comment\">;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>则会得到一个大大的编译错误。因为上面的模板函数只能接受左值或者左值引用（左值一般是有名字的变量，可以取到地址的），我们当然可以重载一个接受右值的模板函数，如下也可以达到效果。</p>\n<figure class=\"highlight cpp\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(T&amp; param)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"传入的是左值\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"传入的是右值\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num = <span class=\"number\">2019</span>;</span><br><span class=\"line\">    func(num);</span><br><span class=\"line\">    func(<span class=\"number\">2019</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>输出结果：</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">传入的是左值</span><br><span class=\"line\">传入的是右值</span><br></pre></td></tr></table></div></figure>\n<p>第一次函数调用的是左值得版本，第二次函数调用的是右值版本。但是，有没有办法只写一个模板函数即可以接收左值又可以接收右值呢？</p>\n<p>C++ 11中有万能引用（Universal Reference）的概念：使用T&amp;&amp;类型的形参既能绑定右值，又能绑定左值。</p>\n<p>但是注意了：<strong>只有发生类型推导的时候，T&amp;&amp;才表示万能引用；</strong> 否则，表示右值引用。</p>\n<p>所以，上面的案例我们可以修改为：</p>\n<figure class=\"highlight autoit\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">void <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(T&amp;&amp; param)</span> &#123;</span></span><br><span class=\"line\">    cout &lt;&lt; param &lt;&lt; endl<span class=\"comment\">;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">int</span> main() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> num = <span class=\"number\">2019</span><span class=\"comment\">;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(num)</span>;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"number\">2019</span>)</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span><span class=\"comment\">;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<h2 id=\"引用折叠-universal-collapse\">引用折叠（Universal Collapse）<a href=\"post/完美转发#引用折叠-universal-collapse\"></a></h2>\n<p>万能引用说完了，接着来聊引用折叠（Univers Collapse），因为完美转发（Perfect Forwarding）的概念涉及引用折叠。一个模板函数，根据定义的形参和传入的实参的类型，我们可以有下面四中组合：</p>\n<ul>\n<li>左值-左值 T&amp; &amp;        # 函数定义的形参类型是左值引用，传入的实参是左值引用</li>\n<li>左值-右值 T&amp; &amp;&amp;      # 函数定义的形参类型是左值引用，传入的实参是右值引用</li>\n<li>右值-左值 T&amp;&amp; &amp;      # 函数定义的形参类型是右值引用，传入的实参是左值引用</li>\n<li>右值-右值 T&amp;&amp; &amp;&amp;    # 函数定义的形参类型是右值引用，传入的实参是右值引用</li>\n</ul>\n<p>但是C++中不允许对引用再进行引用，对于上述情况的处理有如下的规则：</p>\n<p>所有的折叠引用最终都代表一个引用，要么是左值引用，要么是右值引用。规则是：如果任一引用为左值引用，则结果为左值引用。否则（即两个都是右值引用），结果为右值引用。</p>\n<p>即就是前面三种情况代表的都是左值引用，而第四种代表的右值引用。</p>\n<h2 id=\"完美转发-perfect-forwarding\">完美转发（Perfect Forwarding）<a href=\"post/完美转发#完美转发-perfect-forwarding\"></a></h2>\n<p>下面接着说完美转发（Perfect Forwarding），首先，看2个例子：</p>\n<p>🌰栗子[1]<br>\n要了解完美转发，先得清楚模板T的<strong>推导过程</strong>，<span class=\"label success\">在没有偏特化的模版前提下，模板总是根据最匹配的规则来推导参数</span>，可以根据下面的例子来看出推导过程。</p>\n<figure class=\"highlight cpp\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> is_lval = <span class=\"built_in\">std</span>::is_lvalue_reference&lt;T&gt;::value;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> is_rval  = <span class=\"built_in\">std</span>::is_rvalue_reference&lt;T&gt;::value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">std</span>::is_same&lt;T, <span class=\"keyword\">int</span>&gt;::value) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"'T' is type[int]\"</span> &lt;&lt; <span class=\"string\">\" ?is lvalue reference:\"</span> &lt;&lt; is_lval &lt;&lt;</span><br><span class=\"line\">                     <span class=\"string\">\" ?is rvalue reference:\"</span> &lt;&lt; is_rval &lt;&lt; <span class=\"string\">\" arg:\"</span> &lt;&lt; arg &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">std</span>::is_same&lt;T, <span class=\"keyword\">int</span>&amp;&gt;::value) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"'T' is type[int&amp;]\"</span> &lt;&lt; <span class=\"string\">\" ?is lvalue reference:\"</span> &lt;&lt; is_lval &lt;&lt;</span><br><span class=\"line\">                     <span class=\"string\">\" ?is rvalue reference:\"</span> &lt;&lt; is_rval &lt;&lt; <span class=\"string\">\" arg:\"</span> &lt;&lt; arg &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">std</span>::is_same&lt;T, <span class=\"keyword\">int</span>&amp;&amp;&gt;::value) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"'T' is type[int&amp;&amp;]\"</span> &lt;&lt; <span class=\"string\">\" ?is lvalue reference:\"</span> &lt;&lt; is_lval &lt;&lt;</span><br><span class=\"line\">                     <span class=\"string\">\" ?is rvalue reference:\"</span> &lt;&lt; is_rval &lt;&lt; <span class=\"string\">\" arg:\"</span> &lt;&lt; arg &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"-----------------\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">  func(a);</span><br><span class=\"line\">  func(<span class=\"number\">2</span>);</span><br><span class=\"line\">  func(<span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&amp;&gt;(a));</span><br><span class=\"line\">  func(<span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&amp;&amp;&gt;(a));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>输出结果为：</p>\n<figure class=\"highlight vim\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'T'</span> <span class=\"keyword\">is</span> <span class=\"built_in\">type</span>[<span class=\"keyword\">int</span>&amp;] ?<span class=\"keyword\">is</span> lvalue reference:<span class=\"number\">1</span> ?<span class=\"keyword\">is</span> rvalue reference:<span class=\"number\">0</span> <span class=\"keyword\">ar</span><span class=\"variable\">g:1</span></span><br><span class=\"line\">-----------------</span><br><span class=\"line\"><span class=\"string\">'T'</span> <span class=\"keyword\">is</span> <span class=\"built_in\">type</span>[<span class=\"keyword\">int</span>] ?<span class=\"keyword\">is</span> lvalue reference:<span class=\"number\">0</span> ?<span class=\"keyword\">is</span> rvalue reference:<span class=\"number\">0</span> <span class=\"keyword\">ar</span><span class=\"variable\">g:2</span></span><br><span class=\"line\">-----------------</span><br><span class=\"line\"><span class=\"string\">'T'</span> <span class=\"keyword\">is</span> <span class=\"built_in\">type</span>[<span class=\"keyword\">int</span>&amp;] ?<span class=\"keyword\">is</span> lvalue reference:<span class=\"number\">1</span> ?<span class=\"keyword\">is</span> rvalue reference:<span class=\"number\">0</span> <span class=\"keyword\">ar</span><span class=\"variable\">g:1</span></span><br><span class=\"line\">-----------------</span><br><span class=\"line\"><span class=\"string\">'T'</span> <span class=\"keyword\">is</span> <span class=\"built_in\">type</span>[<span class=\"keyword\">int</span>] ?<span class=\"keyword\">is</span> lvalue reference:<span class=\"number\">0</span> ?<span class=\"keyword\">is</span> rvalue reference:<span class=\"number\">0</span> <span class=\"keyword\">ar</span><span class=\"variable\">g:1</span></span><br><span class=\"line\">-----------------</span><br></pre></td></tr></table></div></figure>\n<p>可以发现，当实参数是以值传递的方式推导时，左值传递T为int&amp;，右值传递T为int。为什么会这样呢？</p>\n<p>如果将模版参数显示绑定：</p>\n<figure class=\"highlight cpp\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">  func&lt;<span class=\"keyword\">int</span>&gt;(a); <span class=\"comment\">//错误❌</span></span><br><span class=\"line\">  func&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">2</span>);</span><br><span class=\"line\">  func&lt;<span class=\"keyword\">int</span>&amp;&gt;(<span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&amp;&gt;(a));</span><br><span class=\"line\">  func&lt;<span class=\"keyword\">int</span>&amp;&amp;&gt;(<span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&amp;&amp;&gt;(a));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>会发现无法编译通过：</p>\n<figure class=\"highlight subunit\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In function 'int main()'</span><br><span class=\"line\"><span class=\"keyword\">error: </span>no matching for call to 'func(int&amp;)'</span><br><span class=\"line\">\tfunc&lt;int&gt;(a);</span><br><span class=\"line\">\t...</span><br></pre></td></tr></table></div></figure>\n<span class=\"label success\">根据C++ Primer中文版(第五版) 18章第2节模板实参推断</span>\n<p><strong>Note:如果一个函数参数是指向模版板参数类型的右值引用(如，T&amp;&amp;)，则可以传递给它任意类型的实参。如果将一个左值传递给这样的参数，则函数参数被实例化为一个普通的左值引用(T&amp;)。</strong>，估计是编译器做了特殊的处理。</p>\n<p>由于int无法匹配T&amp;&amp;，所以只能根据<span class=\"label success\">引用折叠（Universal Collapse）</span>规则，int&amp; &amp;&amp;=int&amp;，int &amp;&amp;= int&amp;&amp;。保留了参数的左值右值特性。<br>\n这也符合引用折叠规则。</p>\n<p>当实参数以左值引用和右值引用的方式推导时，int&amp;还是无法匹配T&amp;&amp;，所以T=int&amp;，而int&amp;&amp;刚好匹配T&amp;&amp;，所以T就是int。</p>\n<p>🌰栗子[2]</p>\n<p>为了方便观察调用过程，我们在std::forward函数copy出来，增加输出一条内容，改为test::forward，其他保持不变。</p>\n<figure class=\"highlight cpp\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/move.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// add print content</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> test&#123;</span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> _Tp&gt;</span><br><span class=\"line\">  <span class=\"keyword\">constexpr</span> _Tp&amp;&amp;</span><br><span class=\"line\">  forward(<span class=\"keyword\">typename</span> <span class=\"built_in\">std</span>::remove_reference&lt;_Tp&gt;::type&amp; <span class=\"keyword\">__t</span>) <span class=\"keyword\">noexcept</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Forward an l-value.\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class=\"keyword\">__t</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> _Tp&gt;</span><br><span class=\"line\">  <span class=\"keyword\">constexpr</span> _Tp&amp;&amp;</span><br><span class=\"line\">  forward(<span class=\"keyword\">typename</span> <span class=\"built_in\">std</span>::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class=\"keyword\">__t</span>) <span class=\"keyword\">noexcept</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Forward an r-value.\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static_assert</span>(!<span class=\"built_in\">std</span>::is_lvalue_reference&lt;_Tp&gt;::value, <span class=\"string\">\"template argument\"</span></span><br><span class=\"line\">          <span class=\"string\">\" substituting _Tp is an lvalue reference type\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class=\"keyword\">__t</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// my template functions</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(T&amp; param)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"传入的是左值\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"传入的是右值\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">warp</span><span class=\"params\">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class=\"line\">    func(param);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num = <span class=\"number\">2019</span>;</span><br><span class=\"line\">    warp(num);</span><br><span class=\"line\">    warp(<span class=\"number\">2019</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;&#125;</span><br></pre></td></tr></table></div></figure>\n<p>输出结果为：</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">传入的是左值</span><br><span class=\"line\">传入的是左值</span><br></pre></td></tr></table></div></figure>\n<p>是不是和我们预期的不一样，下面我们来分析一下原因：</p>\n<p><strong>warp()</strong>函数本身的形参是一个万能引用，即可以接受左值又可以接受右值；第一个warp()函数调用实参是左值，所以，<strong>warp()</strong>函数中调用<strong>func()</strong>中传入的参数也应该是左值；第二个warp()函数调用实参是右值，根据上面所说的引用折叠规则，<strong>warp()函数接收的参数类型是右值引用，那么为什么却调用了调用func()的左值版本了呢？</strong>这是因为在warp()函数内部，右值引用类型变为了左值，因为参数有了名称，我们也通过变量名取得变量地址。</p>\n<p>结论：无论传入wrap()的参数是左值还是右值，到了函数内部都变成了左值。</p>\n<p>那么问题来了，怎么保持函数调用过程中，变量类型的不变呢？这就是我们所谓的“完美转发”技术，在C++11中通过std::forward()函数来实现。我们修改我们的warp()函数如下：</p>\n<figure class=\"highlight swift\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename <span class=\"type\">T</span>&gt;</span><br><span class=\"line\">void warp(<span class=\"type\">T</span>&amp;&amp; param) &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(test::forward&lt;T&gt;<span class=\"params\">(param)</span></span></span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>输出结果为：</p>\n<figure class=\"highlight livecodeserver\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Forward <span class=\"keyword\">an</span> l-<span class=\"built_in\">value</span>.</span><br><span class=\"line\">传入的是左值</span><br><span class=\"line\">Forward <span class=\"keyword\">an</span> l-<span class=\"built_in\">value</span>.</span><br><span class=\"line\">传入的是右值</span><br></pre></td></tr></table></div></figure>\n<p>现在跟我们的预期一致了，但是原理是什么呢？观察forward()函数内部不难发现，传入的参数做了<strong>移除引用</strong>的操作，使其都为&amp;&amp; 或 &amp;，所以有2个函数版本，重点在于模版返回的时候<strong>return static_cast&lt;_Tp&amp;&amp;&gt;(__t);</strong>强制将实参转换成T原有的引用类型，根据<strong>引用折叠</strong>原则，T&amp;&amp; &amp;还是&amp;，T&amp;&amp; &amp;&amp;还是&amp;&amp;。所以实现了“完美转发”。</p>\n<p>如果将wrap()函数改为这样呢？</p>\n<figure class=\"highlight swift\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename <span class=\"type\">T</span>&gt;</span><br><span class=\"line\">void warp(<span class=\"type\">T</span>&amp;&amp; param) &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(test::forward&lt;T&gt;<span class=\"params\">(std::move<span class=\"params\">(param)</span></span></span></span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>编译结果：</p>\n<figure class=\"highlight vim\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error：</span><br><span class=\"line\">static_assert(template <span class=\"keyword\">argument</span> substituting _Tp <span class=\"keyword\">is</span> <span class=\"keyword\">an</span> lvalue reference <span class=\"built_in\">type</span><span class=\"comment\">\");</span></span><br></pre></td></tr></table></div></figure>\n<p>可以发现成功走到了第二个forward()函数版本。将<strong>static_assert&lt;&gt;</strong>注释掉，编译通过。输出结果为：</p>\n<figure class=\"highlight livecodeserver\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Forward <span class=\"keyword\">an</span> r-<span class=\"built_in\">value</span>.</span><br><span class=\"line\">传入的是左值</span><br><span class=\"line\">Forward <span class=\"keyword\">an</span> r-<span class=\"built_in\">value</span>.</span><br><span class=\"line\">传入的是右值</span><br></pre></td></tr></table></div></figure>\n<p>对比std::move()的返回值就可以发现，它的返回值是<strong>return static_cast&lt;typename  std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(__t);</strong>不难看出，必是右值引用。而std::forward()函数则将其按T的引用类型保持不变原样返回。</p>\n","prev":{"title":"C++ 模板偏特化－来自STL的思考","link":"post/模板特化"},"next":{"title":"从4行代码看右值引用","link":"post/右值引用"},"plink":"https://shuntan.github.io/post/完美转发/","toc":[{"title":"C++中的万能引用和完美转发","id":"c-中的万能引用和完美转发","index":"1","children":[{"title":"万能引用（Universal Reference）","id":"万能引用-universal-reference","index":"1.1"}]},{"title":"引用折叠（Universal Collapse）","id":"引用折叠-universal-collapse","index":"2"},{"title":"完美转发（Perfect Forwarding）","id":"完美转发-perfect-forwarding","index":"3"}],"reward":true,"copyright":{"author":"Shawntan","link":"<a href=\"https://shuntan.github.io/post/完美转发/\" title=\"C++中的万能引用和完美转发\">https://shuntan.github.io/post/完美转发/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow noopener\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","published":"May 29, 2019","updated":"July 14, 2019"}}