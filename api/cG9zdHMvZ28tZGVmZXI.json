{"title":"理解 Go defer","date":"2020-04-23T14:57:34.000Z","date_formatted":{"ll":"Apr 23, 2020","L":"04/23/2020","MM-DD":"04-23"},"thumbnail":"/posts/go-defer/go-defer.png","link":"posts/go-defer","comments":true,"tags":["go"],"categories":["go"],"updated":"2020-04-23T15:12:54.701Z","content":"<h2 id=\"defer-的作用和执行时机\">defer 的作用和执行时机<a title=\"#defer-的作用和执行时机\" href=\"#defer-的作用和执行时机\"></a></h2>\n<p>go 的 defer 语句是用来<strong>延迟执行函数的</strong>，而且延迟发生在<strong>调用函数 return 之后</strong>，比如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">a</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> b()</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>b 的执行是发生在 return 0 之后，注意 defer 的语法，关键字 defer 之后是函数的调用。</p>\n<a id=\"more\"></a>\n<h2 id=\"defer-的重要用途一：清理释放资源\">defer 的重要用途一：清理释放资源<a title=\"#defer-的重要用途一：清理释放资源\" href=\"#defer-的重要用途一：清理释放资源\"></a></h2>\n<p>由于 defer 的延迟特性，defer 常用在函数调用结束之后清理相关的资源，比如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f, _ := os.Open(filename)</span><br><span class=\"line\"><span class=\"keyword\">defer</span> f.Close()</span><br></pre></td></tr></table></figure>\n<p>文件资源的释放会在函数调用结束之后借助 defer 自动执行，不需要时刻记住哪里的资源需要释放，打开和释放必须相对应。</p>\n<p>用一个例子深刻诠释一下 defer 带来的便利和简洁。</p>\n<p>代码的主要目的是打开一个文件，然后复制内容到另一个新的文件中，没有 defer 时这样写：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CopyFile</span><span class=\"params\">(dstName, srcName <span class=\"keyword\">string</span>)</span> <span class=\"params\">(written <span class=\"keyword\">int64</span>, err error)</span></span> &#123;</span><br><span class=\"line\">    src, err := os.Open(srcName)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    dst, err := os.Create(dstName)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123; <span class=\"comment\">//1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    written, err = io.Copy(dst, src)</span><br><span class=\"line\">    dst.Close()</span><br><span class=\"line\">    src.Close()</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码在 <code>#1</code> 处返回之后，src 文件没有执行关闭操作，可能会导致资源不能正确释放，改用 defer 实现：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CopyFile</span><span class=\"params\">(dstName, srcName <span class=\"keyword\">string</span>)</span> <span class=\"params\">(written <span class=\"keyword\">int64</span>, err error)</span></span> &#123;</span><br><span class=\"line\">    src, err := os.Open(srcName)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> src.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">    dst, err := os.Create(dstName)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> dst.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> io.Copy(dst, src)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>src 和 dst 都能及时清理和释放，无论 return 在什么地方执行。</p>\n<p>鉴于 defer 的这种作用，defer 常用来释放数据库连接，文件打开句柄等释放资源的操作。</p>\n<h2 id=\"defer-的重要用途二：执行-recover\">defer 的重要用途二：执行 recover<a title=\"#defer-的重要用途二：执行-recover\" href=\"#defer-的重要用途二：执行-recover\"></a></h2>\n<p>被 defer 的函数在 return 之后执行，这个时机点正好可以捕获函数抛出的 panic，因而 defer 的另一个重要用途就是执行 recover。</p>\n<p>recover 只有在 defer 中使用才更有意义，如果在其他地方使用，由于 program 已经调用结束而提前返回而无法有效捕捉错误。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ok := <span class=\"built_in\">recover</span>(); ok != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            fmt.Println(<span class=\"string\">\"recover\"</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">\"error\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>记住 defer 要放在 panic 执行之前。</p>\n<h2 id=\"多个-defer-的执行顺序\">多个 defer 的执行顺序<a title=\"#多个-defer-的执行顺序\" href=\"#多个-defer-的执行顺序\"></a></h2>\n<p>defer 的作用就是把关键字之后的函数执行压入一个栈中延迟执行，多个 defer 的执行顺序是后进先出 LIFO ：</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">defer <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> &#123; <span class=\"title\">fmt</span>.<span class=\"title\">Println</span><span class=\"params\">(<span class=\"string\">\"1\"</span>)</span> &#125;<span class=\"params\">()</span></span></span><br><span class=\"line\">defer <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> &#123; <span class=\"title\">fmt</span>.<span class=\"title\">Println</span><span class=\"params\">(<span class=\"string\">\"2\"</span>)</span> &#125;<span class=\"params\">()</span></span></span><br><span class=\"line\">defer <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> &#123; <span class=\"title\">fmt</span>.<span class=\"title\">Println</span><span class=\"params\">(<span class=\"string\">\"3\"</span>)</span> &#125;<span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure>\n<p>输出顺序是 321。</p>\n<p>这个特性可以对一个 array 实现逆序操作。</p>\n<h2 id=\"被-deferred-函数的参数在-defer-时确定\">被 deferred 函数的参数在 defer 时确定<a title=\"#被-deferred-函数的参数在-defer-时确定\" href=\"#被-deferred-函数的参数在-defer-时确定\"></a></h2>\n<p>这是 defer 的特点，一个函数被 defer 时，它的参数在 defer 时进行计算确定，即使 defer 之后参数发生修改，对已经 defer 的函数没有影响，什么意思？看例子：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">func</span> <span class=\"selector-tag\">a</span>() &#123;</span><br><span class=\"line\">    <span class=\"attribute\">i </span>:= <span class=\"number\">0</span></span><br><span class=\"line\">    defer fmt.<span class=\"built_in\">Println</span>(i)</span><br><span class=\"line\">    i++</span><br><span class=\"line\">    return</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>a 执行输出的是 0 而不是 1，因为 defer 时，i 的值是 0，此时被 defer 的函数参数已经进行执行计算并确定了。</p>\n<p>再看一个例子：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">calc</span><span class=\"params\">(index <span class=\"keyword\">string</span>, a, b <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    ret := a + b</span><br><span class=\"line\">    fmt.Println(index, a, b, ret)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    a := <span class=\"number\">1</span></span><br><span class=\"line\">    b := <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">defer</span> calc(<span class=\"string\">\"1\"</span>, a, calc(<span class=\"string\">\"10\"</span>, a, b))</span><br><span class=\"line\">    a = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行代码输出</p>\n<figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">10 </span><span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> </span><br><span class=\"line\"><span class=\"symbol\">1 </span><span class=\"number\">1</span> <span class=\"number\">3</span> <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n<p>defer 函数的参数 第三个参数在 defer 时就已经计算完成并确定，第二个参数 a 也是如此，无论之后 a 变量是否修改都不影响。</p>\n<h2 id=\"被-defer-的函数可以读取和修改带名称的返回值\">被 defer 的函数可以读取和修改带名称的返回值<a title=\"#被-defer-的函数可以读取和修改带名称的返回值\" href=\"#被-defer-的函数可以读取和修改带名称的返回值\"></a></h2>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">c</span><span class=\"params\">()</span> <span class=\"params\">(i <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; i++ &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>被 defer 的函数是在 return 之后执行，可以修改带名称的返回值，上面的函数 c 返回的是 2。</p>\n<h2 id=\"go语言-异常panic和恢复recover用法\">Go语言 异常panic和恢复recover用法<a title=\"#go语言-异常panic和恢复recover用法\" href=\"#go语言-异常panic和恢复recover用法\"></a></h2>\n<p>背景：Go语言追求简洁优雅，所以，Go语言不支持传统的 try…catch…finally 这种异常，因为Go语言的设计者们认为，将异常与控制结构混在一起会很容易使得代码变得混乱。因为开发者很容易滥用异常，甚至一个小小的错误都抛出一个异常。在Go语言中，使用多值返回来返回错误。不要用异常代替错误，更不要用来控制流程。在极个别的情况下，才使用Go中引入的Exception处理：defer, panic, recover。</p>\n<h2 id=\"panic：\">panic：<a title=\"#panic：\" href=\"#panic：\"></a></h2>\n<p>1、内建函数</p>\n<p>2、假如函数F中书写了panic语句，会终止其后要执行的代码，在panic所在函数F内如果存在要执行的defer函数列表，按照defer的逆序执行</p>\n<p>比如panic函数内有：</p>\n<ul>\n<li>defer  函数1</li>\n<li>defer  函数2</li>\n<li>defer  函数3</li>\n<li>那么执行顺序就是：</li>\n<li>函数3</li>\n<li>函数2</li>\n<li>函数1</li>\n</ul>\n<p>3、返回函数F的调用者G，在G中，调用函数F语句之后的代码不会执行，假如函数G中存在要执行的defer函数列表，按照defer的逆序执行，这里的defer 有点类似 try-catch-finally 中的 finally</p>\n<p>4、直到goroutine整个退出，并报告错误</p>\n<h2 id=\"recover：\">recover：<a title=\"#recover：\" href=\"#recover：\"></a></h2>\n<p>1、内建函数</p>\n<p>2、用来控制一个goroutine的panicking行为，捕获panic，从而影响应用的行为</p>\n<p>3、一般的调用建议</p>\n<p>a). 在defer函数中，通过recever来终止一个gojroutine的panicking过程，从而恢复正常代码的执行</p>\n<p>b). 可以获取通过panic传递的error</p>\n<p>简单来讲：go中可以抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理。</p>\n<p>示例代码 main函数相当于调用者G，f函数相当于函数F</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">      fmt.Println(<span class=\"string\">\"c\"</span>)</span><br><span class=\"line\">   <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; <span class=\"comment\">// 必须要先声明defer，否则不能捕获到panic异常</span></span><br><span class=\"line\">      fmt.Println(<span class=\"string\">\"d\"</span>)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> err := <span class=\"built_in\">recover</span>(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">         fmt.Println(err) <span class=\"comment\">// 这里的err其实就是panic传入的内容</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      fmt.Println(<span class=\"string\">\"e\"</span>)</span><br><span class=\"line\">   &#125;()</span><br><span class=\"line\">   f() <span class=\"comment\">//开始调用f</span></span><br><span class=\"line\">   fmt.Println(<span class=\"string\">\"f\"</span>) <span class=\"comment\">//这里开始下面代码不会再执行</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">   fmt.Println(<span class=\"string\">\"a\"</span>)</span><br><span class=\"line\">   <span class=\"built_in\">panic</span>(<span class=\"string\">\"异常信息\"</span>)</span><br><span class=\"line\">   fmt.Println(<span class=\"string\">\"b\"</span>) <span class=\"comment\">//这里开始下面代码不会再执行</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">-------output-------</span><br><span class=\"line\">c</span><br><span class=\"line\">a</span><br><span class=\"line\">d</span><br><span class=\"line\">异常信息</span><br><span class=\"line\">e</span><br></pre></td></tr></table></figure>\n<p><strong>注意：利用recover处理panic指令，defer必须在panic之前声明，否则当panic时，recover无法捕获到panic．</strong></p>\n<h2 id=\"参考资料\">参考资料<a title=\"#参考资料\" href=\"#参考资料\"></a></h2>\n<p><a href=\"https://blog.golang.org/defer-panic-and-recover\" target=\"_blank\" rel=\"noopener\">https://blog.golang.org/defer-panic-and-recover</a></p>\n","next":{"title":"Hexo + inside 博客个性化定制","link":"posts/Hexo-inside个性化定制"},"plink":"https://shuntan.github.io/posts/go-defer/","toc":[{"id":"defer-的作用和执行时机","title":"defer 的作用和执行时机","index":"1"},{"id":"defer-的重要用途一：清理释放资源","title":"defer 的重要用途一：清理释放资源","index":"2"},{"id":"defer-的重要用途二：执行-recover","title":"defer 的重要用途二：执行 recover","index":"3"},{"id":"多个-defer-的执行顺序","title":"多个 defer 的执行顺序","index":"4"},{"id":"被-deferred-函数的参数在-defer-时确定","title":"被 deferred 函数的参数在 defer 时确定","index":"5"},{"id":"被-defer-的函数可以读取和修改带名称的返回值","title":"被 defer 的函数可以读取和修改带名称的返回值","index":"6"},{"id":"go语言-异常panic和恢复recover用法","title":"Go语言 异常panic和恢复recover用法","index":"7"},{"id":"panic：","title":"panic：","index":"8"},{"id":"recover：","title":"recover：","index":"9"},{"id":"参考资料","title":"参考资料","index":"10"}],"reward":true,"copyright":{"author":"Shawntan","link":"<a href=\"https://shuntan.github.io/posts/go-defer/\" title=\"理解 Go defer\">https://shuntan.github.io/posts/go-defer/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow noopener\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","published":"April 23, 2020","updated":"April 23, 2020"}}