{"title":"new和malloc的区别","date":"2019-09-19T06:58:35.000Z","date_formatted":{"ll":"Sep 19, 2019","L":"09/19/2019","MM-DD":"09-19"},"link":"posts/new和malloc的区别","comments":true,"tags":["C++"],"categories":["C++"],"updated":"2020-04-14T14:02:07.071Z","content":"<h2 id=\"1-申请的内存所在位置\">1. 申请的内存所在位置<a href=\"posts/new和malloc的区别#1-申请的内存所在位置\"></a></h2><p>　　new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。</p>\n<p>　　自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。</p>\n<p>　　那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。</p>\n<a id=\"more\"></a>\n\n<p>　　特别的，new甚至可以不为对象分配内存！定位new的功能可以办到这一点：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> (place_address) type</span><br></pre></td></tr></table></div></figure>\n\n<p>　　place_address为一个指针，代表一块内存的地址。当使用上面这种仅以一个地址调用new操作符时，new操作符调用特殊的operator new，也就是下面这个版本：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> * <span class=\"keyword\">operator</span> <span class=\"title\">new</span> <span class=\"params\">(<span class=\"keyword\">size_t</span>,<span class=\"keyword\">void</span> *)</span> <span class=\"comment\">//不允许重定义这个版本的operator new</span></span></span><br></pre></td></tr></table></div></figure>\n\n<p>　　这个operator new不分配任何的内存，它只是简单地返回指针实参，然后右new表达式负责在place_address指定的地址进行对象的初始化工作。</p>\n<p>​        所以以这种方式new的指针无需delete，只需要关注place_address的内存的释放与否。例如：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tempalete &lt;<span class=\"keyword\">typename</span> U&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> U* <span class=\"title\">create_array</span><span class=\"params\">(<span class=\"keyword\">size_t</span> count)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tassert(count &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> p = <span class=\"keyword\">static_cast</span>&lt;U*&gt;((<span class=\"built_in\">malloc</span>)(<span class=\"keyword\">sizeof</span>(U) * count)) <span class=\"comment\">//创建一块内存</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">nullptr</span> == p)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i != count; ++i)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> (p + i) U();  <span class=\"comment\">//在指定的内存地址创建对象</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tempalete &lt;<span class=\"keyword\">typename</span> U&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">destory_array</span><span class=\"params\">(U* p, <span class=\"keyword\">size_t</span> count)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(p != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">\t\tassert(count &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = count; i !- <span class=\"number\">0</span>; )&#123;</span><br><span class=\"line\">\t\t\t(p + --i)-&gt;~U();  <span class=\"comment\">//析构指定内存位置的对象</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t(<span class=\"built_in\">free</span>)(p);  <span class=\"comment\">//释放内存</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"2-返回类型安全性\">2.返回类型安全性<a href=\"posts/new和malloc的区别#2-返回类型安全性\"></a></h2><p>　　new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。</p>\n<p>　　类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图分配自己没被授权的内存区域。关于C++的类型安全性可说的又有很多了。</p>\n<h2 id=\"3-内存分配失败时的返回值\">3.内存分配失败时的返回值<a href=\"posts/new和malloc的区别#3-内存分配失败时的返回值\"></a></h2><p>　　new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。</p>\n<p>　　在使用C语言时，我们习惯在malloc分配内存后判断分配是否成功：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *a  = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span> ( <span class=\"keyword\">sizeof</span> (<span class=\"keyword\">int</span> ));</span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">NULL</span> == a)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>　　从C语言走入C++阵营的新手可能会把这个习惯带入C++：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> * a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>();</span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">NULL</span> == a)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>　　实际上这样做一点意义也没有，因为new根本不会返回NULL，而且程序能够执行到if语句已经说明内存分配成功了，如果失败早就抛异常了。正确的做法应该是使用异常机制：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span> (bad_alloc)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>　　如果你想顺便了解下异常基础，可以看<a href=\"http://www.cnblogs.com/QG-whz/p/5136883.htmlC++\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/QG-whz/p/5136883.htmlC++</a> 异常机制分析。</p>\n<h2 id=\"4-是否需要指定内存大小\">4.是否需要指定内存大小<a href=\"posts/new和malloc的区别#4-是否需要指定内存大小\"></a></h2><p>　　使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&#123;</span>...&#125;</span><br><span class=\"line\">A * ptr = <span class=\"keyword\">new</span> A;</span><br><span class=\"line\">A * ptr = (A *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(A)); <span class=\"comment\">//需要显式指定所需内存大小sizeof(A);</span></span><br></pre></td></tr></table></div></figure>\n\n<p>　　当然了，我这里使用malloc来为我们自定义类型分配内存是不怎么合适的，请看下一条。</p>\n<h2 id=\"5-是否调用构造函数-析构函数\">5.是否调用构造函数/析构函数<a href=\"posts/new和malloc的区别#5-是否调用构造函数-析构函数\"></a></h2><p>　　使用new操作符来分配对象内存时会经历三个步骤：</p>\n<p>　　第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。</p>\n<p>　　第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。</p>\n<p>　　第三部：对象构造完成后，返回一个指向该对象的指针。</p>\n<p>　　使用delete操作符来释放对象内存时会经历两个步骤：</p>\n<p>　　第一步：调用对象的析构函数。</p>\n<p>　　第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。</p>\n<p>　　总之来说，new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构。而malloc则不会。如果你不嫌啰嗦可以看下我的例子：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    A() :a(<span class=\"number\">1</span>), b(<span class=\"number\">1.11</span>)&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    A * ptr = (A*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(A));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>　　在return处设置断点，观看ptr所指内存的内容：</p>\n<p><img src=\"https://images2018.cnblogs.com/blog/1191971/201803/1191971-20180319110403732-1469701660.png\" alt=\"img\" class=\"article-img\"></p>\n<p>　　可以看出A的默认构造函数并没有被调用，因为数据成员a,b的值并没有得到初始化，这也是上面我为什么说使用malloc/free来处理C++的自定义类型不合适，其实不止自定义类型，标准库中凡是需要构造/析构的类型通通不合适。</p>\n<p>　　而使用new来分配对象时：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    A * ptr = <span class=\"keyword\">new</span> A;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>　　查看程序生成的汇编代码可以发现，A的默认构造函数被调用了：</p>\n<p><img src=\"https://images2018.cnblogs.com/blog/1191971/201803/1191971-20180319110522159-1015504969.png\" alt=\"img\" class=\"article-img\"></p>\n<h2 id=\"6-对数组的处理\">6.对数组的处理<a href=\"posts/new和malloc的区别#6-对数组的处理\"></a></h2><p>　　C++提供了new[]与delete[]来专门处理数组类型:</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A * ptr = <span class=\"keyword\">new</span> A[<span class=\"number\">10</span>];<span class=\"comment\">//分配10个A对象</span></span><br></pre></td></tr></table></div></figure>\n\n<p>　　使用new[]分配的内存必须使用delete[]进行释放：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">delete</span> [] ptr;</span><br></pre></td></tr></table></div></figure>\n\n<p>　　new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。</p>\n<p>　　至于malloc，它并知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> * ptr = (<span class=\"keyword\">int</span> *) <span class=\"built_in\">malloc</span>( <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)* <span class=\"number\">10</span> );<span class=\"comment\">//分配一个10个int元素的数组</span></span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"7-new与malloc是否可以相互调用\">7.new与malloc是否可以相互调用<a href=\"posts/new和malloc的区别#7-new与malloc是否可以相互调用\"></a></h2><p>　　operator new /operator delete的实现可以基于malloc，而malloc的实现不可以去调用new。下面是编写operator new /operator delete 的一种简单方式，其他版本也与之类似：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> * <span class=\"keyword\">operator</span> <span class=\"title\">new</span> <span class=\"params\">(<span class=\"keyword\">sieze_t</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">void</span> * mem = <span class=\"built_in\">malloc</span>(size)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mem;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> bad_alloc();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"keyword\">operator</span> <span class=\"keyword\">delete</span>(<span class=\"keyword\">void</span> *mem) <span class=\"keyword\">noexcept</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(mem);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"8-是否可以被重载\">8.是否可以被重载<a href=\"posts/new和malloc的区别#8-是否可以被重载\"></a></h2><p>　　opeartor new /operator delete可以被重载。标准库是定义了operator new函数和operator delete函数的8个重载版本：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"number\">1</span> <span class=\"comment\">//这些版本可能抛出异常</span></span><br><span class=\"line\"> <span class=\"number\">2</span> <span class=\"function\"><span class=\"keyword\">void</span> * <span class=\"keyword\">operator</span> <span class=\"title\">new</span><span class=\"params\">(<span class=\"keyword\">size_t</span>)</span></span>;</span><br><span class=\"line\"> <span class=\"number\">3</span> <span class=\"keyword\">void</span> * <span class=\"keyword\">operator</span> <span class=\"keyword\">new</span>[](<span class=\"keyword\">size_t</span>);</span><br><span class=\"line\"> <span class=\"number\">4</span> <span class=\"function\"><span class=\"keyword\">void</span> * <span class=\"keyword\">operator</span> <span class=\"title\">delete</span> <span class=\"params\">(<span class=\"keyword\">void</span> * )</span><span class=\"keyword\">noexcept</span></span>;</span><br><span class=\"line\"> <span class=\"number\">5</span> <span class=\"keyword\">void</span> * <span class=\"keyword\">operator</span> <span class=\"keyword\">delete</span>[](<span class=\"keyword\">void</span> *<span class=\"number\">0</span>）<span class=\"keyword\">noexcept</span>;</span><br><span class=\"line\"> <span class=\"number\">6</span> <span class=\"comment\">//这些版本承诺不抛出异常</span></span><br><span class=\"line\"> <span class=\"number\">7</span> <span class=\"keyword\">void</span> * <span class=\"keyword\">operator</span> <span class=\"keyword\">new</span>(<span class=\"keyword\">size_t</span> ,<span class=\"keyword\">nothrow_t</span>&amp;) <span class=\"keyword\">noexcept</span>;</span><br><span class=\"line\"> <span class=\"number\">8</span> <span class=\"keyword\">void</span> * <span class=\"keyword\">operator</span> <span class=\"keyword\">new</span>[](<span class=\"keyword\">size_t</span>, <span class=\"keyword\">nothrow_t</span>&amp; );</span><br><span class=\"line\"> <span class=\"number\">9</span> <span class=\"keyword\">void</span> * <span class=\"keyword\">operator</span> <span class=\"keyword\">delete</span> (<span class=\"keyword\">void</span> *,<span class=\"keyword\">nothrow_t</span>&amp; )<span class=\"keyword\">noexcept</span>;</span><br><span class=\"line\"><span class=\"number\">10</span> <span class=\"keyword\">void</span> * <span class=\"keyword\">operator</span> <span class=\"keyword\">delete</span>[](<span class=\"keyword\">void</span> *<span class=\"number\">0</span>,<span class=\"keyword\">nothrow_t</span>&amp; ）<span class=\"keyword\">noexcept</span>;</span><br></pre></td></tr></table></div></figure>\n\n<p>　　我们可以自定义上面函数版本中的任意一个，前提是自定义版本必须位于全局作用域或者类作用域中。太细节的东西不在这里讲述，总之，我们知道我们有足够的自由去重载operator new /operator delete ,以决定我们的new与delete如何为对象分配内存，如何回收对象。</p>\n<p>　　而malloc/free并不允许重载。</p>\n<h2 id=\"9-能够直观地重新分配内存\">9. 能够直观地重新分配内存<a href=\"posts/new和malloc的区别#9-能够直观地重新分配内存\"></a></h2><p>　　使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。</p>\n<p>　　new没有这样直观的配套设施来扩充内存。</p>\n<h2 id=\"10-客户处理内存分配不足\">10. 客户处理内存分配不足<a href=\"posts/new和malloc的区别#10-客户处理内存分配不足\"></a></h2><p>　　在operator new抛出异常以反映一个未获得满足的需求之前，它会先调用一个用户指定的错误处理函数，这就是new-handler。new_handler是一个指针类型：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(*new_handler)</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>　　指向了一个没有参数没有返回值的函数,即为错误处理函数。为了指定错误处理函数，客户需要调用set_new_handler，这是一个声明于的一个标准库函数:</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\">new_handler <span class=\"title\">set_new_handler</span><span class=\"params\">(new_handler p )</span> <span class=\"title\">throw</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>　　set_new_handler的参数为new_handler指针，指向了operator new 无法分配足够内存时该调用的函数。其返回值也是个指针，指向set_new_handler被调用前正在执行（但马上就要发生替换）的那个new_handler函数。</p>\n<p>　　对于malloc，客户并不能够去编程决定内存不足以分配时要干什么事，只能看着malloc返回NULL。</p>\n<h2 id=\"总结\">总结<a href=\"posts/new和malloc的区别#总结\"></a></h2><p>　　将上面所述的10点差别整理成表格：</p>\n<p><img src=\"https://images2018.cnblogs.com/blog/1191971/201803/1191971-20180319111342066-1232739079.png\" alt=\"img\" class=\"article-img\"></p>\n<p><strong>如有不对的地方，非常欢迎给予指导！</strong></p>\n<p>　　<strong>如有疑问，可以给我留言</strong></p>\n<p><strong>【感谢】资料来源于</strong></p>\n<p><strong>——<a href=\"http://blog.jobbole.com/102002/\" target=\"_blank\" rel=\"noopener\">http://blog.jobbole.com/102002/</a></strong></p>\n","prev":{"title":"巫师三干货收藏","link":"posts/巫师三干货收藏"},"next":{"title":"Linux--awk命令","link":"posts/Linux-awk命令"},"plink":"https://shuntan.github.io/posts/new和malloc的区别/","toc":[{"title":"1. 申请的内存所在位置","id":"1-申请的内存所在位置","index":"1"},{"title":"2.返回类型安全性","id":"2-返回类型安全性","index":"2"},{"title":"3.内存分配失败时的返回值","id":"3-内存分配失败时的返回值","index":"3"},{"title":"4.是否需要指定内存大小","id":"4-是否需要指定内存大小","index":"4"},{"title":"5.是否调用构造函数/析构函数","id":"5-是否调用构造函数-析构函数","index":"5"},{"title":"6.对数组的处理","id":"6-对数组的处理","index":"6"},{"title":"7.new与malloc是否可以相互调用","id":"7-new与malloc是否可以相互调用","index":"7"},{"title":"8.是否可以被重载","id":"8-是否可以被重载","index":"8"},{"title":"9. 能够直观地重新分配内存","id":"9-能够直观地重新分配内存","index":"9"},{"title":"10. 客户处理内存分配不足","id":"10-客户处理内存分配不足","index":"10"},{"title":"总结","id":"总结","index":"11"}],"reward":true,"copyright":{"author":"Shawntan","link":"<a href=\"https://shuntan.github.io/posts/new和malloc的区别/\" title=\"new和malloc的区别\">https://shuntan.github.io/posts/new和malloc的区别/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow noopener\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","published":"September 19, 2019","updated":"April 14, 2020"}}