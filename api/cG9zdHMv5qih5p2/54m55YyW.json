{"title":"C++ 模板偏特化－来自STL的思考","date":"2019-05-31T06:29:52.000Z","date_formatted":{"ll":"May 31, 2019","L":"05/31/2019","MM-DD":"05-31"},"link":"posts/模板特化","comments":true,"tags":["C++"],"categories":["C++"],"updated":"2019-07-14T01:22:35.792Z","content":"<p>之前学习STL时接触过一段时间的模板，模板是C++泛型编程编程的基础<br>STL从头到尾都是模板泛型编程，我觉得用的最巧妙的就是在traits萃取技巧时用到的模板偏特化</p>\n<hr>\n<ul>\n<li>先简要回顾一下模板吧，模板主要分为函数模板与类模板</li>\n</ul>\n<h2 id=\"函数模板\">函数模板<a href=\"posts/模板特化#函数模板\"></a></h2><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">T</span> <span class=\"title\">add</span>(<span class=\"title\">T</span> <span class=\"title\">a</span>, <span class=\"title\">T</span> <span class=\"title\">b</span>) &#123;</span> <span class=\"keyword\">return</span> a + b;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>, b = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; add(a + b) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<a id=\"more\"></a>\n\n<p>如上就是最简单的函数模板，当实例化函数模板时，编译器会自动进行实参类型推导<br>上面类型T就被自动推导为int类型</p>\n<h2 id=\"类模板\">类模板<a href=\"posts/模板特化#类模板\"></a></h2><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">templete&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">explicit <span class=\"title\">A</span><span class=\"params\">(T val)</span> : <span class=\"title\">t</span><span class=\"params\">(val)</span> </span>&#123; &#125;</span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">add</span><span class=\"params\">(T x)</span> </span>&#123; <span class=\"keyword\">return</span> t + y; &#125;    </span><br><span class=\"line\">privete:</span><br><span class=\"line\">    T t;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">A&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">a</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">    std::cout &lt;&lt; a.add(<span class=\"number\">5</span>) &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>如上就是最简单的类模板，实例化类模板必须要指定类型，编译器无法为类模板自动推导类型</p>\n<h3 id=\"几个需要注意的点\">几个需要注意的点<a href=\"posts/模板特化#几个需要注意的点\"></a></h3><ul>\n<li><p>１．类模板的和函数模板都必须定义在.h头文件中</p>\n</li>\n<li><p>２．模板的实例化类型确定是在编译期间</p>\n</li>\n<li><p>３．只是模板写好了，编译一般不会很多出错，出错一般会在实例化编译之后</p>\n</li>\n<li><p>４．模板实例化只会实例化用到的部分，没有用到的部分将不会被实例化</p>\n</li>\n</ul>\n<hr>\n<p>我觉得模板的特例化是模板中比较精髓的东西<br>有函数模板特例化，类模板特例化，其中又分为全特化与偏特化<br>主要的用途都是对于特定的类型，指定特定的处理方式<br>就相当于普通编程中if-else if - else这样的方式<br>编译阶段确定如果是某个特化类型，就用特化的模板<br>如果都不是，就用最一般的模板</p>\n<h2 id=\"函数模板特例化\">函数模板特例化<a href=\"posts/模板特化#函数模板特例化\"></a></h2><p>函数模板只能全特化，<span class=\"label primary\">不能偏特化</span>，如果要偏特化的话只能重载</p>\n<h3 id=\"函数模板全特化\">函数模板全特化<a href=\"posts/模板特化#函数模板全特化\"></a></h3><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt; &gt;                                  <span class=\"comment\">// 全特化　注意语法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">double</span> a, <span class=\"keyword\">double</span> b)</span>  </span>&#123; <span class=\"keyword\">return</span> a + b; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x = <span class=\"number\">10</span>, y = <span class=\"number\">20</span>;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> z = <span class=\"number\">1.1</span>, w = <span class=\"number\">2.2</span>;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; add(x, y) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;   <span class=\"comment\">// 调用普通版本</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; add(z, w) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;   <span class=\"comment\">// 调用全特化版本</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>如果有与实参更加匹配的特例化版本，编译器将会选择特例化版本</p>\n<h3 id=\"函数模板重载（不存在偏特化）\">函数模板重载（不存在偏特化）<a href=\"posts/模板特化#函数模板重载（不存在偏特化）\"></a></h3><p>因为偏特化版本本质上仍然是模板，所以如果需要的话，可以重载一个函数模板</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T1</span>&gt;　　// 重载版本，接收参数为指针</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">T1</span> <span class=\"title\">add</span>(<span class=\"title\">T1</span>* <span class=\"title\">a</span>, <span class=\"title\">T1</span>* <span class=\"title\">b</span>) &#123;</span> <span class=\"keyword\">return</span> *a + *b; &#125;   </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>, b = <span class=\"number\">20</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *x = &amp;a, *y = &amp;b;</span><br><span class=\"line\">    add(a, b);    <span class=\"comment\">// 调用普通模板</span></span><br><span class=\"line\">    add(x, y);　  <span class=\"comment\">// 调用重载的模板</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>如上，如果需要一个接收指针的偏特化版本，那么可以用重载模板实现<br>函数模板不存在偏特化</p>\n<h2 id=\"类模板特例化\">类模板特例化<a href=\"posts/模板特化#类模板特例化\"></a></h2><p>类模板既有全特化，又有偏特化<br>这里重新写一个更一般的模板类来说明类模板的特例化</p>\n<p>类模板全特化比较好理解，跟函数模板一样，全特化是一个实例，当编译器匹配时会优先匹配参数一致的实例</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt; &gt;     　　　<span class=\"comment\">// 注意语法</span></span><br><span class=\"line\">class A&lt;<span class=\"keyword\">char</span>*&gt;       <span class=\"comment\">// 一个全特化的模板类A</span></span><br><span class=\"line\">&#123;                    <span class=\"comment\">// 当用char*类型来实例化类模板A时，将会优先调用这个全特化实例</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">explicit</span> A(<span class=\"keyword\">char</span>* val) : t(val) &#123; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>* add(<span class=\"keyword\">char</span>* a, <span class=\"keyword\">char</span>* b) &#123; <span class=\"built_in\">return</span> strcat(a, b); &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">char</span>* t;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"类模板的偏特化\">类模板的偏特化<a href=\"posts/模板特化#类模板的偏特化\"></a></h2><p>类模板的偏特化会稍微复杂一点点，它有多种形式<br>类模板偏特化本质上都是指定部分类型，让偏特化版本称为普通版本的子集，若实例化时参数类型为指定的类型，则优先调用特例化版本<br>第一种形式</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;<span class=\"keyword\">class</span> T1, <span class=\"keyword\">class</span> T2&gt;      <span class=\"comment\">// 普通版本，有两个模板参数</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> B &#123; ..... &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template&lt;<span class=\"keyword\">class</span> T2&gt;　　　         <span class=\"comment\">// 偏特化版本，指定其中一个参数，即指定了部分类型</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> B&lt;int , T2&gt; &#123; ..... &#125;;　　<span class=\"comment\">// 当实例化时的第一个参数为int 则会优先调用这个版本</span></span><br></pre></td></tr></table></div></figure>\n\n<p>第二种形式，也是最重要的版本</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;     // 普通版本</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> &#123; ..... &#125;;</span></span><br><span class=\"line\"></span><br><span class=\"line\">template&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;　　　//这个偏特化版本只接收指针类型的模板实参 </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>&lt;T*&gt; &#123; ..... &#125;;</span> </span><br><span class=\"line\"></span><br><span class=\"line\">template&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>&lt;T&amp;&gt; &#123; ..... &#125;;</span>     /<span class=\"regexp\">/ 这个偏特化版本只接受引用类型的模板实参</span></span><br></pre></td></tr></table></div></figure>\n\n<p>第三种形式</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;    //普通版本</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> &#123; ..... &#125;;</span></span><br><span class=\"line\"></span><br><span class=\"line\">template&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;　　　// 这种只接受用<span class=\"title\">T</span>实例化的<span class=\"title\">vector</span>的模板实参．也是一种偏特化</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>&lt;vector&lt;T&gt;&gt; &#123; ......  &#125;;</span></span><br></pre></td></tr></table></div></figure>\n\n<p><strong>几个值得注意的地方</strong></p>\n<ul>\n<li>１．特例化本质上是我们顶替了编译器的工作，我们帮编译器做了类型推导</li>\n<li>２．全特化本质上是一个实例，而偏特化本质上还是一个模板，只是原来模板的一个子集</li>\n<li>３．所以全特化的函数模板，本质上是实例，从而不会与函数模板产生二义性</li>\n<li>４．若想让用户能使用特例化版本，特例化版本必须与模板定义在同一个.h头文件中</li>\n</ul>\n<hr>\n<p>STL中的迭代器实现与高效实现与模板偏特化息息相关．</p>\n<h2 id=\"类模板偏特化与STL\">类模板偏特化与STL<a href=\"posts/模板特化#类模板偏特化与STL\"></a></h2><p><strong>偏特化在STL中最重要的两个应用</strong></p>\n<p>１．应用在迭代器设计中，为了使迭代器既可以萃取出值类型，又可以包容原生指针<br>如果要通过一个迭代器就能知道它的值类型，那么一般会使用iterator_traits<br>迭代器萃取技术的两个核心是：</p>\n<ul>\n<li>１）在每个迭代器类中定义value_type值类型的类型成员，这样直接通过迭代器的value_type类型成员就可以知道值类型</li>\n<li>２）问题就在于，迭代器必须兼容原生指针，而原生指针很难被重新定义，即要在原生指针的类中添加value_type的值类型的类型成员．这时候，靠的就是类模板的偏特化了．新添加一层iterator_traits类，专门萃取迭代器的属性，然后再对iterator_traits类设计原生指针与原生引用的偏特化版本，就解决了这个棘手的问题</li>\n</ul>\n<p>２．<span class=\"label success\"> type_traits</span>类型萃取，对待特殊类型，特殊处理，提高效率<br>对于没有构造函数，析构函数等的内置类型，如果与复杂类型一样，执行同样的操作，显然是效率不高的<br>先实现一个对所有类型都设置一个最保守值的type_traits模板类，然后再对每个内置类型设置偏特化版本，内置类型设置一个更为激进的值，表明可以采取更为高效的操作来提高效率<br>比如copy函数，如果传递的对象是一个复杂类型，那么可能只能采取最保守的处理方式，一个一个的构造；如果是内置类型，这样显然太低效，使用memcpy()可能会好一些</p>\n<p>其实iterator_traits也不止是处理兼容原生指针的问题，它也可以提高效率．<br>迭代器分为很多种，有可以随机访问的（vector），有只能前后一个一个移动的（list）,也有只能单向移动的（slist），所以一般把迭代器分为五种：</p>\n<ul>\n<li>InputIterator　　　　　　　输入迭代器</li>\n<li>OutputIterator 　　　　　 　输出迭代器</li>\n<li>ForwardIterator　　　　　　单向迭代器</li>\n<li>BidirectionIterator　　　　　双向迭代器</li>\n<li>RandomAccessIterator　　　随机访问迭代器</li>\n</ul>\n<p>比如一个advance(n)函数，对于单向迭代器只能一个一个移动过去，但是这种实现对于随机访问迭代器显然不是理想的处理方式<br>处理的方式就是先实现这五个类，用作标记用，在每个迭代器里面都定义迭代器类型的类型成员iterator_catagory，再对不同版本的迭代器实现不同的advance(n)处理方式</p>\n<p>比如stl中添加右值引用元模板的实现：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename _Tp,</span><br><span class=\"line\">\t\t   bool = __and_&lt;__not_&lt;is_reference&lt;_Tp&gt;&gt;,</span><br><span class=\"line\">\t\t   \t\t\t\t\t__not_&lt;is_void&lt;_Tp&gt;&gt;&gt;::value&gt;</span><br><span class=\"line\">\tstruct __add_rvalue_reference_helper</span><br><span class=\"line\">\t&#123;typedef __Tp  <span class=\"built_in\"> type; </span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template&lt;typename _Tp&gt;</span><br><span class=\"line\">\tstruct __add_rvalue_reference_helper&lt;__Tp, <span class=\"literal\">true</span>&gt;</span><br><span class=\"line\">\t&#123;typedef __Tp&amp;&amp; <span class=\"built_in\"> type; </span>&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">template&lt;typename _Tp&gt;</span><br><span class=\"line\">struct add_rvalue_reference</span><br><span class=\"line\">: public __add_rvalue_reference_helper&lt;_Tp&gt;</span><br><span class=\"line\">&#123; &#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p>可以发现调用时一般为<code>static_cast&lt;typenameadd_rvalue_reference&lt;T&gt;::type&gt;(__t)</code>,首先会匹配泛化版本的元模板类，第二个模版参数bool会匹配_Tp的类型，如果原来不是引用类型的话就直接匹配true的偏特化版本（优先级高），否则false为原泛化版本。</p>\n<p>短短几行代码已经展示出了模板偏/全特化的强大匹配功能！</p>\n","prev":{"title":"C++之Lambda研究","link":"posts/Lambda"},"next":{"title":"C++中的万能引用和完美转发","link":"posts/完美转发"},"plink":"https://shuntan.github.io/posts/模板特化/","toc":[{"title":"函数模板","id":"函数模板","index":"1"},{"title":"类模板","id":"类模板","index":"2","children":[{"title":"几个需要注意的点","id":"几个需要注意的点","index":"2.1"}]},{"title":"函数模板特例化","id":"函数模板特例化","index":"3","children":[{"title":"函数模板全特化","id":"函数模板全特化","index":"3.1"},{"title":"函数模板重载（不存在偏特化）","id":"函数模板重载（不存在偏特化）","index":"3.2"}]},{"title":"类模板特例化","id":"类模板特例化","index":"4"},{"title":"类模板的偏特化","id":"类模板的偏特化","index":"5"},{"title":"类模板偏特化与STL","id":"类模板偏特化与STL","index":"6"}],"reward":true,"copyright":{"author":"Shawntan","link":"<a href=\"https://shuntan.github.io/posts/模板特化/\" title=\"C++ 模板偏特化－来自STL的思考\">https://shuntan.github.io/posts/模板特化/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow noopener\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","published":"May 31, 2019","updated":"July 14, 2019"}}