<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shawntan&#39;s Blog</title>
  
  <subtitle>Segmentfault</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shuntan.github.io/"/>
  <updated>2019-06-22T06:17:07.079Z</updated>
  <id>https://shuntan.github.io/</id>
  
  <author>
    <name>Shawntan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>fuck_you_baby</title>
    <link href="https://shuntan.github.io/posts/d9341801/"/>
    <id>https://shuntan.github.io/posts/d9341801/</id>
    <published>2019-06-22T06:16:57.000Z</published>
    <updated>2019-06-22T06:17:07.079Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mutex头文件介绍</title>
    <link href="https://shuntan.github.io/posts/58aac72e/"/>
    <id>https://shuntan.github.io/posts/58aac72e/</id>
    <published>2019-06-14T03:00:47.000Z</published>
    <updated>2019-06-22T10:48:17.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="head">head<a href="post/Mutex介绍#head"></a></h2><p>Mutex 又称互斥量，C++ 11中与 Mutex 相关的类（包括锁类型）和函数都声明在<mutex>头文件中，所以如果你需要使用 std::mutex，就必须包含<mutex>头文件。</mutex></mutex></p><h3 id="头文件介绍"><mutex>头文件介绍</mutex><a href="post/Mutex介绍#头文件介绍"></a></h3><h4 id="Mutex-系列类-四种">Mutex 系列类(四种)<a href="post/Mutex介绍#Mutex-系列类-四种"></a></h4><ul><li><p>std::mutex，最基本的 Mutex 类。</p></li><li><p>std::recursive_mutex，递归 Mutex 类。</p></li><li><p>std::time_mutex，定时 Mutex 类。</p></li><li><p>std::recursive_timed_mutex，定时递归 Mutex 类。</p></li></ul><a id="more"></a><h4 id="Lock-类（两种）">Lock 类（两种）<a href="post/Mutex介绍#Lock-类（两种）"></a></h4><ul><li>std::lock_guard，与 Mutex RAII 相关，方便线程对互斥量上锁。</li><li>std::unique_lock，与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。</li></ul><h4 id="其他类型">其他类型<a href="post/Mutex介绍#其他类型"></a></h4><ul><li>std::once_flag</li><li>std::adopt_lock_t</li><li>std::defer_lock_t</li><li>std::try_to_lock_t</li></ul><h4 id="函数">函数<a href="post/Mutex介绍#函数"></a></h4><ul><li>std::try_lock，尝试同时对多个互斥量上锁。</li><li>std::lock，可以同时对多个互斥量上锁。</li><li>std::call_once，如果多个线程需要同时调用某个函数，call_once 可以保证多个线程对该函数只调用一次。</li></ul><h3 id="std-mutex-介绍">std::mutex 介绍<a href="post/Mutex介绍#std-mutex-介绍"></a></h3><p>下面以 std::mutex 为例介绍 C++11 中的互斥量用法。</p><p>std::mutex 是C++11 中最基本的互斥量，std::mutex 对象提供了独占所有权的特性——即不支持递归地对 std::mutex 对象上锁，而 std::recursive_lock 则可以递归地对互斥量对象上锁。</p><h4 id="std-mutex-的成员函数">std::mutex 的成员函数<a href="post/Mutex介绍#std-mutex-的成员函数"></a></h4><ul><li>构造函数，std::mutex不允许拷贝构造，也不允许 move 拷贝，最初产生的 mutex 对象是处于 unlocked 状态的。</li><li>lock()，调用线程将锁住该互斥量。线程调用该函数会发生下面 3 种情况：(1). 如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁。(2). 如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。</li><li>unlock()， 解锁，释放对互斥量的所有权。</li><li>try_lock()，尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面 3 种情况，(1). 如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量。(2). 如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。</li></ul><p>下面给出一个与 std::mutex 的小例子（<a href="http://www.cplusplus.com/reference/mutex/mutex/try_lock/" target="_blank" rel="noopener">参考</a>）</p><figure class="highlight c++"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;          // std::mutex</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">volatile</span> <span class="keyword">int</span> <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// non-atomic counter</span></span><br><span class="line"><span class="built_in">std</span>::mutex mtx;           <span class="comment">// locks access to counter</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attempt_10k_increases</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mtx.try_lock()) &#123;   <span class="comment">// only increase if currently not locked:</span></span><br><span class="line">            ++counter;</span><br><span class="line">            mtx.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::thread threads[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">        threads[i] = <span class="built_in">std</span>::thread(attempt_10k_increases);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) th.join();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; counter &lt;&lt; <span class="string">" successful increases of the counter.\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>输出结果：</p><figure class="highlight c++"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$g++ -lpthread -<span class="built_in">std</span>=c++<span class="number">11</span> -o main *.cpp</span><br><span class="line">$main</span><br><span class="line"><span class="number">9012</span> successful increases of the counter.</span><br></pre></td></tr></table></div></figure><blockquote><p>可以看出有很多次mtx.try_lock()返回了false，并没有执行++counter操作。</p><p>如果把mtx.try_lock()改成mtx.lock()，则必定会阻塞其他线程。</p></blockquote><p>输出结果2:</p><figure class="highlight c++"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$g++ -lpthread -<span class="built_in">std</span>=c++<span class="number">11</span> -o main *.cpp</span><br><span class="line">$main</span><br><span class="line"><span class="number">100000</span> successful increases of the counter.</span><br></pre></td></tr></table></div></figure><h3 id="std-recursive-mutex-介绍">std::recursive_mutex 介绍<a href="post/Mutex介绍#std-recursive-mutex-介绍"></a></h3><p>std::recursive_mutex 与 std::mutex 一样，也是一种可以被上锁的对象，但是和 std::mutex 不同的是，std::recursive_mutex 允许同一个线程对互斥量多次上锁（即递归上锁），来获得对互斥量对象的多层所有权，std::recursive_mutex 释放互斥量时需要调用与该锁层次深度相同次数的 unlock()，可理解为 lock() 次数和 unlock() 次数相同，除此之外，std::recursive_mutex 的特性和 std::mutex 大致相同。</p><figure class="highlight c++"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;          // std::mutex</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">volatile</span> <span class="keyword">int</span> <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// non-atomic counter</span></span><br><span class="line"><span class="built_in">std</span>::recursive_mutex  rmtx;           <span class="comment">// locks access to counter</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attempt_1k_increases</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        rmtx.lock();   </span><br><span class="line">        ++counter; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; ++i) &#123; </span><br><span class="line">        counter-=<span class="number">2</span>; </span><br><span class="line">        rmtx.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> th = <span class="built_in">std</span>::thread(attempt_1k_increases);</span><br><span class="line">    th.join();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; counter &lt;&lt; <span class="string">" successful increases of the counter.\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>输出结果：</p><figure class="highlight c++"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$g++ -lpthread -o main *.cpp</span><br><span class="line">$main</span><br><span class="line"><span class="number">-10000</span> successful increases of the counter.</span><br></pre></td></tr></table></div></figure><h3 id="std-time-mutex-介绍">std::time_mutex 介绍<a href="post/Mutex介绍#std-time-mutex-介绍"></a></h3><p>std::time_mutex 比 std::mutex 多了两个成员函数，try_lock_for()，try_lock_until()。</p><p>try_lock_for 函数接受一个时间范围，表示在这一段时间范围之内线程如果没有获得锁则被阻塞住（与 std::mutex 的 try_lock() 不同，try_lock 如果被调用时没有获得锁则直接返回 false），如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。</p><p>try_lock_until 函数则接受一个时间点作为参数，在指定时间点未到来之前线程如果没有获得锁则被阻塞住，如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。</p><p>下面的小例子说明了 std::time_mutex 的用法（<a href="http://www.cplusplus.com/reference/mutex/timed_mutex/try_lock_for/" target="_blank" rel="noopener">参考</a>）。</p><figure class="highlight c++"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;         // std::chrono::milliseconds</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;          // std::timed_mutex</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::timed_mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fireworks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// waiting to get a lock: each thread prints "-" every 200ms:</span></span><br><span class="line">  <span class="keyword">while</span> (!mtx.try_lock_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">200</span>))) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"-"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// got a lock! - wait for 1s, then this thread prints "*"</span></span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">1000</span>));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*\n"</span>;</span><br><span class="line">  mtx.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::thread threads[<span class="number">10</span>];</span><br><span class="line">  <span class="comment">// spawn 10 threads:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    threads[i] = <span class="built_in">std</span>::thread(fireworks);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) th.join();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>输出结果：</p><blockquote><p>线程输出*表示该线程已经正常退出，并且释放该锁。否则将每200ms尝试获取mutex🔒，直到成功为止。</p></blockquote><h3 id="std-recursive-timed-mutex-介绍">std::recursive_timed_mutex 介绍<a href="post/Mutex介绍#std-recursive-timed-mutex-介绍"></a></h3><p>和 std:recursive_mutex 与 std::mutex 的关系一样，std::recursive_timed_mutex 的特性也可以从 std::timed_mutex 推导出来，感兴趣的同鞋可以自行查阅。 ;-)</p><h3 id="std-lock-guard-介绍">std::lock_guard 介绍<a href="post/Mutex介绍#std-lock-guard-介绍"></a></h3><p>与 Mutex RAII 相关，方便线程对互斥量上锁。例子（<a href="http://www.cplusplus.com/reference/mutex/lock_guard/" target="_blank" rel="noopener">参考</a>）:</p><ul><li>1.std::lock_guard 在构造函数中进行加锁，析构函数中进行解锁。</li><li>2.锁在多线程编程中，使用较多，因此c++11提供了lock_guard模板类；在实际编程中，我们也可以根据自己的场景编写<code>resource_guard</code> RAII类，避免忘掉释放资源。</li></ul><figure class="highlight c++"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;          // std::mutex, std::lock_guard</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;      // std::logic_error</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_even</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x%<span class="number">2</span>==<span class="number">0</span>) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" is even\n"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">throw</span> (<span class="built_in">std</span>::logic_error(<span class="string">"not even"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_thread_id</span> <span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// using a local lock_guard to lock mtx guarantees unlocking on destruction / exception:</span></span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lck (mtx);</span><br><span class="line">        print_even(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="built_in">std</span>::logic_error&amp;) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[exception caught]\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::thread threads[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// spawn 10 threads:</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">        threads[i] = <span class="built_in">std</span>::thread(print_thread_id,i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) th.join();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>输出结果：</p><figure class="highlight c++"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$g++ -lpthread -o main *.cpp</span><br><span class="line">$main</span><br><span class="line">[exception caught]</span><br><span class="line"><span class="number">4</span> is even</span><br><span class="line">[exception caught]</span><br><span class="line"><span class="number">2</span> is even</span><br><span class="line">[exception caught]</span><br><span class="line"><span class="number">6</span> is even</span><br><span class="line"><span class="number">8</span> is even</span><br><span class="line">[exception caught]</span><br><span class="line">[exception caught]</span><br><span class="line"><span class="number">10</span> is even</span><br></pre></td></tr></table></div></figure><h3 id="std-unique-lock-介绍">std::unique_lock 介绍<a href="post/Mutex介绍#std-unique-lock-介绍"></a></h3><p>与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。例子（<a href="http://www.cplusplus.com/reference/mutex/unique_lock/" target="_blank" rel="noopener">参考</a>）：</p><ul><li>1.类 unique_lock 是通用互斥包装器，允许<code>延迟锁定、锁定的有时限尝试、递归锁定、所有权转移和与条件变量一同使用</code>。</li><li>2.unique_lock比lock_guard使用更加灵活，功能更加强大。<br>使用unique_lock需要付出更多的时间、性能成本。</li></ul><figure class="highlight c++"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;          // std::mutex, std::unique_lock</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex mtx;           <span class="comment">// mutex for critical section</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_block</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// critical section (exclusive access to std::cout signaled by lifetime of lck):</span></span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lck (mtx);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">th1</span> <span class="params">(print_block,<span class="number">50</span>,<span class="string">'*'</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">th2</span> <span class="params">(print_block,<span class="number">50</span>,<span class="string">'$'</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    th1.join();</span><br><span class="line">    th2.join();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>输出结果：</p><figure class="highlight c++"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$g++ -lpthread -o main *.cpp</span><br><span class="line">$main</span><br><span class="line">**************************************************</span><br><span class="line">$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$</span><br></pre></td></tr></table></div></figure><p>好了，本文暂时讲到这里，还剩下 std::try_lock，std::lock，std::call_once 三个函数没有讲到，留在下一篇博客中讲吧 ;-)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;head&quot;&gt;head&lt;a href=&quot;post/Mutex介绍#head&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Mutex 又称互斥量，C++ 11中与 Mutex 相关的类（包括锁类型）和函数都声明在&lt;mutex&gt;头文件中，所以如果你需要使用 std::mutex，就必须包含&lt;mutex&gt;头文件。&lt;/mutex&gt;&lt;/mutex&gt;&lt;/p&gt;&lt;h3 id=&quot;头文件介绍&quot;&gt;&lt;mutex&gt;头文件介绍&lt;/mutex&gt;&lt;a href=&quot;post/Mutex介绍#头文件介绍&quot;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;h4 id=&quot;Mutex-系列类-四种&quot;&gt;Mutex 系列类(四种)&lt;a href=&quot;post/Mutex介绍#Mutex-系列类-四种&quot;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;std::mutex，最基本的 Mutex 类。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;std::recursive_mutex，递归 Mutex 类。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;std::time_mutex，定时 Mutex 类。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;std::recursive_timed_mutex，定时递归 Mutex 类。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="C++" scheme="https://shuntan.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://shuntan.github.io/tags/C/"/>
    
      <category term="Mutex" scheme="https://shuntan.github.io/tags/Mutex/"/>
    
  </entry>
  
  <entry>
    <title>squid介绍及其简单配置</title>
    <link href="https://shuntan.github.io/posts/55e3d16d/"/>
    <id>https://shuntan.github.io/posts/55e3d16d/</id>
    <published>2019-05-15T07:15:30.000Z</published>
    <updated>2019-06-22T10:51:44.739Z</updated>
    
    <content type="html"><![CDATA[<h2 id="squid的概念">squid的概念<a href="post/squid#squid的概念"></a></h2><p>squid是一种用来缓存Internet数据的软件。接受来自人们需要下载的目标（object）的请求并适当的处理这些请求。也就是说，如果一个人想下载一web界面，他请求squid为他取得这个页面。squid随之连接到远程服务器并向这个页面发出请求。然后，squid显式地聚集数据到客户端机器，而且同时复制一份。当下一次有人需要同一页面时， squid可以简单的从磁盘中读到它，那样数据会立即传输到客户机上。</p><a id="more"></a><h2 id="下载地址">下载地址<a href="post/squid#下载地址"></a></h2><p>squid-cache 官网 <a href="http://www.squid-cache.org" target="_blank" rel="noopener">http://www.squid-cache.org</a></p><p>squid介绍及其简单配置 <a href="https://www.cnblogs.com/cherishry/p/5706736.html" target="_blank" rel="noopener">https://www.cnblogs.com/cherishry/p/5706736.html</a></p><p>CentOS 7安装squid代理服务器 <a href="https://blog.csdn.net/ithomer/article/details/78136993" target="_blank" rel="noopener">https://blog.csdn.net/ithomer/article/details/78136993</a></p><h2 id="squid代理的作用">squid代理的作用<a href="post/squid#squid代理的作用"></a></h2><ul><li>通过缓存的方式为用户提供Web访问加速</li><li>对用户的Web访问进行过滤控制</li></ul><h2 id="工作流程">工作流程<a href="post/squid#工作流程"></a></h2><p>当代理服务器中有客户端需要的数据时：</p><p>a.客户端向代理服务器发送数据请求；</p><p>b.代理服务器检查自己的数据缓存；</p><p>c.代理服务器在缓存中找到了用户想要的数据，取出数据；</p><p>d.代理服务器将从缓存中取得的数据返回给客户端。</p><p>当代理服务器中没有客户端需要的数据时了：</p><p>1.客户端向代理服务器发送数据请求；</p><p>2.代理服务器检查自己的数据缓存；</p><p>3.代理服务器在缓存中没有找到用户想要的数据；</p><p>4.代理服务器向Internet 上的远端服务器发送数据请求；</p><p>5.远端服务器响应，返回相应的数据；</p><p>6.代理服务器取得远端服务器的数据，返回给客户端，并保留一份到自己的数据缓存中。</p><div class="article-img"><p><img src="https://images2015.cnblogs.com/blog/872781/201607/872781-20160726112850919-758636566.jpg" alt="" data-zoomable=""></p></div><p>Squid代理服务器工作在TCP/IP应用层</p><div class="article-img"><p><img src="https://images2015.cnblogs.com/blog/872781/201607/872781-20160726112935653-887103660.jpg" alt="" data-zoomable=""></p></div><h2 id="Squid各种代理的定义">Squid各种代理的定义<a href="post/squid#Squid各种代理的定义"></a></h2><h3 id="正向代理">正向代理<a href="post/squid#正向代理"></a></h3><h4 id="标准的代理缓冲服务器">标准的代理缓冲服务器<a href="post/squid#标准的代理缓冲服务器"></a></h4><p>一个标准的代理缓冲服务被用于缓存静态的网页到本地网络上的一台主机上（即代理服务器）。当被缓存的页面被第二次访问的时候，浏览器将直接从本地代理服务器那里获取请求数据而不再向原web站点请求数据。这样就节省了宝贵的网络带宽，而且提高了访问速度。但是，要想实现这种方式，必须在每一个内部主机的浏览器上明确指名代理服务器的IP地址和端口号。客户端上网时，每次都把请求发送给代理服务器处理,代理服务器根据请求确定是否连接到远程web服务器获取数据。如果在本地缓冲区有目标文件，则直接将文件传给用户即可。如果没有的话则先取回文件，先在本地保存一份缓冲，然后将文件发送给客户端浏览器。</p><h4 id="透明代理缓冲服务器">透明代理缓冲服务器<a href="post/squid#透明代理缓冲服务器"></a></h4><p>透明代理缓冲服务器和标准代理服务器的功能完全相同。但是，代理操作对客户端的浏览器是透明的（即不需指明代理服务器的IP和端口）。透明代理服务器阻断网络通信，并且过滤出访问外部的HTTP（80端口）流量。如果客户端的请求在本地有缓冲则将缓冲的数据直接发给用户，如果在本地没有缓冲则向远程web服务器发出请求，其余操作和标准的代理服务器完全相同。对于linux操作系统来说，透明代理使用Iptables或者Ipchains实现。因此不需要对浏览器作任何设置，所以，透明代理对于ISP（Internet服务器提供商）特别有用。</p><h3 id="反向代理">反向代理<a href="post/squid#反向代理"></a></h3><h4 id="反向代理缓冲器">反向代理缓冲器<a href="post/squid#反向代理缓冲器"></a></h4><p>反向代理是和前两种代理完全不同的一种代理服务。使用它可以降低原始WEB服务器的负载。反向代理服务器承担了对原始WEB服务器的静态页面的请求，防止原始服务器过载。它位于WEB服务器和Internet之间，处理所有对WEB服务器的请求，组织了WEB服务器和Internet的直接通信。如果互联网用户请求的页面在代理服务器上有缓冲的话，代理服务器直接将缓冲内容发送给用户。如果没有缓冲则先向WEB服务器发出请求，取回数据，本地缓存后再发给用户。这种方式通过降低了WEB服务器的请求数从而降低了WEB服务器的负载。</p><h3 id="正向代理与反向代理的区别">正向代理与反向代理的区别<a href="post/squid#正向代理与反向代理的区别"></a></h3><h3 id="概念">概念<a href="post/squid#概念"></a></h3><p>正向代理：对于原始服务器而言，就是客户端的代言人<br>反向代理：对于客户端而言，就像是原始服务器</p><h3 id="用途">用途<a href="post/squid#用途"></a></h3><p>正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。<br>反向代理还可以为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。另外，反向代理还可以启用高级URL策略和管理技术，从而使处于不同web服务器系统的web页面同时存在于同一个URL空间下。</p><h3 id="安全性">安全性<a href="post/squid#安全性"></a></h3><p>正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。<br>反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。</p><h2 id="Squid主要组成部分">Squid主要组成部分<a href="post/squid#Squid主要组成部分"></a></h2><p>服务名：<code>squid</code><br>主程序：<code>/usr/sbin/squid</code><br>配置目录：<code>/etc/squid</code><br>主配置文件：<code>/etc/squid/squid.conf</code><br>监听tcp端口号：<code>3128</code><br>默认访问日志文件：<code>/var/log/squid/access.log</code></p><h2 id="squid常用配置选项">squid常用配置选项<a href="post/squid#squid常用配置选项"></a></h2><p><code>/etc/squid/squid.conf</code></p><figure class="highlight glsl"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">http_port <span class="number">3128</span>  (还可以只监听一个IP http_port <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">3128</span>)</span><br><span class="line">cache_mem <span class="number">64</span>MB  <span class="meta">#缓存占内存大小</span></span><br><span class="line">maximum_object_size <span class="number">4096</span>KB  <span class="meta">#最大缓存块</span></span><br><span class="line">reply_body_max_size  <span class="number">1024000</span> allow <span class="built_in">all</span>      <span class="meta">#限定下载文件大小</span></span><br><span class="line">access_log /var/<span class="built_in">log</span>/squid/access.<span class="built_in">log</span>    <span class="meta">#访问日志存放的地方</span></span><br><span class="line">visible_hostname    proxy.test.xom  <span class="meta">#可见的主机名</span></span><br><span class="line">cache_dir ufs /var/spool/squid  <span class="number">100</span> <span class="number">16</span> <span class="number">256</span> </span><br><span class="line"><span class="meta">#ufs:缓存数据的存储格式</span></span><br><span class="line"><span class="meta">#/var/spool/squid    缓存目录</span></span><br><span class="line"><span class="meta">#100：缓存目录占磁盘空间大小（M）</span></span><br><span class="line"><span class="meta">#16：缓存空间一级子目录个数</span></span><br><span class="line"><span class="meta">#256：缓存空间二级子目录个数</span></span><br><span class="line">cache_mgr webmaster@test.com    <span class="meta">#定义管理员邮箱</span></span><br><span class="line">http_access deny <span class="built_in">all</span>    <span class="meta">#访问控制</span></span><br></pre></td></tr></table></div></figure><h2 id="squid中的访问控制">squid中的访问控制<a href="post/squid#squid中的访问控制"></a></h2><p>使用访问控制特性，可以控制在访问时根据特定的时间间隔进行缓存、访问特定站点或一组站点等等。squid访问控制有两个要素：ACL元素和访问列表。访问列表可以允许或拒绝某些用户对此服务的访问。</p><h3 id="ACL元素类型">ACL元素类型<a href="post/squid#ACL元素类型"></a></h3><ul><li>src：源地址（即客户机IP地址）</li><li>dst：目标地址（即服务器IP地址）</li><li>srcdomain：源名称（即客户机名称）</li><li>dstdomain：目标名称（即服务器名称）</li><li>time：一天中的时刻和一周内的一天</li><li>url_regex：URL规则表达式匹配</li><li>urlpath_regex：URL-path规则表达式匹配，略去协议和主机名</li><li>proxy_auth：通过外部程序进行用户验证</li><li>maxconn：单一IP的最大连接数</li></ul><h3 id="ACL格式">ACL格式<a href="post/squid#ACL格式"></a></h3><pre><code>为了使用控制功能，必须先设置ACL规则并应用。ACL声明的格式如下：</code></pre><p>注：</p><ul><li>acl_element_name 可以是任一个在ACL中定义的名称</li><li>任何两个ACL元素不能用相同的名字</li><li>每个ACL由列表值组成。当进行匹配检测的时候，多个值由逻辑或运算连接；换言之，即任一ACL元素的值被匹配，则这个ACL元素即被匹配。</li><li>并不是所有ACL元素都能使用访问列表中的全部类型</li><li>不同的ACL元素写在不同行中，squid将把他们组合在一个列表中</li></ul><h3 id="访问条目">访问条目<a href="post/squid#访问条目"></a></h3><p>我们可以使用许多不同的访问条目。下面是我们常用的几个：</p><ul><li>http_access:允许HTTP访问</li><li>no_cache:定义对缓存请求的响应。<br>访问列表的规则由一些类似’allow’或‘deny’的关键字构成，用以允许或拒绝向特定或一组ACL元素提供服务。</li></ul><ol><li>一个访问列表可以由多条规则组成</li><li>如果没有任何规则与访问请求匹配，默认动作将与列表中最后一条规则对应。</li><li>一个访问条目中所有元素将用逻辑与运算连接<br>http_access Action 声明1 AND 声明2 AND 声明 OR.<br>http_access Action 声明3<br>多个http_accesss声明间用或运算连接，但每个访问条目的元素间用与运算连接。</li><li>列表中的规则总是遵循由上而下的顺序</li><li>这些规则按照他们的排列顺序进行匹配检测，一旦检测到匹配的规则，匹配就立即结束。</li></ol><h2 id="Squid-conf配置文件详解">Squid.conf配置文件详解<a href="post/squid#Squid-conf配置文件详解"></a></h2><figure class="highlight sql"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#acl all src 0.0.0.0/0.0.0.0 and http_access allow all选项定义了一个访问控制列表。详细情况参见和Squid软件</span></span><br><span class="line"><span class="comment">#携带的文档。这里的访问控制列表允许所有对代理服务的访问，因为这里该代理是加速web服务器。</span></span><br><span class="line">acl all src 0.0.0.0/0.0.0.0                 <span class="comment">#允许所有IP访问</span></span><br><span class="line">acl manager proto http                 <span class="comment">#manager url协议为http</span></span><br><span class="line">acl localhost src 127.0.0.1/255.255.255.255  <span class="comment">#允午本机IP</span></span><br><span class="line">acl to_localhost dst 127.0.0.1                 <span class="comment">#允午目的地址为本机IP</span></span><br><span class="line">acl Safe_ports port 80                <span class="comment"># 允许安全更新的端口为80</span></span><br><span class="line">acl CONNECT method CONNECT        <span class="comment">#请求方法以CONNECT</span></span><br><span class="line">http_access allow all                <span class="comment">#允许所有人使用该代理.因为这里是代理加速web服务器</span></span><br><span class="line">http_reply_access allow all                <span class="comment">#允许所有客户端使用该代理</span></span><br><span class="line"></span><br><span class="line">acl OverConnLimit maxconn 16        <span class="comment">#限制每个IP最大允许16个连接，防止攻击</span></span><br><span class="line">http_access deny OverConnLimit</span><br><span class="line"></span><br><span class="line">icp_access deny all                        <span class="comment">#禁止从邻居服务器缓冲内发送和接收ICP请求.</span></span><br><span class="line">miss_access allow all                <span class="comment">#允许直接更新请求</span></span><br><span class="line">ident_lookup_access deny all                                <span class="comment">#禁止lookup检查DNS</span></span><br><span class="line">http_port 8080 transparent                                <span class="comment">#指定Squid监听浏览器客户请求的端口号。</span></span><br><span class="line"></span><br><span class="line">hierarchy_stoplist cgi-bin ?                <span class="comment">#用来强制某些特定的对象不被缓存，主要是处于安全的目的。</span></span><br><span class="line">acl QUERY urlpath_regex cgi-bin \?</span><br><span class="line"><span class="keyword">cache</span> deny <span class="keyword">QUERY</span></span><br><span class="line"></span><br><span class="line">cache_mem <span class="number">1</span> GB        <span class="comment">#这是一个优化选项，增加该内存值有利于缓存。应该注意的是：</span></span><br><span class="line">                     <span class="comment">#一般来说如果系统有内存，设置该值为(n/)3M。现在是3G 所以这里1G</span></span><br><span class="line">fqdncache_size <span class="number">1024</span>        <span class="comment">#FQDN 高速缓存大小</span></span><br><span class="line">maximum_object_size_in_memory <span class="number">2</span> MB        <span class="comment">#允许最大的文件载入内存</span></span><br><span class="line"></span><br><span class="line">memory_replacement_policy <span class="keyword">heap</span> LFUDA  <span class="comment">#动态使用最小的，移出内存cache</span></span><br><span class="line">cache_replacement_policy <span class="keyword">heap</span> LFUDA         <span class="comment">#动态使用最小的，移出硬盘cache</span></span><br><span class="line"></span><br><span class="line">cache_dir ufs /home/<span class="keyword">cache</span> <span class="number">5000</span> <span class="number">32</span> <span class="number">512</span>  <span class="comment">#高速缓存目录 ufs 类型 使用的缓冲值最大允午1000MB空间，</span></span><br><span class="line"><span class="comment">#32个一级目录，512个二级目录</span></span><br><span class="line"></span><br><span class="line">max_open_disk_fds <span class="number">0</span>                                 <span class="comment">#允许最大打开文件数量,0 无限制</span></span><br><span class="line">minimum_object_size <span class="number">1</span> KB                         <span class="comment">#允午最小文件请求体大小</span></span><br><span class="line">maximum_object_size <span class="number">20</span> MB                 <span class="comment">#允午最大文件请求体大小</span></span><br><span class="line"></span><br><span class="line">cache_swap_low <span class="number">90</span>                            <span class="comment">#最小允许使用swap 90%</span></span><br><span class="line">cache_swap_high <span class="number">95</span>                            <span class="comment">#最多允许使用swap 95%</span></span><br><span class="line"></span><br><span class="line">ipcache_size <span class="number">2048</span>                                <span class="comment"># IP 地址高速缓存大小 2M</span></span><br><span class="line">ipcache_low <span class="number">90</span>                                <span class="comment">#最小允许ipcache使用swap 90%</span></span><br><span class="line">ipcache_high <span class="number">95</span>                                  <span class="comment">#最大允许ipcache使用swap 90%</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">access_log /<span class="keyword">var</span>/<span class="keyword">log</span>/squid/access.log squid        <span class="comment">#定义日志存放记录</span></span><br><span class="line">cache_log /<span class="keyword">var</span>/<span class="keyword">log</span>/squid/cache.log squid</span><br><span class="line">cache_store_log <span class="keyword">none</span>                        <span class="comment">#禁止store日志</span></span><br><span class="line"></span><br><span class="line">emulate_httpd_log <span class="keyword">on</span>        <span class="comment">#将使Squid仿照Web服务器的格式创建访问记录。如果希望使用</span></span><br><span class="line">                                <span class="comment">#Web访问记录分析程序，就需要设置这个参数。</span></span><br><span class="line"></span><br><span class="line">refresh_pattern . <span class="number">0</span> <span class="number">20</span>% <span class="number">4320</span> override-<span class="keyword">expire</span> override-lastmod reload-<span class="keyword">into</span>-ims <span class="keyword">ignore</span>-reload   <span class="comment">#更新cache规则</span></span><br><span class="line"></span><br><span class="line">acl buggy_server url_regex ^<span class="keyword">http</span>://.... <span class="keyword">http</span>://          <span class="comment">#只允许http的请求</span></span><br><span class="line">broken_posts <span class="keyword">allow</span> buggy_server</span><br><span class="line"></span><br><span class="line">acl apache rep_header <span class="keyword">Server</span> ^Apache                 <span class="comment">#允许apache的编码</span></span><br><span class="line">broken_vary_encoding <span class="keyword">allow</span> apache</span><br><span class="line"></span><br><span class="line">request_entities <span class="keyword">off</span>                                        <span class="comment">#禁止非http的标分准请求，防止攻击</span></span><br><span class="line">header_access header <span class="keyword">allow</span> all                        <span class="comment">#允许所有的http报头</span></span><br><span class="line">relaxed_header_parser <span class="keyword">on</span>                                <span class="comment">#不严格分析http报头.</span></span><br><span class="line">client_lifetime <span class="number">120</span> <span class="keyword">minute</span>                                <span class="comment">#最大客户连接时间 120分钟</span></span><br><span class="line"></span><br><span class="line">cache_mgr sky@test.com                        <span class="comment">#指定当缓冲出现问题时向缓冲管理者发送告警信息的地址信息。</span></span><br><span class="line"></span><br><span class="line">cache_effective_user squid                        <span class="comment">#这里以用户squid的身份Squid服务器</span></span><br><span class="line">cache_effective_group squid</span><br><span class="line"></span><br><span class="line">icp_port <span class="number">0</span>                       <span class="comment">#指定Squid从邻居服务器缓冲内发送和接收ICP请求的端口号。</span></span><br><span class="line">                     <span class="comment">#这里设置为0是因为这里配置Squid为内部Web服务器的加速器，</span></span><br><span class="line">                     <span class="comment">#所以不需要使用邻居服务器的缓冲。0是禁用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cache_peer 设置允许更新缓存的主机，因是本机所以127.0.0.1</span></span><br><span class="line">cache_peer <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="keyword">parent</span> <span class="number">80</span> <span class="number">0</span> <span class="keyword">no</span>-<span class="keyword">query</span> <span class="keyword">default</span> multicast-responder <span class="keyword">no</span>-netdb-<span class="keyword">exchange</span></span><br><span class="line">cache_peer_domain <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>                                 </span><br><span class="line">hostname_aliases <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line">error_directory /usr/<span class="keyword">share</span>/squid/<span class="keyword">errors</span>/Simplify_Chinese        <span class="comment">#定义错误路径</span></span><br><span class="line"></span><br><span class="line">always_direct <span class="keyword">allow</span> all                <span class="comment"># cache丢失或不存在是允许所有请求直接转发到原始服务器</span></span><br><span class="line">ignore_unknown_nameservers <span class="keyword">on</span>        <span class="comment">#开反DNS查询，当域名地址不相同时候，禁止访问</span></span><br><span class="line">coredump_dir  /<span class="keyword">var</span>/<span class="keyword">log</span>/squid                 <span class="comment">#定义dump的目录</span></span><br><span class="line"></span><br><span class="line">max_filedesc <span class="number">2048</span>                <span class="comment">#最大打开的文件描述</span></span><br><span class="line"></span><br><span class="line">half_closed_clients <span class="keyword">off</span>        <span class="comment">#使Squid在当read不再返回数据时立即关闭客户端的连接。</span></span><br><span class="line">                                <span class="comment">#有时read不再返回数据是由于某些客户关闭TCP的发送数据</span></span><br><span class="line">                                <span class="comment">#而仍然保持接收数据。而Squid分辨不出TCP半关闭和完全关闭。</span></span><br><span class="line"></span><br><span class="line">buffered_logs <span class="keyword">on</span> <span class="comment">#若打开选项“buffered_logs”可以稍稍提高加速某些对日志文件的写入，该选项主要是实现优化特性。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#防止天涯盗链，转嫁给百度</span></span><br><span class="line">acl tianya referer_regex -i tianya</span><br><span class="line">http_access deny tianya</span><br><span class="line">deny_info  tianya</span><br><span class="line"><span class="comment">#阻止baidu蜘蛛</span></span><br><span class="line">acl baidu req_header <span class="keyword">User</span>-<span class="keyword">Agent</span> Baiduspider</span><br><span class="line">http_access deny baidu</span><br><span class="line"><span class="comment">#限制同一IP客户端的最大连接数</span></span><br><span class="line">acl OverConnLimit maxconn <span class="number">128</span></span><br><span class="line">http_access deny OverConnLimit</span><br><span class="line"></span><br><span class="line"><span class="comment">#防止被人利用为HTTP代理，设置允许访问的IP地址</span></span><br><span class="line">acl myip dst <span class="number">222.18</span><span class="number">.63</span><span class="number">.37</span></span><br><span class="line">http_access deny !myip</span><br><span class="line"></span><br><span class="line"><span class="comment">#允许本地管理</span></span><br><span class="line">acl Manager proto cache_object</span><br><span class="line">acl Localhost src <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">222.18</span><span class="number">.63</span><span class="number">.37</span></span><br><span class="line">http_access <span class="keyword">allow</span> Manager Localhost</span><br><span class="line">cachemgr_passwd <span class="number">53034338</span> all</span><br><span class="line">http_access deny Manager</span><br><span class="line"></span><br><span class="line"><span class="comment">#仅仅允许80端口的代理</span></span><br><span class="line">acl all src <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">acl Safe_ports port <span class="number">80</span> <span class="comment"># http</span></span><br><span class="line">http_access deny !Safe_ports</span><br><span class="line">http_access <span class="keyword">allow</span> all</span><br><span class="line"></span><br><span class="line"><span class="comment">#Squid信息设置</span></span><br><span class="line">visible_hostname happy.swjtu.edu.cn</span><br><span class="line">cache_mgr  ooopic2008@qq.com</span><br><span class="line"></span><br><span class="line"><span class="comment">#基本设置</span></span><br><span class="line">cache_effective_user squid</span><br><span class="line">cache_effective_group squid</span><br><span class="line">tcp_recv_bufsize <span class="number">65535</span> <span class="keyword">bytes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.6的反向代理加速配置</span></span><br><span class="line">cache_peer <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="keyword">parent</span> <span class="number">80</span> <span class="number">0</span> <span class="keyword">no</span>-<span class="keyword">query</span> originserver</span><br><span class="line"></span><br><span class="line"><span class="comment">#错误文档</span></span><br><span class="line">error_directory /usr/<span class="keyword">local</span>/squid/<span class="keyword">share</span>/<span class="keyword">errors</span>/Simplify_Chinese</span><br><span class="line"></span><br><span class="line"><span class="comment">#单台使用，不使用该功能</span></span><br><span class="line">icp_port <span class="number">0</span></span><br><span class="line"></span><br><span class="line">hierarchy_stoplist cgi-<span class="keyword">bin</span> ?</span><br><span class="line"></span><br><span class="line">acl <span class="keyword">QUERY</span> urlpath_regex cgi-<span class="keyword">bin</span> \? .php .cgi .avi .wmv .rm .ram .mpg .mpeg .zip .exe</span><br><span class="line"><span class="keyword">cache</span> deny <span class="keyword">QUERY</span></span><br><span class="line"></span><br><span class="line">acl apache rep_header <span class="keyword">Server</span> ^Apache</span><br><span class="line">broken_vary_encoding <span class="keyword">allow</span> apache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">refresh_pattern ^<span class="keyword">ftp</span>:           <span class="number">1440</span> <span class="number">20</span>%     <span class="number">10080</span></span><br><span class="line">refresh_pattern ^gopher:        <span class="number">1440</span> <span class="number">0</span>%    <span class="number">1440</span></span><br><span class="line">refresh_pattern .             <span class="number">0</span>    <span class="number">20</span>%     <span class="number">4320</span></span><br><span class="line"></span><br><span class="line">cache_store_log <span class="keyword">none</span></span><br><span class="line">pid_filename /usr/<span class="keyword">local</span>/squid/<span class="keyword">var</span>/<span class="keyword">logs</span>/squid.pid</span><br><span class="line">emulate_httpd_log <span class="keyword">on</span></span><br></pre></td></tr></table></div></figure><h2 id="Squid常用命令">Squid常用命令<a href="post/squid#Squid常用命令"></a></h2><ol><li>初始化在squid.conf里配置的cache目录<br>squid -z<br>如果有错误提示，请检查cache目录的权限，可以更改目录权限<br>chown -R squid:squid /cache目录</li><li>对squid.conf排错，即验证squid.conf的语法和配置<br>squid -k parse<br>如果在squid.conf中有语法或配置错误，这里会返回提示，若无返回，尝试启动squid</li><li>前台启动squid，并输出启动过程<br>/usr/local/squid/sbin/squid -N -d1<br>如果有ready to server reques相关信息，说明squid启动成功<br>然后ctrl+c ,停止squid,并以后台运行的方式启动它</li><li>启动squid在后台运行<br>squid -s<br>可以使用ps -ax | grep squid 来查看squid进程是否存在</li><li>停止squid<br>squid -k shutdown</li><li>重新引导修改过的squid.conf<br>squid -k reconfigure -f /XXX/squid.conf<br>当squid进行配置更改后，可以使用该命令进行squid配置重载</li><li>把squid添加到系统启动项<br>vim /etc/rc.local<br>/usr/local/squid/sbin/squid -s</li><li>修改cache缓存目录的权限<br>chown -R squid.squid /cache目录<br>cache缓存目录根据自己的配置更改，squid用户和组是squid，squid</li><li>修改squid日志目录的权限<br>chown -R squid.squid 定义的日志文件所在目录<br>这一步并不是适合每一个使用squid的用户，意为让squid有权限在该目录里进行写操作</li><li>查看你的日志文档<br>more /usr/local/squid/var/logs/access.log | grep TCP_MEM_HIT<br>该指令可以看到在squid运行过程中，有那些文件被squid缓存到内存中，并返回给访问用户。<br>more /usr/local/squid/var/logs/access.log | grep TCP_HIT<br>该指令可以看到在squid运行过程中，有那些文件被squid缓存到cache目录中，并返回给访问用户。<br>more /usr/local/squid/var/logs/access.log | grep TCP_MISS<br>该指令可以看到在squid运行过程中，有那些文件没有被squid缓存，而是从原始服务器获取并返回给访问用户。</li></ol><h2 id="Squid命中率分析">Squid命中率分析<a href="post/squid#Squid命中率分析"></a></h2><figure class="highlight groovy"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/squid/</span>bin/squidclient -p <span class="number">80</span> <span class="string">mgr:</span>info</span><br><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/squid/</span>bin/squidclient -p <span class="number">80</span> <span class="string">mgr:</span><span class="number">5</span>min</span><br></pre></td></tr></table></div></figure><p>可以看到详细的性能情况,其中PORT是你的proxy的端口，5min可以是60min<br>取得squid运行状态信息：</p><figure class="highlight nginx"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">squidclient</span> -p <span class="number">80</span> mgr:<span class="literal">info</span></span><br></pre></td></tr></table></div></figure><p>取得squid内存使用情况：</p><figure class="highlight stylus"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">squidclient -<span class="selector-tag">p</span> <span class="number">80</span> mgr:mem</span><br></pre></td></tr></table></div></figure><p>取得squid已经缓存的列表：</p><figure class="highlight armasm"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">squidclient</span> -p <span class="number">80</span> mgr:<span class="keyword">bjects. </span>use <span class="keyword">it </span>carefully,<span class="keyword">it </span>may crash</span><br></pre></td></tr></table></div></figure><p>取得squid的磁盘使用情况：</p><figure class="highlight stylus"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">squidclient -<span class="selector-tag">p</span> <span class="number">80</span> mgr:diskd</span><br></pre></td></tr></table></div></figure><p>强制更新某个url：</p><figure class="highlight stylus"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">squidclient -<span class="selector-tag">p</span> <span class="number">80</span> -m PURGE http:<span class="comment">//www.xxx.com/xxx.php</span></span><br></pre></td></tr></table></div></figure><p>更多的请查看：squidclient-h 或者 squidclient -p 80 mgr:<br>查命中率：</p><figure class="highlight armasm"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">squidclient</span> -h <span class="built_in">IP</span>(具体侦听<span class="built_in">IP</span>) -p <span class="number">80</span>(具体侦听端口) mgr:<span class="meta">info</span></span><br></pre></td></tr></table></div></figure><h2 id="定期清理swap-state内无效数据">定期清理swap.state内无效数据<a href="post/squid#定期清理swap-state内无效数据"></a></h2><figure class="highlight dts"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta-keyword">/path/</span>to<span class="meta-keyword">/squid/</span>sbin/squid -k rotate -f <span class="meta-keyword">/path/</span>to<span class="meta-keyword">/squid/</span>conf_file</span><br><span class="line">vi <span class="meta-keyword">/etc/</span>crontab</span><br><span class="line"><span class="number">0</span>        <span class="number">0</span>       *       *       *       root    <span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/sbin/</span>squid -k rotate -f <span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/etc/</span>squid/squid1.conf</span><br></pre></td></tr></table></div></figure><p>当squid应用运行了一段时间之后，cache_dir对应的swap.state文件就会变得越来越大，里面的无效接口数据越来越多，这可能影响squid的响应时间，因此需要使用squid清理swap.state里面的无效数据，减少swap.state的大小。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;squid的概念&quot;&gt;squid的概念&lt;a href=&quot;post/squid#squid的概念&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;squid是一种用来缓存Internet数据的软件。接受来自人们需要下载的目标（object）的请求并适当的处理这些请求。也就是说，如果一个人想下载一web界面，他请求squid为他取得这个页面。squid随之连接到远程服务器并向这个页面发出请求。然后，squid显式地聚集数据到客户端机器，而且同时复制一份。当下一次有人需要同一页面时， squid可以简单的从磁盘中读到它，那样数据会立即传输到客户机上。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://shuntan.github.io/categories/Linux/"/>
    
    
      <category term="squid" scheme="https://shuntan.github.io/tags/squid/"/>
    
      <category term="proxy" scheme="https://shuntan.github.io/tags/proxy/"/>
    
  </entry>
  
</feed>
