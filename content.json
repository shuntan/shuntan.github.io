{"meta":{"title":"Shawntan's Blog","subtitle":"Segmentfault","description":"shawntan@tencent.com","author":"Shawntan","url":"https://shuntan.github.io"},"pages":[{},{},{}],"posts":[{"title":"new和malloc的区别","date":"2019-09-19T06:58:35.000Z","path":"posts/new和malloc的区别/","text":"1. 申请的内存所在位置 new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。 自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。 那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。 特别的，new甚至可以不为对象分配内存！定位new的功能可以办到这一点： 1new (place_address) type place_address为一个指针，代表一块内存的地址。当使用上面这种仅以一个地址调用new操作符时，new操作符调用特殊的operator new，也就是下面这个版本： 1void * operator new (size_t,void *) //不允许重定义这个版本的operator new 这个operator new不分配任何的内存，它只是简单地返回指针实参，然后右new表达式负责在place_address指定的地址进行对象的初始化工作。 ​ 所以以这种方式new的指针无需delete，只需要关注place_address的内存的释放与否。例如： 1234567891011121314tempalete &lt;typename U&gt;static inline U* create_array(size_t count)&#123; assert(count &gt; 0); auto p = static_cast&lt;U*&gt;((malloc)(sizeof(U) * count)) //创建一块内存 if (nullptr == p)&#123; return nullptr; &#125; for (size_t i = 0; i != count; ++i)&#123; new (p + i) U(); //在指定的内存地址创建对象 &#125; return p;&#125; 1234567891011tempalete &lt;typename U&gt;static inline void destory_array(U* p, size_t count)&#123; if(p != nullptr)&#123; assert(count &gt; 0); for (size_t i = count; i !- 0; )&#123; (p + --i)-&gt;~U(); //析构指定内存位置的对象 &#125; (free)(p); //释放内存 &#125;&#125; 2.返回类型安全性 new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。 类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图分配自己没被授权的内存区域。关于C++的类型安全性可说的又有很多了。 3.内存分配失败时的返回值 new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。 在使用C语言时，我们习惯在malloc分配内存后判断分配是否成功： 123456789int *a = (int *)malloc ( sizeof (int ));if(NULL == a)&#123; ...&#125;else &#123; ...&#125; 从C语言走入C++阵营的新手可能会把这个习惯带入C++： 123456789int * a = new int();if(NULL == a)&#123; ...&#125;else&#123; ...&#125; 实际上这样做一点意义也没有，因为new根本不会返回NULL，而且程序能够执行到if语句已经说明内存分配成功了，如果失败早就抛异常了。正确的做法应该是使用异常机制： 12345678try&#123; int *a = new int();&#125;catch (bad_alloc)&#123; ...&#125; 如果你想顺便了解下异常基础，可以看http://www.cnblogs.com/QG-whz/p/5136883.htmlC++ 异常机制分析。 4.是否需要指定内存大小 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。 123class A&#123;...&#125;A * ptr = new A;A * ptr = (A *)malloc(sizeof(A)); //需要显式指定所需内存大小sizeof(A); 当然了，我这里使用malloc来为我们自定义类型分配内存是不怎么合适的，请看下一条。 5.是否调用构造函数/析构函数 使用new操作符来分配对象内存时会经历三个步骤： 第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。 第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。 第三部：对象构造完成后，返回一个指向该对象的指针。 使用delete操作符来释放对象内存时会经历两个步骤： 第一步：调用对象的析构函数。 第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。 总之来说，new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构。而malloc则不会。如果你不嫌啰嗦可以看下我的例子： 12345678910111213 class A&#123;public: A() :a(1), b(1.11)&#123;&#125;private: int a; double b;&#125;;int main()&#123; A * ptr = (A*)malloc(sizeof(A)); return 0;&#125; 在return处设置断点，观看ptr所指内存的内容： 可以看出A的默认构造函数并没有被调用，因为数据成员a,b的值并没有得到初始化，这也是上面我为什么说使用malloc/free来处理C++的自定义类型不合适，其实不止自定义类型，标准库中凡是需要构造/析构的类型通通不合适。 而使用new来分配对象时： 1234int main()&#123; A * ptr = new A;&#125; 查看程序生成的汇编代码可以发现，A的默认构造函数被调用了： 6.对数组的处理 C++提供了new[]与delete[]来专门处理数组类型: 1A * ptr = new A[10];//分配10个A对象 使用new[]分配的内存必须使用delete[]进行释放： 1delete [] ptr; new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。 至于malloc，它并知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小： 1int * ptr = (int *) malloc( sizeof(int)* 10 );//分配一个10个int元素的数组 7.new与malloc是否可以相互调用 operator new /operator delete的实现可以基于malloc，而malloc的实现不可以去调用new。下面是编写operator new /operator delete 的一种简单方式，其他版本也与之类似： 1234567891011void * operator new (sieze_t size)&#123; if(void * mem = malloc(size) return mem; else throw bad_alloc();&#125;void operator delete(void *mem) noexcept&#123; free(mem);&#125; 8.是否可以被重载 opeartor new /operator delete可以被重载。标准库是定义了operator new函数和operator delete函数的8个重载版本： 12345678910 1 //这些版本可能抛出异常 2 void * operator new(size_t); 3 void * operator new[](size_t); 4 void * operator delete (void * )noexcept; 5 void * operator delete[](void *0）noexcept; 6 //这些版本承诺不抛出异常 7 void * operator new(size_t ,nothrow_t&amp;) noexcept; 8 void * operator new[](size_t, nothrow_t&amp; ); 9 void * operator delete (void *,nothrow_t&amp; )noexcept;10 void * operator delete[](void *0,nothrow_t&amp; ）noexcept; 我们可以自定义上面函数版本中的任意一个，前提是自定义版本必须位于全局作用域或者类作用域中。太细节的东西不在这里讲述，总之，我们知道我们有足够的自由去重载operator new /operator delete ,以决定我们的new与delete如何为对象分配内存，如何回收对象。 而malloc/free并不允许重载。 9. 能够直观地重新分配内存 使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。 new没有这样直观的配套设施来扩充内存。 10. 客户处理内存分配不足 在operator new抛出异常以反映一个未获得满足的需求之前，它会先调用一个用户指定的错误处理函数，这就是new-handler。new_handler是一个指针类型： 1234namespace std&#123; typedef void (*new_handler)();&#125; 指向了一个没有参数没有返回值的函数,即为错误处理函数。为了指定错误处理函数，客户需要调用set_new_handler，这是一个声明于的一个标准库函数: 1234namespace std&#123; new_handler set_new_handler(new_handler p ) throw();&#125; set_new_handler的参数为new_handler指针，指向了operator new 无法分配足够内存时该调用的函数。其返回值也是个指针，指向set_new_handler被调用前正在执行（但马上就要发生替换）的那个new_handler函数。 对于malloc，客户并不能够去编程决定内存不足以分配时要干什么事，只能看着malloc返回NULL。 总结 将上面所述的10点差别整理成表格： 如有不对的地方，非常欢迎给予指导！ 如有疑问，可以给我留言 【感谢】资料来源于 ——http://blog.jobbole.com/102002/","raw":"---\ntitle: new和malloc的区别\ncopyright: true\ntags: C++\ncategories: C++\ncomments: true\nabbrlink: c69e57ea\ndate: 2019-09-19 14:58:35\ntype:\nkeyword:\ntop:\npassword:\ndescription:\n---\n\n## 1. 申请的内存所在位置\n\n　　new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。\n\n　　自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。\n\n　　那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。\n\n<!--more-->\n\n　　特别的，new甚至可以不为对象分配内存！定位new的功能可以办到这一点：\n\n```c++\nnew (place_address) type\n```\n\n　　place_address为一个指针，代表一块内存的地址。当使用上面这种仅以一个地址调用new操作符时，new操作符调用特殊的operator new，也就是下面这个版本：\n\n```c++\nvoid * operator new (size_t,void *) //不允许重定义这个版本的operator new\n```\n\n　　这个operator new不分配任何的内存，它只是简单地返回指针实参，然后右new表达式负责在place_address指定的地址进行对象的初始化工作。\n\n​\t\t所以以这种方式new的指针无需delete，只需要关注place_address的内存的释放与否。例如：\n\n```c++\ntempalete <typename U>\nstatic inline U* create_array(size_t count)\n{\n\tassert(count > 0);\n\tauto p = static_cast<U*>((malloc)(sizeof(U) * count)) //创建一块内存\n\tif (nullptr == p){\n\t\treturn nullptr;\n\t}\n\t\n\tfor (size_t i = 0; i != count; ++i){\n\t\tnew (p + i) U();  //在指定的内存地址创建对象\n\t}\n\treturn p;\n}\n```\n\n```c++\ntempalete <typename U>\nstatic inline void destory_array(U* p, size_t count)\n{\n\tif(p != nullptr){\n\t\tassert(count > 0);\n\t\tfor (size_t i = count; i !- 0; ){\n\t\t\t(p + --i)->~U();  //析构指定内存位置的对象\n\t\t}\n\t\t(free)(p);  //释放内存\n\t}\n}\n```\n\n\n\n## 2.返回类型安全性\n\n　　new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。\n\n　　类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图分配自己没被授权的内存区域。关于C++的类型安全性可说的又有很多了。\n\n## 3.内存分配失败时的返回值\n\n　　new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。\n\n　　在使用C语言时，我们习惯在malloc分配内存后判断分配是否成功：\n\n```c++\nint *a  = (int *)malloc ( sizeof (int ));\nif(NULL == a)\n{\n    ...\n}\nelse \n{\n    ...\n}\n```\n\n　　从C语言走入C++阵营的新手可能会把这个习惯带入C++：\n\n```c++\nint * a = new int();\nif(NULL == a)\n{\n    ...\n}\nelse\n{   \n    ...\n}\n\n```\n\n　　实际上这样做一点意义也没有，因为new根本不会返回NULL，而且程序能够执行到if语句已经说明内存分配成功了，如果失败早就抛异常了。正确的做法应该是使用异常机制：\n\n```c++\ntry\n{\n    int *a = new int();\n}\ncatch (bad_alloc)\n{\n    ...\n}\n```\n\n　　如果你想顺便了解下异常基础，可以看http://www.cnblogs.com/QG-whz/p/5136883.htmlC++ 异常机制分析。\n\n## 4.是否需要指定内存大小\n\n　　使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。\n\n```c++\nclass A{...}\nA * ptr = new A;\nA * ptr = (A *)malloc(sizeof(A)); //需要显式指定所需内存大小sizeof(A);\n```\n\n　　当然了，我这里使用malloc来为我们自定义类型分配内存是不怎么合适的，请看下一条。\n\n## 5.是否调用构造函数/析构函数\n\n　　使用new操作符来分配对象内存时会经历三个步骤：\n\n　　第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。\n\n　　第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。\n\n　　第三部：对象构造完成后，返回一个指向该对象的指针。\n\n　　使用delete操作符来释放对象内存时会经历两个步骤：\n\n　　第一步：调用对象的析构函数。\n\n　　第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。\n\n　　总之来说，new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构。而malloc则不会。如果你不嫌啰嗦可以看下我的例子：\n\n```c++\n class A\n{\npublic:\n    A() :a(1), b(1.11){}\nprivate:\n    int a;\n    double b;\n};\nint main()\n{\n    A * ptr = (A*)malloc(sizeof(A));\n    return 0;\n}\n```\n\n　　在return处设置断点，观看ptr所指内存的内容：\n\n![img](https://images2018.cnblogs.com/blog/1191971/201803/1191971-20180319110403732-1469701660.png)\n\n　　可以看出A的默认构造函数并没有被调用，因为数据成员a,b的值并没有得到初始化，这也是上面我为什么说使用malloc/free来处理C++的自定义类型不合适，其实不止自定义类型，标准库中凡是需要构造/析构的类型通通不合适。\n\n　　而使用new来分配对象时：\n\n```c++\nint main()\n{\n    A * ptr = new A;\n}\n```\n\n　　查看程序生成的汇编代码可以发现，A的默认构造函数被调用了：\n\n![img](https://images2018.cnblogs.com/blog/1191971/201803/1191971-20180319110522159-1015504969.png)\n\n## 6.对数组的处理\n\n　　C++提供了new[]与delete[]来专门处理数组类型:\n\n```c++\nA * ptr = new A[10];//分配10个A对象\n```\n\n　　使用new[]分配的内存必须使用delete[]进行释放：\n\n```c++\ndelete [] ptr;\n```\n\n　　new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。\n\n　　至于malloc，它并知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小：\n\n```c++\nint * ptr = (int *) malloc( sizeof(int)* 10 );//分配一个10个int元素的数组\n```\n\n## 7.new与malloc是否可以相互调用\n\n　　operator new /operator delete的实现可以基于malloc，而malloc的实现不可以去调用new。下面是编写operator new /operator delete 的一种简单方式，其他版本也与之类似：\n\n```c++\n void * operator new (sieze_t size)\n {\n     if(void * mem = malloc(size)\n         return mem;\n     else\n         throw bad_alloc();\n }\n void operator delete(void *mem) noexcept\n {\n     free(mem);\n }\n```\n\n## 8.是否可以被重载\n\n　　opeartor new /operator delete可以被重载。标准库是定义了operator new函数和operator delete函数的8个重载版本：\n\n```c++\n 1 //这些版本可能抛出异常\n 2 void * operator new(size_t);\n 3 void * operator new[](size_t);\n 4 void * operator delete (void * )noexcept;\n 5 void * operator delete[](void *0）noexcept;\n 6 //这些版本承诺不抛出异常\n 7 void * operator new(size_t ,nothrow_t&) noexcept;\n 8 void * operator new[](size_t, nothrow_t& );\n 9 void * operator delete (void *,nothrow_t& )noexcept;\n10 void * operator delete[](void *0,nothrow_t& ）noexcept;\n```\n\n　　我们可以自定义上面函数版本中的任意一个，前提是自定义版本必须位于全局作用域或者类作用域中。太细节的东西不在这里讲述，总之，我们知道我们有足够的自由去重载operator new /operator delete ,以决定我们的new与delete如何为对象分配内存，如何回收对象。\n\n　　而malloc/free并不允许重载。\n\n## 9. 能够直观地重新分配内存\n\n　　使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。\n\n　　new没有这样直观的配套设施来扩充内存。\n\n## 10. 客户处理内存分配不足\n\n　　在operator new抛出异常以反映一个未获得满足的需求之前，它会先调用一个用户指定的错误处理函数，这就是new-handler。new_handler是一个指针类型：\n\n```c++\nnamespace std\n{\n    typedef void (*new_handler)();\n}\n```\n\n　　指向了一个没有参数没有返回值的函数,即为错误处理函数。为了指定错误处理函数，客户需要调用set_new_handler，这是一个声明于的一个标准库函数:\n\n```c++\nnamespace std\n{\n    new_handler set_new_handler(new_handler p ) throw();\n}\n```\n\n　　set_new_handler的参数为new_handler指针，指向了operator new 无法分配足够内存时该调用的函数。其返回值也是个指针，指向set_new_handler被调用前正在执行（但马上就要发生替换）的那个new_handler函数。\n\n　　对于malloc，客户并不能够去编程决定内存不足以分配时要干什么事，只能看着malloc返回NULL。\n\n## 总结\n\n　　将上面所述的10点差别整理成表格：\n\n![img](https://images2018.cnblogs.com/blog/1191971/201803/1191971-20180319111342066-1232739079.png)\n\n \n\n \n\n**如有不对的地方，非常欢迎给予指导！**\n\n　　**如有疑问，可以给我留言**\n\n \n\n**【感谢】资料来源于**\n\n**——http://blog.jobbole.com/102002/**","content":"<h2 id=\"1-申请的内存所在位置\">1. 申请的内存所在位置<a href=\"posts/new和malloc的区别#1-申请的内存所在位置\"></a></h2><p>　　new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。</p>\n<p>　　自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。</p>\n<p>　　那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。</p>\n<a id=\"more\"></a>\n\n<p>　　特别的，new甚至可以不为对象分配内存！定位new的功能可以办到这一点：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> (place_address) type</span><br></pre></td></tr></table></div></figure>\n\n<p>　　place_address为一个指针，代表一块内存的地址。当使用上面这种仅以一个地址调用new操作符时，new操作符调用特殊的operator new，也就是下面这个版本：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> * <span class=\"keyword\">operator</span> <span class=\"title\">new</span> <span class=\"params\">(<span class=\"keyword\">size_t</span>,<span class=\"keyword\">void</span> *)</span> <span class=\"comment\">//不允许重定义这个版本的operator new</span></span></span><br></pre></td></tr></table></div></figure>\n\n<p>　　这个operator new不分配任何的内存，它只是简单地返回指针实参，然后右new表达式负责在place_address指定的地址进行对象的初始化工作。</p>\n<p>​        所以以这种方式new的指针无需delete，只需要关注place_address的内存的释放与否。例如：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tempalete &lt;<span class=\"keyword\">typename</span> U&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> U* <span class=\"title\">create_array</span><span class=\"params\">(<span class=\"keyword\">size_t</span> count)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tassert(count &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> p = <span class=\"keyword\">static_cast</span>&lt;U*&gt;((<span class=\"built_in\">malloc</span>)(<span class=\"keyword\">sizeof</span>(U) * count)) <span class=\"comment\">//创建一块内存</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"literal\">nullptr</span> == p)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i != count; ++i)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> (p + i) U();  <span class=\"comment\">//在指定的内存地址创建对象</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tempalete &lt;<span class=\"keyword\">typename</span> U&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">destory_array</span><span class=\"params\">(U* p, <span class=\"keyword\">size_t</span> count)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(p != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">\t\tassert(count &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = count; i !- <span class=\"number\">0</span>; )&#123;</span><br><span class=\"line\">\t\t\t(p + --i)-&gt;~U();  <span class=\"comment\">//析构指定内存位置的对象</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t(<span class=\"built_in\">free</span>)(p);  <span class=\"comment\">//释放内存</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"2-返回类型安全性\">2.返回类型安全性<a href=\"posts/new和malloc的区别#2-返回类型安全性\"></a></h2><p>　　new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。</p>\n<p>　　类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图分配自己没被授权的内存区域。关于C++的类型安全性可说的又有很多了。</p>\n<h2 id=\"3-内存分配失败时的返回值\">3.内存分配失败时的返回值<a href=\"posts/new和malloc的区别#3-内存分配失败时的返回值\"></a></h2><p>　　new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。</p>\n<p>　　在使用C语言时，我们习惯在malloc分配内存后判断分配是否成功：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *a  = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span> ( <span class=\"keyword\">sizeof</span> (<span class=\"keyword\">int</span> ));</span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">NULL</span> == a)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>　　从C语言走入C++阵营的新手可能会把这个习惯带入C++：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> * a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>();</span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">NULL</span> == a)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>　　实际上这样做一点意义也没有，因为new根本不会返回NULL，而且程序能够执行到if语句已经说明内存分配成功了，如果失败早就抛异常了。正确的做法应该是使用异常机制：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span> (bad_alloc)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>　　如果你想顺便了解下异常基础，可以看<a href=\"http://www.cnblogs.com/QG-whz/p/5136883.htmlC++\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/QG-whz/p/5136883.htmlC++</a> 异常机制分析。</p>\n<h2 id=\"4-是否需要指定内存大小\">4.是否需要指定内存大小<a href=\"posts/new和malloc的区别#4-是否需要指定内存大小\"></a></h2><p>　　使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&#123;</span>...&#125;</span><br><span class=\"line\">A * ptr = <span class=\"keyword\">new</span> A;</span><br><span class=\"line\">A * ptr = (A *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(A)); <span class=\"comment\">//需要显式指定所需内存大小sizeof(A);</span></span><br></pre></td></tr></table></div></figure>\n\n<p>　　当然了，我这里使用malloc来为我们自定义类型分配内存是不怎么合适的，请看下一条。</p>\n<h2 id=\"5-是否调用构造函数-析构函数\">5.是否调用构造函数/析构函数<a href=\"posts/new和malloc的区别#5-是否调用构造函数-析构函数\"></a></h2><p>　　使用new操作符来分配对象内存时会经历三个步骤：</p>\n<p>　　第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。</p>\n<p>　　第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。</p>\n<p>　　第三部：对象构造完成后，返回一个指向该对象的指针。</p>\n<p>　　使用delete操作符来释放对象内存时会经历两个步骤：</p>\n<p>　　第一步：调用对象的析构函数。</p>\n<p>　　第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。</p>\n<p>　　总之来说，new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构。而malloc则不会。如果你不嫌啰嗦可以看下我的例子：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    A() :a(<span class=\"number\">1</span>), b(<span class=\"number\">1.11</span>)&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    A * ptr = (A*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(A));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>　　在return处设置断点，观看ptr所指内存的内容：</p>\n<p><img src=\"https://images2018.cnblogs.com/blog/1191971/201803/1191971-20180319110403732-1469701660.png\" alt=\"img\" class=\"article-img\"></p>\n<p>　　可以看出A的默认构造函数并没有被调用，因为数据成员a,b的值并没有得到初始化，这也是上面我为什么说使用malloc/free来处理C++的自定义类型不合适，其实不止自定义类型，标准库中凡是需要构造/析构的类型通通不合适。</p>\n<p>　　而使用new来分配对象时：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    A * ptr = <span class=\"keyword\">new</span> A;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>　　查看程序生成的汇编代码可以发现，A的默认构造函数被调用了：</p>\n<p><img src=\"https://images2018.cnblogs.com/blog/1191971/201803/1191971-20180319110522159-1015504969.png\" alt=\"img\" class=\"article-img\"></p>\n<h2 id=\"6-对数组的处理\">6.对数组的处理<a href=\"posts/new和malloc的区别#6-对数组的处理\"></a></h2><p>　　C++提供了new[]与delete[]来专门处理数组类型:</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A * ptr = <span class=\"keyword\">new</span> A[<span class=\"number\">10</span>];<span class=\"comment\">//分配10个A对象</span></span><br></pre></td></tr></table></div></figure>\n\n<p>　　使用new[]分配的内存必须使用delete[]进行释放：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">delete</span> [] ptr;</span><br></pre></td></tr></table></div></figure>\n\n<p>　　new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。</p>\n<p>　　至于malloc，它并知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> * ptr = (<span class=\"keyword\">int</span> *) <span class=\"built_in\">malloc</span>( <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)* <span class=\"number\">10</span> );<span class=\"comment\">//分配一个10个int元素的数组</span></span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"7-new与malloc是否可以相互调用\">7.new与malloc是否可以相互调用<a href=\"posts/new和malloc的区别#7-new与malloc是否可以相互调用\"></a></h2><p>　　operator new /operator delete的实现可以基于malloc，而malloc的实现不可以去调用new。下面是编写operator new /operator delete 的一种简单方式，其他版本也与之类似：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> * <span class=\"keyword\">operator</span> <span class=\"title\">new</span> <span class=\"params\">(<span class=\"keyword\">sieze_t</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">void</span> * mem = <span class=\"built_in\">malloc</span>(size)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mem;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> bad_alloc();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"keyword\">operator</span> <span class=\"keyword\">delete</span>(<span class=\"keyword\">void</span> *mem) <span class=\"keyword\">noexcept</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(mem);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"8-是否可以被重载\">8.是否可以被重载<a href=\"posts/new和malloc的区别#8-是否可以被重载\"></a></h2><p>　　opeartor new /operator delete可以被重载。标准库是定义了operator new函数和operator delete函数的8个重载版本：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"number\">1</span> <span class=\"comment\">//这些版本可能抛出异常</span></span><br><span class=\"line\"> <span class=\"number\">2</span> <span class=\"function\"><span class=\"keyword\">void</span> * <span class=\"keyword\">operator</span> <span class=\"title\">new</span><span class=\"params\">(<span class=\"keyword\">size_t</span>)</span></span>;</span><br><span class=\"line\"> <span class=\"number\">3</span> <span class=\"keyword\">void</span> * <span class=\"keyword\">operator</span> <span class=\"keyword\">new</span>[](<span class=\"keyword\">size_t</span>);</span><br><span class=\"line\"> <span class=\"number\">4</span> <span class=\"function\"><span class=\"keyword\">void</span> * <span class=\"keyword\">operator</span> <span class=\"title\">delete</span> <span class=\"params\">(<span class=\"keyword\">void</span> * )</span><span class=\"keyword\">noexcept</span></span>;</span><br><span class=\"line\"> <span class=\"number\">5</span> <span class=\"keyword\">void</span> * <span class=\"keyword\">operator</span> <span class=\"keyword\">delete</span>[](<span class=\"keyword\">void</span> *<span class=\"number\">0</span>）<span class=\"keyword\">noexcept</span>;</span><br><span class=\"line\"> <span class=\"number\">6</span> <span class=\"comment\">//这些版本承诺不抛出异常</span></span><br><span class=\"line\"> <span class=\"number\">7</span> <span class=\"keyword\">void</span> * <span class=\"keyword\">operator</span> <span class=\"keyword\">new</span>(<span class=\"keyword\">size_t</span> ,<span class=\"keyword\">nothrow_t</span>&amp;) <span class=\"keyword\">noexcept</span>;</span><br><span class=\"line\"> <span class=\"number\">8</span> <span class=\"keyword\">void</span> * <span class=\"keyword\">operator</span> <span class=\"keyword\">new</span>[](<span class=\"keyword\">size_t</span>, <span class=\"keyword\">nothrow_t</span>&amp; );</span><br><span class=\"line\"> <span class=\"number\">9</span> <span class=\"keyword\">void</span> * <span class=\"keyword\">operator</span> <span class=\"keyword\">delete</span> (<span class=\"keyword\">void</span> *,<span class=\"keyword\">nothrow_t</span>&amp; )<span class=\"keyword\">noexcept</span>;</span><br><span class=\"line\"><span class=\"number\">10</span> <span class=\"keyword\">void</span> * <span class=\"keyword\">operator</span> <span class=\"keyword\">delete</span>[](<span class=\"keyword\">void</span> *<span class=\"number\">0</span>,<span class=\"keyword\">nothrow_t</span>&amp; ）<span class=\"keyword\">noexcept</span>;</span><br></pre></td></tr></table></div></figure>\n\n<p>　　我们可以自定义上面函数版本中的任意一个，前提是自定义版本必须位于全局作用域或者类作用域中。太细节的东西不在这里讲述，总之，我们知道我们有足够的自由去重载operator new /operator delete ,以决定我们的new与delete如何为对象分配内存，如何回收对象。</p>\n<p>　　而malloc/free并不允许重载。</p>\n<h2 id=\"9-能够直观地重新分配内存\">9. 能够直观地重新分配内存<a href=\"posts/new和malloc的区别#9-能够直观地重新分配内存\"></a></h2><p>　　使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。</p>\n<p>　　new没有这样直观的配套设施来扩充内存。</p>\n<h2 id=\"10-客户处理内存分配不足\">10. 客户处理内存分配不足<a href=\"posts/new和malloc的区别#10-客户处理内存分配不足\"></a></h2><p>　　在operator new抛出异常以反映一个未获得满足的需求之前，它会先调用一个用户指定的错误处理函数，这就是new-handler。new_handler是一个指针类型：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(*new_handler)</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>　　指向了一个没有参数没有返回值的函数,即为错误处理函数。为了指定错误处理函数，客户需要调用set_new_handler，这是一个声明于的一个标准库函数:</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\">new_handler <span class=\"title\">set_new_handler</span><span class=\"params\">(new_handler p )</span> <span class=\"title\">throw</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>　　set_new_handler的参数为new_handler指针，指向了operator new 无法分配足够内存时该调用的函数。其返回值也是个指针，指向set_new_handler被调用前正在执行（但马上就要发生替换）的那个new_handler函数。</p>\n<p>　　对于malloc，客户并不能够去编程决定内存不足以分配时要干什么事，只能看着malloc返回NULL。</p>\n<h2 id=\"总结\">总结<a href=\"posts/new和malloc的区别#总结\"></a></h2><p>　　将上面所述的10点差别整理成表格：</p>\n<p><img src=\"https://images2018.cnblogs.com/blog/1191971/201803/1191971-20180319111342066-1232739079.png\" alt=\"img\" class=\"article-img\"></p>\n<p><strong>如有不对的地方，非常欢迎给予指导！</strong></p>\n<p>　　<strong>如有疑问，可以给我留言</strong></p>\n<p><strong>【感谢】资料来源于</strong></p>\n<p><strong>——<a href=\"http://blog.jobbole.com/102002/\" target=\"_blank\" rel=\"noopener\">http://blog.jobbole.com/102002/</a></strong></p>\n","slug":"new和malloc的区别","updated":"2019-09-19T07:24:55.931Z","comments":true,"link":"posts/new和malloc的区别","permalink":"https://shuntan.github.io/posts/new和malloc的区别/","excerpt":"1. 申请的内存所在位置 new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。 自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。 那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。","categories":[{"name":"C++","slug":"C","permalink":"https://shuntan.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://shuntan.github.io/tags/C/"}]},{"title":"Linux--awk命令","date":"2019-09-18T12:00:37.000Z","path":"posts/Linux-awk命令/","text":"一：awk简介​ awk其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。实际上 AWK 的确拥有自己的语言： AWK 程序设计语言 ， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。 ​ awk 是一种很棒的语言，它适合文本处理和报表生成，其语法较为常见，借鉴了某些语言的一些精华，如 C 语言等。在 linux 系统日常处理工作中，发挥很重要的作用，掌握了 awk将会使你的工作变的高大上。 awk 是三剑客的老大，利剑出鞘，必会不同凡响。 回到顶部 二：使用方法1`awk ``'&#123;pattern + action&#125;'` `&#123;filenames&#125;` ​ 尽管操作可能会很复杂，但语法总是这样，其中 pattern 表示 AWK 在数据中查找的内容，而 action 是在找到匹配内容时所执行的一系列命令。花括号（{}）不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组。 pattern就是要表示的正则表达式，用斜杠括起来。 ​ awk语言的最基本功能是在文件或者字符串中基于指定规则浏览和抽取信息，awk抽取信息后，才能进行其他文本操作。完整的awk脚本通常用来格式化文本文件中的信息。 通常，awk是以文件的一行为处理单位的。awk每接收文件的一行，然后执行相应的命令，来处理文本。 回到顶部 三：awk 的原理通过一个简短的命令，我们来了解其工作原理。 1`[root@Gin scripts]# awk ``'&#123;print $0&#125;'` `/etc/passwd``root:x:0:0:root:/root:/bin/bash``bin:x:1:1:bin:/bin:/sbin/nologin``.....................................................`` ` `[root@Gin scripts]# echo hhh|awk ``'&#123;print \"hello,world\"&#125;'``hello,world`` ` `[root@Gin scripts]# awk ``'&#123;print \"hiya\"&#125;'` `/etc/passwd``hiya``hiya``hiya``hiya``...............................................` ​ 你将会见到/etc/passwd 文件的内容出现在眼前。现在，解释 awk 做了些什么。调用 awk时，我们指定/etc/passwd 作为输入文件。执行 awk 时，它依次对/etc/passwd 中的每一行执行 print 命令。 ​ 所有输出都发送到 stdout，所得到的结果与执行 cat /etc/passwd 完全相同。​ 现在，解释{ print }代码块。在 awk 中，花括号用于将几块代码组合到一起，这一点类似于 C 语言。在代码块中只有一条 print 命令。在 awk 中，如果只出现 print 命令，那么将打印当前行的全部内容。再次说明， awk 对输入文件中的每一行都执行这个脚本。 1`$ awk -F``\":\"` `'&#123; print $1 &#125;'` `/etc/passwd``$ awk -F``\":\"` `'&#123; print $1 $3 &#125;'` `/etc/passwd``$ awk -F``\":\"` `'&#123; print $1 \" \" $3 &#125;'` `/etc/passwd``$ awk -F``\":\"` `'&#123; print \"username: \" $1 \"\\t\\tuid:\" $3\" &#125;'` `/etc/passwd` -F参数：指定分隔符，可指定一个或多个 print 后面做字符串的拼接 下面通过几实例来了解下awk的工作原理： 实例一：只查看test.txt文件（100行）内第20到第30行的内容（企业面试）1`#print $a取列#NR取行数[root@Gin scripts]# awk '&#123;if(NR&gt;=20 &amp;&amp; NR&lt;=30) print $1&#125;' test.txt ``20``21``22``23``24``25``26``27``28``29``30` 实例二：已知test.txt文件内容为：1`[root@Gin scripts]# cat test.txt``I am Poe,my qq ``is` `33794712` 请从该文件中过滤出’Poe’字符串与33794712，最后输出的结果为：Poe 33794712 1`[root@Gin scripts]# awk -F ``'[ ,]+'` `'&#123;print $3\" \"$7&#125;'` `test.txt``Poe 33794712` BEGIN 和 END 模块通常，对于每个输入行， awk 都会执行每个脚本代码块一次。然而，在许多编程情况中，可能需要在 awk 开始处理输入文件中的文本之前执行初始化代码。对于这种情况， awk 允许您定义一个 BEGIN 块。 因为 awk 在开始处理输入文件之前会执行 BEGIN 块，因此它是初始化 FS（字段分隔符）变量、打印页眉或初始化其它在程序中以后会引用的全局变量的极佳位置。awk 还提供了另一个特殊块，叫作 END 块。 awk 在处理了输入文件中的所有行之后执行这个块。通常， END 块用于执行最终计算或打印应该出现在输出流结尾的摘要信息。 实例一：统计/etc/passwd的账户人数1`[root@Gin scripts]# awk ``'&#123;count++;print $0;&#125; END&#123;print \"user count is \",count&#125;'` `passwd``root:x:0:0:root:/root:/bin/bash``..............................................``user count ``is` `27` count是自定义变量。之前的action{}里都是只有一个print,其实print只是一个语句，而action{}可以有多个语句，以;号隔开。这里没有初始化count，虽然默认是0，但是妥当的做法还是初始化为0: 1`[root@Gin scripts]# awk ``'BEGIN &#123;count=0;print \"[start] user count is \",count&#125; &#123;count=count+1;print $0&#125; END&#123;print \"[end] user count is \",count&#125;'` `passwd``[start] user count ``is` `0``root:x:0:0:root:/root:/bin/bash``...................................................................``[end] user count ``is` `27` 实例二：统计某个文件夹下的文件占用的字节数1`[root@Gin scripts]# ll |awk ``'BEGIN &#123;size=0;&#125; &#123;size=size+$5;&#125; END&#123;print \"[end]size is \",size&#125;'``[end]size ``is` `1489` 如果以M为单位显示: 1`[root@Gin scripts]# ll |awk ``'BEGIN&#123;size=0;&#125; &#123;size=size+$5;&#125; END&#123;print \"[end]size is \",size/1024/1024,\"M\"&#125;'` `[end]size ``is` `0.00142002 M` awk运算符 awk 赋值运算符：a+5;等价于： a=a+5;其他同类1`[root@Gin scripts]# awk ``'BEGIN&#123;a=5;a+=5;print a&#125;'``10` awk逻辑运算符：1`[root@Gin scripts]# awk ``'BEGIN&#123;a=1;b=2;print (a&gt;2&amp;&amp;b&gt;1,a=1||b&gt;1)&#125;'``0 1` 判断表达式 a&gt;2&amp;&amp;b&gt;1为真还是为假，后面的表达式同理 awk正则运算符：1`[root@Gin scripts]# awk ``'BEGIN&#123;a=\"100testaa\";if(a~/100/) &#123;print \"ok\"&#125;&#125;'``ok` 1`[root@Gin scripts]# echo|awk ``'BEGIN&#123;a=\"100testaaa\"&#125;a~/test/&#123;print \"ok\"&#125;'``ok` 关系运算符：如： &gt; &lt; 可以作为字符串比较，也可以用作数值比较，关键看操作数如果是字符串就会转换为字符串比较。两个都为数字 才转为数值比较。字符串比较：按照ascii码顺序比较。 1`[root@Gin scripts]# awk ``'BEGIN&#123;a=\"11\";if(a&gt;=9)&#123;print \"ok\"&#125;&#125;'` `#无输出``[root@Gin scripts]# awk ``'BEGIN&#123;a=11;if(a&gt;=9)&#123;print \"ok\"&#125;&#125;'``ok``[root@Gin scripts]# awk ``'BEGIN&#123;a;if(a&gt;=b)&#123;print \"ok\"&#125;&#125;'``ok` awk 算术运算符：说明，所有用作算术运算符进行操作，操作数自动转为数值，所有非数值都变为0。 1`[root@Gin scripts]# awk ``'BEGIN&#123;a=\"b\";print a++,++a&#125;'``0 2``[root@Gin scripts]# awk ``'BEGIN&#123;a=\"20b4\";print a++,++a&#125;'``20 22` 这里的a++ , ++a与javascript语言一样：a++是先赋值加++；++a是先++再赋值 三目运算符 ?:1`[root@Gin scripts]# awk ``'BEGIN&#123;a=\"b\";print a==\"b\"?\"ok\":\"err\"&#125;'``ok``[root@Gin scripts]# awk ``'BEGIN&#123;a=\"b\";print a==\"c\"?\"ok\":\"err\"&#125;'``err` 常用 awk 内置变量 注：内置变量很多，参阅相关资料 字段分隔符 FSFS=”\\t” 一个或多个 Tab 分隔 1`[root@Gin scripts]# cat tab.txt``ww CC IDD``[root@Gin scripts]# awk ``'BEGIN&#123;FS=\"\\t+\"&#125;&#123;print $1,$2,$3&#125;'` `tab.txt``ww CC IDD` FS=”[[:space:]+]” 一个或多个空白空格，默认的 1`[root@Gin scripts]# cat space.txt``we are studing awk now!``[root@Gin scripts]# awk -F [[:space:]+] ``'&#123;print $1,$2,$3,$4,$5&#125;'` `space.txt``we are ``[root@Gin scripts]# awk -F [[:space:]+] ``'&#123;print $1,$2&#125;'` `space.txt``we are` FS=”[“ “:]+” 以一个或多个空格或：分隔 1`[root@Gin scripts]# cat hello.txt``root:x:0:0:root:/root:/bin/bash``[root@Gin scripts]# awk -F [``\" \"``:]+ ``'&#123;print $1,$2,$3&#125;'` `hello.txt``root x 0` 字段数量 NF 1`[root@Gin scripts]# cat hello.txt``root:x:0:0:root:/root:/bin/bash``bin:x:1:1:bin:/bin:/sbin/nologin:888``[root@Gin scripts]# awk -F ``\":\"` `'NF==8&#123;print $0&#125;'` `hello.txt``bin:x:1:1:bin:/bin:/sbin/nologin:888` 记录数量 NR 1`[root@Gin scripts]# ifconfig eth0|awk -F [``\" \"``:]+ ``'NR==2&#123;print $4&#125;'` `## NR==2也就是取第2行``192.168.17.129` RS 记录分隔符变量将 FS 设置成”\\n”告诉 awk 每个字段都占据一行。通过将 RS 设置成””，还会告诉 awk每个地址记录都由空白行分隔。 1`[root@Gin scripts]# cat recode.txt``Jimmy the Weasel``100 Pleasant Drive``San Francisco,CA 123456`` ` `Big Tony``200 Incognito Ave.``Suburbia,WA 64890``[root@Gin scripts]# cat awk.txt``#!/bin/awk``BEGIN &#123;`` ``FS=``\"\\n\"`` ``RS=``\"\"``&#125;``&#123;`` ``print $1``\",\"``$2``\",\"``$3``&#125;``[root@Gin scripts]# awk -f awk.txt recode.txt``Jimmy the Weasel,100 Pleasant Drive,San Francisco,CA 123456``Big Tony,200 Incognito Ave.,Suburbia,WA 64890` OFS 输出字段分隔符 1`[root@Gin scripts]# cat hello.txt``root:x:0:0:root:/root:/bin/bash``bin:x:1:1:bin:/bin:/sbin/nologin:888``[root@Gin scripts]# awk ``'BEGIN&#123;FS=\":\"&#125;&#123;print $1\",\"$2\",\"$3&#125;'` `hello.txt``root,x,0``bin,x,1``[root@Gin scripts]# awk ``'BEGIN&#123;FS=\":\";OFS=\"#\"&#125;&#123;print $1,$2,$3&#125;'` `hello.txt``root#x#0``bin#x#1` ORS 输出记录分隔符 1`[root@Gin scripts]# cat recode.txt``Jimmy the Weasel``100 Pleasant Drive``San Francisco,CA 123456`` ` `Big Tony``200 Incognito Ave.``Suburbia,WA 64890``[root@Gin scripts]# cat awk.txt``#!/bin/awk``BEGIN &#123;`` ``FS=``\"\\n\"`` ``RS=``\"\"`` ``ORS=``\"\\n\\n\"``&#125;``&#123;`` ``print $1``\",\"``$2``\",\"``$3``&#125;``[root@Gin scripts]# awk -f awk.txt recode.txt``Jimmy the Weasel,100 Pleasant Drive,San Francisco,CA 123456`` ` `Big Tony,200 Incognito Ave.,Suburbia,WA 64890` awk 正则 正则应用规则表达式 awk ‘/REG/{action} ‘ file,/REG/为正则表达式，可以将$0 中，满足条件的记录送入到：action 进行处理 1`[root@Gin scripts]# awk ``'/root/&#123;print $0&#125;'` `passwd ##匹配所有包含root的行``root:x:0:0:root:/root:/bin/bash``operator``:x:11:0:``operator``:/root:/sbin/nologin`` ` `[root@Gin scripts]# awk -F: ``'$5~/root/&#123;print $0&#125;'` `passwd ## 以分号作为分隔符，匹配第5个字段是root的行``root:x:0:0:root:/root:/bin/bash`` ` `[root@Gin scripts]# ifconfig eth0|awk ``'BEGIN&#123;FS=\"[[:space:]:]+\"&#125; NR==2&#123;print $4&#125;'``192.168.17.129` 布尔表达式awk ‘布尔表达式{action}’ file 仅当对前面的布尔表达式求值为真时， awk 才执行代码块。 1`[root@Gin scripts]# awk -F: ``'$1==\"root\"&#123;print $0&#125;'` `passwd``root:x:0:0:root:/root:/bin/bash``[root@Gin scripts]# awk -F: ``'($1==\"root\")&amp;&amp;($5==\"root\") &#123;print $0&#125;'` `passwd``root:x:0:0:root:/root:/bin/bash` awk 的 if、循环和数组条件语句awk 提供了非常好的类似于 C 语言的 if 语句。 1`&#123;`` ``if` `($1==``\"foo\"``)&#123;`` ``if``($2==``\"foo\"``)&#123;`` ``print ``\"uno\"`` ``&#125;``else``&#123;`` ``print ``\"one\"`` ``&#125;`` ``&#125;elseif($1==``\"bar\"``)&#123;`` ``print ``\"two\"`` ``&#125;``else``&#123;`` ``print ``\"three\"`` ``&#125;``&#125;` 使用 if 语句还可以将代码： 1`! /matchme/ &#123; print $1 $3 $4 &#125;` 转换成： 1`&#123;`` ``if` `( $0 !~ /matchme/ ) &#123;`` print $1 $3 $4`` &#125;``&#125;` 循环结构我们已经看到了 awk 的 while 循环结构，它等同于相应的 C 语言 while 循环。 awk 还有”do…while”循环，它在代码块结尾处对条件求值，而不像标准 while 循环那样在开始处求值。 它类似于其它语言中的”repeat…until”循环。以下是一个示例：do…while 示例 1`&#123;`` ``count=1do &#123;`` ``print ``\"I get printed at least once no matter what\"`` ``&#125; ``while` `( count !=1 )``&#125;` 与一般的 while 循环不同，由于在代码块之后对条件求值， “do…while”循环永远都至少执行一次。换句话说，当第一次遇到普通 while 循环时，如果条件为假，将永远不执行该循环。 for 循环awk 允许创建 for 循环，它就象 while 循环，也等同于 C 语言的 for 循环： 1`for` `( initial assignment; comparison; increment ) &#123;`` ``code block``&#125;` 以下是一个简短示例： 1`for` `( x=1;x&lt;=4;x++ ) &#123;`` ``print ``\"iteration\"``, x``&#125;` 此段代码将打印： 1`iteration1``iteration2``iteration3``iteration4` break 和 continue此外，如同 C 语言一样， awk 提供了 break 和 continue 语句。使用这些语句可以更好地控制 awk 的循环结构。以下是迫切需要 break 语句的代码片断： 1`while` `死循环``while` `(1) &#123;``print ``\"forever and ever...\"``&#125;``while` `死循环 1 永远代表是真，这个 ``while` `循环将永远运行下去。` 以下是一个只执行十次的循环： 1`#break 语句示例``x=1``while``(1) &#123;`` print ``\"iteration\"``, x`` ``if` `( x==10 ) &#123;`` ``break`` &#125;`` x++``&#125;` 这里， break 语句用于“逃出”最深层的循环。 “break”使循环立即终止，并继续执行循环代码块后面的语句。continue 语句补充了 break，其作用如下： 1`x=1while (1) &#123;`` ``if` `( x==4 ) &#123;`` ``x++`` ``continue`` ``&#125;`` ``print ``\"iteration\"``, x`` ``if` `( x&gt;20 ) &#123;`` ``break`` ``&#125;`` ``x++``&#125;` 这段代码打印”iteration1”到”iteration21”， “iteration4”除外。如果迭代等于 4，则增加 x并调用 continue 语句，该语句立即使 awk 开始执行下一个循环迭代，而不执行代码块的其余部分。如同 break 一样， continue 语句适合各种 awk 迭代循环。在 for 循环主体中使用时， continue 将使循环控制变量自动增加。以下是一个等价循环： 1`for` `( x=1;x&lt;=21;x++ ) &#123;`` ``if` `( x==4 ) &#123;`` ``continue`` ``&#125;`` ``print ``\"iteration\"``, x``&#125;` 在while 循环中时，在调用 continue 之前没有必要增加 x，因为 for 循环会自动增加 x。 数组AWK 中的数组都是关联数组,数字索引也会转变为字符串索引 1`&#123;`` ``cities[1]=”beijing”`` ``cities[2]=”shanghai”`` ``cities[“three”]=”guangzhou”`` ``for``( c ``in` `cities) &#123;`` ``print cities[c]`` ``&#125;`` ``print cities[1]`` ``print cities[“1”]`` ``print cities[“three”]``&#125;` for…in 输出，因为数组是关联数组，默认是无序的。所以通过 for…in 得到是无序的数组。如果需要得到有序数组，需要通过下标获得。 数组的典型应用用 awk 中查看服务器连接状态并汇总 1`netstat -an|awk ``'/^tcp/&#123;++s[$NF]&#125;END&#123;for(a in s)print a,s[a]&#125;'``ESTABLISHED 1``LISTEN 20` 统计 web 日志访问流量，要求输出访问次数，请求页面或图片，每个请求的总大小，总访问流量的大小汇总 1`awk '&#123;a[$7]+=$10;++b[$7];total+=$10&#125;END&#123;``for``(x ``in` `a)print b[x],x,a[x]|``\"sort -rn -k1\"``;print``\"total size is :\"``total&#125;' /app/log/access_log``total size ``is` `:172230``21 /icons/poweredby.png 83076``14 / 70546``8 /icons/apache_pb.gif 18608``a[$7]+=$10 表示以第 7 列为下标的数组（ $10 列为$7 列的大小），把他们大小累加得到``$7 每次访问的大小，后面的 ``for` `循环有个取巧的地方， a 和 b 数组的下标相同，所以一``条 ``for` `语句足矣` 常用字符串函数 字符串函数的应用替换 1`awk ``'BEGIN&#123;info=\"this is a test2010test!\";gsub(/[0-9]+/,\"!\",info);print info&#125;'` `this` `is` `a test!test!``在 info 中查找满足正则表达式， /[0-9]+/ 用”!”替换，并且替换后的值，赋值给 info 未``给 info 值，默认是$0` 查找 1`awk ``'BEGIN&#123;info=\"this is a test2010test!\";print index(info,\"test\")?\"ok\":\"no found\";&#125;'``ok #未找到，返回 0` 匹配查找 1`awk ``'BEGIN&#123;info=\"this is a test2010test!\";print match(info,/[0-9]+/)?\"ok\":\"no found\";&#125;'``ok #如果查找到数字则匹配成功返回 ok，否则失败，返回未找到` 截取 1`awk ``'BEGIN&#123;info=\"this is a test2010test!\";print substr(info,4,10);&#125;'``s ``is` `a tes #从第 4 个 字符开始，截取 10 个长度字符串` 分割 1`awk ``'BEGIN&#123;info=\"this is a test\";split(info,tA,\" \");print length(tA);for(k in tA)&#123;print k,tA[k];&#125;&#125;'` `4``4 test 1 ``this` `2 ``is` `3 a``#分割 info,动态创建数组 tA,awk for …in 循环，是一个无序的循环。 并不是从数组下标``1…n 开始`","raw":"---\ntitle: Linux--awk命令\ncopyright: true\ntags: Linux\ncategories: awk\ncomments: true\nabbrlink: 3d71fb36\ndate: 2019-09-18 20:00:37\ntype:\nkeyword:\ntop:\npassword:\ndescription:\n---\n\n## 一：awk简介\n\n​        awk其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。实际上 AWK 的确拥有自己的语言： AWK 程序设计语言 ， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。\n\n​       awk 是一种很棒的语言，它适合文本处理和报表生成，其语法较为常见，借鉴了某些语言的一些精华，如 C 语言等。在 linux 系统日常处理工作中，发挥很重要的作用，掌握了 awk将会使你的工作变的高大上。 awk 是三剑客的老大，利剑出鞘，必会不同凡响。\n\n<!--more-->\n\n[回到顶部](https://www.cnblogs.com/yaohong/p/9163471.html#_labelTop)\n\n## **二：使用方法**\n\n```\n`awk ``'{pattern + action}'` `{filenames}`\n```\n\n​        尽管操作可能会很复杂，但语法总是这样，其中 pattern 表示 AWK 在数据中查找的内容，而 action 是在找到匹配内容时所执行的一系列命令。花括号（{}）不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组。 pattern就是要表示的正则表达式，用斜杠括起来。\n\n​        awk语言的最基本功能是在文件或者字符串中基于指定规则浏览和抽取信息，awk抽取信息后，才能进行其他文本操作。完整的awk脚本通常用来格式化文本文件中的信息。\n\n通常，awk是以文件的一行为处理单位的。awk每接收文件的一行，然后执行相应的命令，来处理文本。\n\n[回到顶部](https://www.cnblogs.com/yaohong/p/9163471.html#_labelTop)\n\n## 三：awk 的原理\n\n通过一个简短的命令，我们来了解其工作原理。 \n\n```\n`[root@Gin scripts]# awk ``'{print $0}'` `/etc/passwd``root:x:0:0:root:/root:/bin/bash``bin:x:1:1:bin:/bin:/sbin/nologin``.....................................................`` ` `[root@Gin scripts]# echo hhh|awk ``'{print \"hello,world\"}'``hello,world`` ` `[root@Gin scripts]# awk ``'{print \"hiya\"}'` `/etc/passwd``hiya``hiya``hiya``hiya``...............................................`\n```\n\n　　\n\n \n\n​       你将会见到/etc/passwd 文件的内容出现在眼前。现在，解释 awk 做了些什么。调用 awk时，我们指定/etc/passwd 作为输入文件。执行 awk 时，它依次对/etc/passwd 中的每一行执行 print 命令。\n\n​       所有输出都发送到 stdout，所得到的结果与执行 cat /etc/passwd 完全相同。\n​       现在，解释{ print }代码块。在 awk 中，花括号用于将几块代码组合到一起，这一点类似于 C 语言。在代码块中只有一条 print 命令。在 awk 中，如果只出现 print 命令，那么将打印当前行的全部内容。\n**再次说明， awk 对输入文件中的每一行都执行这个脚本。**\n\n![img](https://images2015.cnblogs.com/blog/1089507/201701/1089507-20170126222420597-662074402.jpg)\n\n```\n`$ awk -F``\":\"` `'{ print $1 }'` `/etc/passwd``$ awk -F``\":\"` `'{ print $1 $3 }'` `/etc/passwd``$ awk -F``\":\"` `'{ print $1 \" \" $3 }'` `/etc/passwd``$ awk -F``\":\"` `'{ print \"username: \" $1 \"\\t\\tuid:\" $3\" }'` `/etc/passwd`\n```\n\n   -F参数：指定分隔符，可指定一个或多个\n\n   print 后面做字符串的拼接\n\n**下面通过几实例来了解下awk的工作原理：**\n\n#### 实例一：只查看test.txt文件（100行）内第20到第30行的内容（企业面试）\n\n \n\n```\n`#print $a取列#NR取行数[root@Gin scripts]# awk '{if(NR>=20 && NR<=30) print $1}' test.txt  ``20``21``22``23``24``25``26``27``28``29``30`\n```\n\n \n\n#### 实例二：已知test.txt文件内容为：\n\n```\n`[root@Gin scripts]# cat test.txt``I am Poe,my qq ``is` `33794712`\n```\n\n　　\n\n请从该文件中过滤出'Poe'字符串与33794712，最后输出的结果为：Poe 33794712\n\n```\n`[root@Gin scripts]# awk -F ``'[ ,]+'` `'{print $3\" \"$7}'` `test.txt``Poe 33794712`\n```\n\n　　\n\n \n\n\n\n### BEGIN 和 END 模块\n\n通常，对于每个输入行， awk 都会执行每个脚本代码块一次。然而，在许多编程情况中，可能需要在 awk 开始处理输入文件中的文本之前执行初始化代码。对于这种情况， awk 允许您定义一个 BEGIN 块。\n\n因为 awk 在开始处理输入文件之前会执行 BEGIN 块，因此它是初始化 FS（字段分隔符）变量、打印页眉或初始化其它在程序中以后会引用的全局变量的极佳位置。\nawk 还提供了另一个特殊块，叫作 END 块。 awk 在处理了输入文件中的所有行之后执行这个块。通常， END 块用于执行最终计算或打印应该出现在输出流结尾的摘要信息。\n\n#### 实例一：统计/etc/passwd的账户人数 \n\n```\n`[root@Gin scripts]# awk ``'{count++;print $0;} END{print \"user count is \",count}'` `passwd``root:x:0:0:root:/root:/bin/bash``..............................................``user count ``is`  `27`\n```\n\n　　\n\n \n\ncount是自定义变量。之前的action{}里都是只有一个print,其实print只是一个语句，而action{}可以有多个语句，以;号隔开。这里没有初始化count，虽然默认是0，但是妥当的做法还是初始化为0:\n\n```\n`[root@Gin scripts]# awk ``'BEGIN {count=0;print \"[start] user count is \",count} {count=count+1;print $0} END{print \"[end] user count is \",count}'` `passwd``[start] user count ``is`  `0``root:x:0:0:root:/root:/bin/bash``...................................................................``[end] user count ``is`  `27`\n```\n\n　　\n\n#### 实例二：统计某个文件夹下的文件占用的字节数\n\n```\n`[root@Gin scripts]# ll |awk ``'BEGIN {size=0;} {size=size+$5;} END{print \"[end]size is \",size}'``[end]size ``is`  `1489`\n```\n\n　　\n\n如果以M为单位显示:\n\n```\n`[root@Gin scripts]# ll |awk ``'BEGIN{size=0;} {size=size+$5;} END{print \"[end]size is \",size/1024/1024,\"M\"}'`  `[end]size ``is`  `0.00142002 M`\n```\n\n　　\n\n \n\n\n\n### awk运算符\n\n![img](https://images2015.cnblogs.com/blog/1089507/201701/1089507-20170126224150269-207487187.jpg)\n\n#### awk 赋值运算符：a+5;等价于： a=a+5;其他同类\n\n```\n`[root@Gin scripts]# awk ``'BEGIN{a=5;a+=5;print a}'``10`\n```\n\n　　\n\n#### awk逻辑运算符：\n\n```\n`[root@Gin scripts]# awk ``'BEGIN{a=1;b=2;print (a>2&&b>1,a=1||b>1)}'``0 1`\n```\n\n　　\n\n判断表达式 a>2&&b>1为真还是为假，后面的表达式同理\n\n#### awk正则运算符：\n\n```\n`[root@Gin scripts]# awk ``'BEGIN{a=\"100testaa\";if(a~/100/) {print \"ok\"}}'``ok`\n```\n\n　　\n\n```\n`[root@Gin scripts]# echo|awk ``'BEGIN{a=\"100testaaa\"}a~/test/{print \"ok\"}'``ok`\n```\n\n　　\n\n \n\n#### 关系运算符：\n\n如： > < 可以作为字符串比较，也可以用作数值比较，关键看操作数如果是字符串就会转换为字符串比较。两个都为数字 才转为数值比较。字符串比较：按照ascii码顺序比较。\n\n```\n`[root@Gin scripts]# awk ``'BEGIN{a=\"11\";if(a>=9){print \"ok\"}}'` `#无输出``[root@Gin scripts]# awk ``'BEGIN{a=11;if(a>=9){print \"ok\"}}'``ok``[root@Gin scripts]# awk ``'BEGIN{a;if(a>=b){print \"ok\"}}'``ok`\n```\n\n　　\n\n#### awk 算术运算符：\n\n说明，所有用作算术运算符进行操作，操作数自动转为数值，所有非数值都变为0。\n\n```\n`[root@Gin scripts]# awk ``'BEGIN{a=\"b\";print a++,++a}'``0 2``[root@Gin scripts]# awk ``'BEGIN{a=\"20b4\";print a++,++a}'``20 22`\n```\n\n　　\n\n这里的a++ , ++a与javascript语言一样：a++是先赋值加++；++a是先++再赋值\n\n#### 三目运算符 ?:\n\n```\n`[root@Gin scripts]# awk ``'BEGIN{a=\"b\";print a==\"b\"?\"ok\":\"err\"}'``ok``[root@Gin scripts]# awk ``'BEGIN{a=\"b\";print a==\"c\"?\"ok\":\"err\"}'``err`\n```\n\n　　\n\n\n\n###  常用 awk 内置变量  \n\n![img](https://images2015.cnblogs.com/blog/1089507/201701/1089507-20170126225731300-1873454323.jpg)\n\n 注：内置变量很多，参阅相关资料\n\n#### 字段分隔符 FS\n\nFS=\"\\t\" 一个或多个 Tab 分隔\n\n```\n`[root@Gin scripts]# cat tab.txt``ww   CC        IDD``[root@Gin scripts]# awk ``'BEGIN{FS=\"\\t+\"}{print $1,$2,$3}'` `tab.txt``ww   CC        IDD`\n```\n\n　　\n\nFS=\"[[:space:]+]\" 一个或多个空白空格，默认的 \n\n```\n`[root@Gin scripts]# cat space.txt``we are    studing awk now!``[root@Gin scripts]# awk -F [[:space:]+] ``'{print $1,$2,$3,$4,$5}'` `space.txt``we are ``[root@Gin scripts]# awk -F [[:space:]+] ``'{print $1,$2}'` `space.txt``we are`\n```\n\n　　\n\nFS=\"[\" \":]+\" 以一个或多个空格或：分隔 \n\n```\n`[root@Gin scripts]# cat hello.txt``root:x:0:0:root:/root:/bin/bash``[root@Gin scripts]# awk -F [``\" \"``:]+ ``'{print $1,$2,$3}'` `hello.txt``root x 0`\n```\n\n　　\n\n字段数量 NF \n\n```\n`[root@Gin scripts]# cat hello.txt``root:x:0:0:root:/root:/bin/bash``bin:x:1:1:bin:/bin:/sbin/nologin:888``[root@Gin scripts]# awk -F ``\":\"` `'NF==8{print $0}'` `hello.txt``bin:x:1:1:bin:/bin:/sbin/nologin:888`\n```\n\n　　\n\n记录数量 NR\n\n```\n`[root@Gin scripts]# ifconfig eth0|awk -F [``\" \"``:]+ ``'NR==2{print $4}'`  `## NR==2也就是取第2行``192.168.17.129`\n```\n\n　　\n\nRS 记录分隔符变量\n将 FS 设置成\"\\n\"告诉 awk 每个字段都占据一行。通过将 RS 设置成\"\"，还会告诉 awk每个地址记录都由空白行分隔。\n\n```\n`[root@Gin scripts]# cat recode.txt``Jimmy the Weasel``100 Pleasant Drive``San Francisco,CA 123456`` ` `Big Tony``200 Incognito Ave.``Suburbia,WA 64890``[root@Gin scripts]# cat awk.txt``#!/bin/awk``BEGIN {``        ``FS=``\"\\n\"``        ``RS=``\"\"``}``{``        ``print $1``\",\"``$2``\",\"``$3``}``[root@Gin scripts]# awk -f awk.txt recode.txt``Jimmy the Weasel,100 Pleasant Drive,San Francisco,CA 123456``Big Tony,200 Incognito Ave.,Suburbia,WA 64890`\n```\n\n　　\n\nOFS 输出字段分隔符 \n\n```\n`[root@Gin scripts]# cat hello.txt``root:x:0:0:root:/root:/bin/bash``bin:x:1:1:bin:/bin:/sbin/nologin:888``[root@Gin scripts]# awk ``'BEGIN{FS=\":\"}{print $1\",\"$2\",\"$3}'` `hello.txt``root,x,0``bin,x,1``[root@Gin scripts]# awk ``'BEGIN{FS=\":\";OFS=\"#\"}{print $1,$2,$3}'` `hello.txt``root#x#0``bin#x#1`\n```\n\n　　\n\nORS 输出记录分隔符 \n\n```\n`[root@Gin scripts]# cat recode.txt``Jimmy the Weasel``100 Pleasant Drive``San Francisco,CA 123456`` ` `Big Tony``200 Incognito Ave.``Suburbia,WA 64890``[root@Gin scripts]# cat awk.txt``#!/bin/awk``BEGIN {``        ``FS=``\"\\n\"``        ``RS=``\"\"``        ``ORS=``\"\\n\\n\"``}``{``        ``print $1``\",\"``$2``\",\"``$3``}``[root@Gin scripts]# awk -f awk.txt recode.txt``Jimmy the Weasel,100 Pleasant Drive,San Francisco,CA 123456`` ` `Big Tony,200 Incognito Ave.,Suburbia,WA 64890`\n```\n\n　　\n\n\n\n###  awk 正则  \n\n![img](https://images2015.cnblogs.com/blog/1089507/201701/1089507-20170126232437800-1355193233.jpg)\n\n####  正则应用\n\n规则表达式\n\nawk '/REG/{action} ' file,/REG/为正则表达式，可以将$0 中，满足条件的记录送入到：action 进行处理\n\n```\n`[root@Gin scripts]# awk ``'/root/{print $0}'` `passwd ##匹配所有包含root的行``root:x:0:0:root:/root:/bin/bash``operator``:x:11:0:``operator``:/root:/sbin/nologin`` ` `[root@Gin scripts]# awk -F: ``'$5~/root/{print $0}'` `passwd  ## 以分号作为分隔符，匹配第5个字段是root的行``root:x:0:0:root:/root:/bin/bash`` ` `[root@Gin scripts]# ifconfig eth0|awk ``'BEGIN{FS=\"[[:space:]:]+\"} NR==2{print $4}'``192.168.17.129`\n```\n\n　　\n\n布尔表达式\nawk '布尔表达式{action}' file 仅当对前面的布尔表达式求值为真时， awk 才执行代码块。\n\n```\n`[root@Gin scripts]# awk -F: ``'$1==\"root\"{print $0}'` `passwd``root:x:0:0:root:/root:/bin/bash``[root@Gin scripts]# awk -F: ``'($1==\"root\")&&($5==\"root\") {print $0}'` `passwd``root:x:0:0:root:/root:/bin/bash`\n```\n\n　　\n\n\n\n###  awk 的 if、循环和数组  \n\n#### 条件语句\n\nawk 提供了非常好的类似于 C 语言的 if 语句。\n\n```\n`{``        ``if` `($1==``\"foo\"``){``                ``if``($2==``\"foo\"``){``                        ``print ``\"uno\"``                ``}``else``{``                        ``print ``\"one\"``                ``}``        ``}elseif($1==``\"bar\"``){``                ``print ``\"two\"``        ``}``else``{``                ``print ``\"three\"``        ``}``}`\n```\n\n　　\n\n使用 if 语句还可以将代码： \n\n```\n`! /matchme/ { print $1 $3 $4 }`\n```\n\n　　\n\n转换成：\n\n```\n`{``　　``if` `( $0 !~ /matchme/ ) {``　　　　print $1 $3 $4``　　}``}`\n```\n\n　　\n\n#### 循环结构\n\n我们已经看到了 awk 的 while 循环结构，它等同于相应的 C 语言 while 循环。 awk 还有\"do...while\"循环，它在代码块结尾处对条件求值，而不像标准 while 循环那样在开始处求值。\n\n它类似于其它语言中的\"repeat...until\"循环。以下是一个示例：\ndo...while 示例\n\n```\n`{``    ``count=1do {``        ``print ``\"I get printed at least once no matter what\"``    ``} ``while` `( count !=1 )``}`\n```\n\n　　\n\n与一般的 while 循环不同，由于在代码块之后对条件求值， \"do...while\"循环永远都至少执行一次。换句话说，当第一次遇到普通 while 循环时，如果条件为假，将永远不执行该循环。\n\n#### for 循环\n\nawk 允许创建 for 循环，它就象 while 循环，也等同于 C 语言的 for 循环：\n\n```\n`for` `( initial assignment; comparison; increment ) {``    ``code block``}`\n```\n\n　　\n\n以下是一个简短示例： \n\n```\n`for` `( x=1;x<=4;x++ ) {``    ``print ``\"iteration\"``, x``}`\n```\n\n　　\n\n此段代码将打印： \n\n```\n`iteration1``iteration2``iteration3``iteration4`\n```\n\n　　\n\n#### break 和 continue\n\n此外，如同 C 语言一样， awk 提供了 break 和 continue 语句。使用这些语句可以更好地控制 awk 的循环结构。以下是迫切需要 break 语句的代码片断：\n\n```\n`while` `死循环``while` `(1) {``print ``\"forever and ever...\"``}``while` `死循环 1 永远代表是真，这个 ``while` `循环将永远运行下去。`\n```\n\n　　\n\n以下是一个只执行十次的循环： \n\n```\n`#break 语句示例``x=1``while``(1) {``　　print ``\"iteration\"``, x``　　``if` `( x==10 ) {``　　　　``break``　　}``　　x++``}`\n```\n\n　　\n\n这里， break 语句用于“逃出”最深层的循环。 \"break\"使循环立即终止，并继续执行循环代码块后面的语句。\ncontinue 语句补充了 break，其作用如下：\n\n```\n`x=1while (1) {``        ``if` `( x==4 ) {``        ``x++``        ``continue``    ``}``    ``print ``\"iteration\"``, x``    ``if` `( x>20 ) {``        ``break``    ``}``    ``x++``}`\n```\n\n　　\n\n这段代码打印\"iteration1\"到\"iteration21\"， \"iteration4\"除外。如果迭代等于 4，则增加 x并调用 continue 语句，该语句立即使 awk 开始执行下一个循环迭代，而不执行代码块的其余部分。如同 break 一样，\n\ncontinue 语句适合各种 awk 迭代循环。在 for 循环主体中使用时， continue 将使循环控制变量自动增加。以下是一个等价循环：\n\n```\n`for` `( x=1;x<=21;x++ ) {``    ``if` `( x==4 ) {``        ``continue``    ``}``    ``print ``\"iteration\"``, x``}`\n```\n\n　　\n\n在while 循环中时，在调用 continue 之前没有必要增加 x，因为 for 循环会自动增加 x。 \n\n#### 数组  \n\nAWK 中的数组都是关联数组,数字索引也会转变为字符串索引 \n\n```\n`{``    ``cities[1]=”beijing”``    ``cities[2]=”shanghai”``    ``cities[“three”]=”guangzhou”``    ``for``( c ``in` `cities) {``        ``print cities[c]``    ``}``    ``print cities[1]``    ``print cities[“1”]``    ``print cities[“three”]``}`\n```\n\n　　\n\nfor…in 输出，因为数组是关联数组，默认是无序的。所以通过 for…in 得到是无序的数组。如果需要得到有序数组，需要通过下标获得。\n\n#### 数组的典型应用\n\n用 awk 中查看服务器连接状态并汇总 \n\n```\n`netstat -an|awk ``'/^tcp/{++s[$NF]}END{for(a in s)print a,s[a]}'``ESTABLISHED 1``LISTEN 20`\n```\n\n　　\n\n统计 web 日志访问流量，要求输出访问次数，请求页面或图片，每个请求的总大小，总访问流量的大小汇总\n\n```\n`awk '{a[$7]+=$10;++b[$7];total+=$10}END{``for``(x ``in` `a)print b[x],x,a[x]|``\"sort -rn -k1\"``;print``\"total size is :\"``total}' /app/log/access_log``total size ``is` `:172230``21 /icons/poweredby.png 83076``14 / 70546``8 /icons/apache_pb.gif 18608``a[$7]+=$10 表示以第 7 列为下标的数组（ $10 列为$7 列的大小），把他们大小累加得到``$7 每次访问的大小，后面的 ``for` `循环有个取巧的地方， a 和 b 数组的下标相同，所以一``条 ``for` `语句足矣`\n```\n\n　　\n\n\n\n### 常用字符串函数 \n\n![img](https://images2015.cnblogs.com/blog/1089507/201701/1089507-20170126235509019-257728577.jpg)\n\n![img](https://images2015.cnblogs.com/blog/1089507/201701/1089507-20170126235518706-915272948.jpg)\n\n#### 字符串函数的应用  \n\n替换 \n\n```\n`awk ``'BEGIN{info=\"this is a test2010test!\";gsub(/[0-9]+/,\"!\",info);print info}'` `this` `is` `a test!test!``在 info 中查找满足正则表达式， /[0-9]+/ 用”!”替换，并且替换后的值，赋值给 info 未``给 info 值，默认是$0`\n```\n\n　　\n\n查找 \n\n```\n`awk ``'BEGIN{info=\"this is a test2010test!\";print index(info,\"test\")?\"ok\":\"no found\";}'``ok #未找到，返回 0`\n```\n\n　　\n\n匹配查找 \n\n```\n`awk ``'BEGIN{info=\"this is a test2010test!\";print match(info,/[0-9]+/)?\"ok\":\"no found\";}'``ok #如果查找到数字则匹配成功返回 ok，否则失败，返回未找到`\n```\n\n　　\n\n截取 \n\n```\n`awk ``'BEGIN{info=\"this is a test2010test!\";print substr(info,4,10);}'``s ``is` `a tes #从第 4 个 字符开始，截取 10 个长度字符串`\n```\n\n　　\n\n分割 \n\n```\n`awk ``'BEGIN{info=\"this is a test\";split(info,tA,\" \");print length(tA);for(k in tA){print k,tA[k];}}'` `4``4 test 1 ``this` `2 ``is` `3 a``#分割 info,动态创建数组 tA,awk for …in 循环，是一个无序的循环。 并不是从数组下标``1…n 开始`\n```","content":"<h2 id=\"一：awk简介\">一：awk简介<a href=\"posts/Linux-awk命令#一：awk简介\"></a></h2><p>​        awk其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。实际上 AWK 的确拥有自己的语言： AWK 程序设计语言 ， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。</p>\n<p>​       awk 是一种很棒的语言，它适合文本处理和报表生成，其语法较为常见，借鉴了某些语言的一些精华，如 C 语言等。在 linux 系统日常处理工作中，发挥很重要的作用，掌握了 awk将会使你的工作变的高大上。 awk 是三剑客的老大，利剑出鞘，必会不同凡响。</p>\n<a id=\"more\"></a>\n\n<p><a href=\"https://www.cnblogs.com/yaohong/p/9163471.html#_labelTop\" target=\"_blank\" rel=\"noopener\">回到顶部</a></p>\n<h2 id=\"二：使用方法\"><strong>二：使用方法</strong><a href=\"posts/Linux-awk命令#二：使用方法\"></a></h2><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`awk ``<span class=\"string\">'&#123;pattern + action&#125;'</span>` `&#123;filenames&#125;`</span><br></pre></td></tr></table></div></figure>\n\n<p>​        尽管操作可能会很复杂，但语法总是这样，其中 pattern 表示 AWK 在数据中查找的内容，而 action 是在找到匹配内容时所执行的一系列命令。花括号（{}）不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组。 pattern就是要表示的正则表达式，用斜杠括起来。</p>\n<p>​        awk语言的最基本功能是在文件或者字符串中基于指定规则浏览和抽取信息，awk抽取信息后，才能进行其他文本操作。完整的awk脚本通常用来格式化文本文件中的信息。</p>\n<p>通常，awk是以文件的一行为处理单位的。awk每接收文件的一行，然后执行相应的命令，来处理文本。</p>\n<p><a href=\"https://www.cnblogs.com/yaohong/p/9163471.html#_labelTop\" target=\"_blank\" rel=\"noopener\">回到顶部</a></p>\n<h2 id=\"三：awk-的原理\">三：awk 的原理<a href=\"posts/Linux-awk命令#三：awk-的原理\"></a></h2><p>通过一个简短的命令，我们来了解其工作原理。 </p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`[root@Gin scripts]# awk ``<span class=\"string\">'&#123;print $0&#125;'</span>` `/etc/passwd``root:x:<span class=\"number\">0</span>:<span class=\"number\">0</span>:root:/root:/bin/bash``bin:x:<span class=\"number\">1</span>:<span class=\"number\">1</span>:bin:/bin:/sbin/nologin``.....................................................`` ` `[root@Gin scripts]# echo hhh|awk ``<span class=\"string\">'&#123;print \"hello,world\"&#125;'</span>``hello,world`` ` `[root@Gin scripts]# awk ``<span class=\"string\">'&#123;print \"hiya\"&#125;'</span>` `/etc/passwd``hiya``hiya``hiya``hiya``...............................................`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<p>​       你将会见到/etc/passwd 文件的内容出现在眼前。现在，解释 awk 做了些什么。调用 awk时，我们指定/etc/passwd 作为输入文件。执行 awk 时，它依次对/etc/passwd 中的每一行执行 print 命令。</p>\n<p>​       所有输出都发送到 stdout，所得到的结果与执行 cat /etc/passwd 完全相同。<br>​       现在，解释{ print }代码块。在 awk 中，花括号用于将几块代码组合到一起，这一点类似于 C 语言。在代码块中只有一条 print 命令。在 awk 中，如果只出现 print 命令，那么将打印当前行的全部内容。<br><strong>再次说明， awk 对输入文件中的每一行都执行这个脚本。</strong></p>\n<p><img src=\"https://images2015.cnblogs.com/blog/1089507/201701/1089507-20170126222420597-662074402.jpg\" alt=\"img\" class=\"article-img\"></p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`$ awk -F``<span class=\"string\">\":\"</span>` `<span class=\"string\">'&#123; print $1 &#125;'</span>` `/etc/passwd``$ awk -F``<span class=\"string\">\":\"</span>` `<span class=\"string\">'&#123; print $1 $3 &#125;'</span>` `/etc/passwd``$ awk -F``<span class=\"string\">\":\"</span>` `<span class=\"string\">'&#123; print $1 \" \" $3 &#125;'</span>` `/etc/passwd``$ awk -F``<span class=\"string\">\":\"</span>` `<span class=\"string\">'&#123; print \"username: \" $1 \"\\t\\tuid:\" $3\" &#125;'</span>` `/etc/passwd`</span><br></pre></td></tr></table></div></figure>\n\n<p>   -F参数：指定分隔符，可指定一个或多个</p>\n<p>   print 后面做字符串的拼接</p>\n<p><strong>下面通过几实例来了解下awk的工作原理：</strong></p>\n<h4 id=\"实例一：只查看test-txt文件（100行）内第20到第30行的内容（企业面试）\">实例一：只查看test.txt文件（100行）内第20到第30行的内容（企业面试）<a href=\"posts/Linux-awk命令#实例一：只查看test-txt文件（100行）内第20到第30行的内容（企业面试）\"></a></h4><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`#print $a取列#NR取行数[root@Gin scripts]# awk <span class=\"string\">'&#123;if(NR&gt;=20 &amp;&amp; NR&lt;=30) print $1&#125;'</span> test.txt  ``<span class=\"number\">20</span>``<span class=\"number\">21</span>``<span class=\"number\">22</span>``<span class=\"number\">23</span>``<span class=\"number\">24</span>``<span class=\"number\">25</span>``<span class=\"number\">26</span>``<span class=\"number\">27</span>``<span class=\"number\">28</span>``<span class=\"number\">29</span>``<span class=\"number\">30</span>`</span><br></pre></td></tr></table></div></figure>\n\n\n\n<h4 id=\"实例二：已知test-txt文件内容为：\">实例二：已知test.txt文件内容为：<a href=\"posts/Linux-awk命令#实例二：已知test-txt文件内容为：\"></a></h4><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`[root@Gin scripts]# cat test.txt``I am Poe,my qq ``is` `<span class=\"number\">33794712</span>`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<p>请从该文件中过滤出’Poe’字符串与33794712，最后输出的结果为：Poe 33794712</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`[root@Gin scripts]# awk -F ``<span class=\"string\">'[ ,]+'</span>` `<span class=\"string\">'&#123;print $3\" \"$7&#125;'</span>` `test.txt``Poe <span class=\"number\">33794712</span>`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<h3 id=\"BEGIN-和-END-模块\">BEGIN 和 END 模块<a href=\"posts/Linux-awk命令#BEGIN-和-END-模块\"></a></h3><p>通常，对于每个输入行， awk 都会执行每个脚本代码块一次。然而，在许多编程情况中，可能需要在 awk 开始处理输入文件中的文本之前执行初始化代码。对于这种情况， awk 允许您定义一个 BEGIN 块。</p>\n<p>因为 awk 在开始处理输入文件之前会执行 BEGIN 块，因此它是初始化 FS（字段分隔符）变量、打印页眉或初始化其它在程序中以后会引用的全局变量的极佳位置。<br>awk 还提供了另一个特殊块，叫作 END 块。 awk 在处理了输入文件中的所有行之后执行这个块。通常， END 块用于执行最终计算或打印应该出现在输出流结尾的摘要信息。</p>\n<h4 id=\"实例一：统计-etc-passwd的账户人数\">实例一：统计/etc/passwd的账户人数<a href=\"posts/Linux-awk命令#实例一：统计-etc-passwd的账户人数\"></a></h4><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`[root@Gin scripts]# awk ``<span class=\"string\">'&#123;count++;print $0;&#125; END&#123;print \"user count is \",count&#125;'</span>` `passwd``root:x:<span class=\"number\">0</span>:<span class=\"number\">0</span>:root:/root:/bin/bash``..............................................``user count ``is`  `<span class=\"number\">27</span>`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<p>count是自定义变量。之前的action{}里都是只有一个print,其实print只是一个语句，而action{}可以有多个语句，以;号隔开。这里没有初始化count，虽然默认是0，但是妥当的做法还是初始化为0:</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`[root@Gin scripts]# awk ``<span class=\"string\">'BEGIN &#123;count=0;print \"[start] user count is \",count&#125; &#123;count=count+1;print $0&#125; END&#123;print \"[end] user count is \",count&#125;'</span>` `passwd``[start] user count ``is`  `<span class=\"number\">0</span>``root:x:<span class=\"number\">0</span>:<span class=\"number\">0</span>:root:/root:/bin/bash``...................................................................``[end] user count ``is`  `<span class=\"number\">27</span>`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<h4 id=\"实例二：统计某个文件夹下的文件占用的字节数\">实例二：统计某个文件夹下的文件占用的字节数<a href=\"posts/Linux-awk命令#实例二：统计某个文件夹下的文件占用的字节数\"></a></h4><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`[root@Gin scripts]# ll |awk ``<span class=\"string\">'BEGIN &#123;size=0;&#125; &#123;size=size+$5;&#125; END&#123;print \"[end]size is \",size&#125;'</span>``[end]size ``is`  `<span class=\"number\">1489</span>`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<p>如果以M为单位显示:</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`[root@Gin scripts]# ll |awk ``<span class=\"string\">'BEGIN&#123;size=0;&#125; &#123;size=size+$5;&#125; END&#123;print \"[end]size is \",size/1024/1024,\"M\"&#125;'</span>`  `[end]size ``is`  `<span class=\"number\">0.00142002</span> M`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<h3 id=\"awk运算符\">awk运算符<a href=\"posts/Linux-awk命令#awk运算符\"></a></h3><p><img src=\"https://images2015.cnblogs.com/blog/1089507/201701/1089507-20170126224150269-207487187.jpg\" alt=\"img\" class=\"article-img\"></p>\n<h4 id=\"awk-赋值运算符：a-5-等价于：-a-a-5-其他同类\">awk 赋值运算符：a+5;等价于： a=a+5;其他同类<a href=\"posts/Linux-awk命令#awk-赋值运算符：a-5-等价于：-a-a-5-其他同类\"></a></h4><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`[root@Gin scripts]# awk ``<span class=\"string\">'BEGIN&#123;a=5;a+=5;print a&#125;'</span>``<span class=\"number\">10</span>`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<h4 id=\"awk逻辑运算符：\">awk逻辑运算符：<a href=\"posts/Linux-awk命令#awk逻辑运算符：\"></a></h4><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`[root@Gin scripts]# awk ``<span class=\"string\">'BEGIN&#123;a=1;b=2;print (a&gt;2&amp;&amp;b&gt;1,a=1||b&gt;1)&#125;'</span>``<span class=\"number\">0</span> <span class=\"number\">1</span>`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<p>判断表达式 a&gt;2&amp;&amp;b&gt;1为真还是为假，后面的表达式同理</p>\n<h4 id=\"awk正则运算符：\">awk正则运算符：<a href=\"posts/Linux-awk命令#awk正则运算符：\"></a></h4><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`[root@Gin scripts]# awk ``<span class=\"string\">'BEGIN&#123;a=\"100testaa\";if(a~/100/) &#123;print \"ok\"&#125;&#125;'</span>``ok`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`[root@Gin scripts]# echo|awk ``<span class=\"string\">'BEGIN&#123;a=\"100testaaa\"&#125;a~/test/&#123;print \"ok\"&#125;'</span>``ok`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<h4 id=\"关系运算符：\">关系运算符：<a href=\"posts/Linux-awk命令#关系运算符：\"></a></h4><p>如： &gt; &lt; 可以作为字符串比较，也可以用作数值比较，关键看操作数如果是字符串就会转换为字符串比较。两个都为数字 才转为数值比较。字符串比较：按照ascii码顺序比较。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`[root@Gin scripts]# awk ``<span class=\"string\">'BEGIN&#123;a=\"11\";if(a&gt;=9)&#123;print \"ok\"&#125;&#125;'</span>` `#无输出``[root@Gin scripts]# awk ``<span class=\"string\">'BEGIN&#123;a=11;if(a&gt;=9)&#123;print \"ok\"&#125;&#125;'</span>``ok``[root@Gin scripts]# awk ``<span class=\"string\">'BEGIN&#123;a;if(a&gt;=b)&#123;print \"ok\"&#125;&#125;'</span>``ok`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<h4 id=\"awk-算术运算符：\">awk 算术运算符：<a href=\"posts/Linux-awk命令#awk-算术运算符：\"></a></h4><p>说明，所有用作算术运算符进行操作，操作数自动转为数值，所有非数值都变为0。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`[root@Gin scripts]# awk ``<span class=\"string\">'BEGIN&#123;a=\"b\";print a++,++a&#125;'</span>``<span class=\"number\">0</span> <span class=\"number\">2</span>``[root@Gin scripts]# awk ``<span class=\"string\">'BEGIN&#123;a=\"20b4\";print a++,++a&#125;'</span>``<span class=\"number\">20</span> <span class=\"number\">22</span>`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<p>这里的a++ , ++a与javascript语言一样：a++是先赋值加++；++a是先++再赋值</p>\n<h4 id=\"三目运算符\">三目运算符 ?:<a href=\"posts/Linux-awk命令#三目运算符\"></a></h4><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`[root@Gin scripts]# awk ``<span class=\"string\">'BEGIN&#123;a=\"b\";print a==\"b\"?\"ok\":\"err\"&#125;'</span>``ok``[root@Gin scripts]# awk ``<span class=\"string\">'BEGIN&#123;a=\"b\";print a==\"c\"?\"ok\":\"err\"&#125;'</span>``err`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<h3 id=\"常用-awk-内置变量\">常用 awk 内置变量<a href=\"posts/Linux-awk命令#常用-awk-内置变量\"></a></h3><p><img src=\"https://images2015.cnblogs.com/blog/1089507/201701/1089507-20170126225731300-1873454323.jpg\" alt=\"img\" class=\"article-img\"></p>\n<p> 注：内置变量很多，参阅相关资料</p>\n<h4 id=\"字段分隔符-FS\">字段分隔符 FS<a href=\"posts/Linux-awk命令#字段分隔符-FS\"></a></h4><p>FS=”\\t” 一个或多个 Tab 分隔</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`[root@Gin scripts]# cat tab.txt``ww   CC        IDD``[root@Gin scripts]# awk ``<span class=\"string\">'BEGIN&#123;FS=\"\\t+\"&#125;&#123;print $1,$2,$3&#125;'</span>` `tab.txt``ww   CC        IDD`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<p>FS=”[[:space:]+]” 一个或多个空白空格，默认的 </p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`[root@Gin scripts]# cat space.txt``we are    studing awk now!``[root@Gin scripts]# awk -F [[:space:]+] ``<span class=\"string\">'&#123;print $1,$2,$3,$4,$5&#125;'</span>` `space.txt``we are ``[root@Gin scripts]# awk -F [[:space:]+] ``<span class=\"string\">'&#123;print $1,$2&#125;'</span>` `space.txt``we are`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<p>FS=”[“ “:]+” 以一个或多个空格或：分隔 </p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`[root@Gin scripts]# cat hello.txt``root:x:<span class=\"number\">0</span>:<span class=\"number\">0</span>:root:/root:/bin/bash``[root@Gin scripts]# awk -F [``<span class=\"string\">\" \"</span>``:]+ ``<span class=\"string\">'&#123;print $1,$2,$3&#125;'</span>` `hello.txt``root x <span class=\"number\">0</span>`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<p>字段数量 NF </p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`[root@Gin scripts]# cat hello.txt``root:x:<span class=\"number\">0</span>:<span class=\"number\">0</span>:root:/root:/bin/bash``bin:x:<span class=\"number\">1</span>:<span class=\"number\">1</span>:bin:/bin:/sbin/nologin:<span class=\"number\">888</span>``[root@Gin scripts]# awk -F ``<span class=\"string\">\":\"</span>` `<span class=\"string\">'NF==8&#123;print $0&#125;'</span>` `hello.txt``bin:x:<span class=\"number\">1</span>:<span class=\"number\">1</span>:bin:/bin:/sbin/nologin:<span class=\"number\">888</span>`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<p>记录数量 NR</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`[root@Gin scripts]# ifconfig eth0|awk -F [``<span class=\"string\">\" \"</span>``:]+ ``<span class=\"string\">'NR==2&#123;print $4&#125;'</span>`  `## NR==<span class=\"number\">2</span>也就是取第<span class=\"number\">2</span>行``<span class=\"number\">192.168</span><span class=\"number\">.17</span><span class=\"number\">.129</span>`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<p>RS 记录分隔符变量<br>将 FS 设置成”\\n”告诉 awk 每个字段都占据一行。通过将 RS 设置成””，还会告诉 awk每个地址记录都由空白行分隔。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`[root@Gin scripts]# cat recode.txt``Jimmy the Weasel``<span class=\"number\">100</span> Pleasant Drive``San Francisco,CA <span class=\"number\">123456</span>`` ` `Big Tony``<span class=\"number\">200</span> Incognito Ave.``Suburbia,WA <span class=\"number\">64890</span>``[root@Gin scripts]# cat awk.txt``#!/bin/awk``BEGIN &#123;``        ``FS=``<span class=\"string\">\"\\n\"</span>``        ``RS=``<span class=\"string\">\"\"</span>``&#125;``&#123;``        ``print $<span class=\"number\">1</span>``<span class=\"string\">\",\"</span>``$<span class=\"number\">2</span>``<span class=\"string\">\",\"</span>``$<span class=\"number\">3</span>``&#125;``[root@Gin scripts]# awk -f awk.txt recode.txt``Jimmy the Weasel,<span class=\"number\">100</span> Pleasant Drive,San Francisco,CA <span class=\"number\">123456</span>``Big Tony,<span class=\"number\">200</span> Incognito Ave.,Suburbia,WA <span class=\"number\">64890</span>`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<p>OFS 输出字段分隔符 </p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`[root@Gin scripts]# cat hello.txt``root:x:<span class=\"number\">0</span>:<span class=\"number\">0</span>:root:/root:/bin/bash``bin:x:<span class=\"number\">1</span>:<span class=\"number\">1</span>:bin:/bin:/sbin/nologin:<span class=\"number\">888</span>``[root@Gin scripts]# awk ``<span class=\"string\">'BEGIN&#123;FS=\":\"&#125;&#123;print $1\",\"$2\",\"$3&#125;'</span>` `hello.txt``root,x,<span class=\"number\">0</span>``bin,x,<span class=\"number\">1</span>``[root@Gin scripts]# awk ``<span class=\"string\">'BEGIN&#123;FS=\":\";OFS=\"#\"&#125;&#123;print $1,$2,$3&#125;'</span>` `hello.txt``root#x#<span class=\"number\">0</span>``bin#x#<span class=\"number\">1</span>`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<p>ORS 输出记录分隔符 </p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`[root@Gin scripts]# cat recode.txt``Jimmy the Weasel``<span class=\"number\">100</span> Pleasant Drive``San Francisco,CA <span class=\"number\">123456</span>`` ` `Big Tony``<span class=\"number\">200</span> Incognito Ave.``Suburbia,WA <span class=\"number\">64890</span>``[root@Gin scripts]# cat awk.txt``#!/bin/awk``BEGIN &#123;``        ``FS=``<span class=\"string\">\"\\n\"</span>``        ``RS=``<span class=\"string\">\"\"</span>``        ``ORS=``<span class=\"string\">\"\\n\\n\"</span>``&#125;``&#123;``        ``print $<span class=\"number\">1</span>``<span class=\"string\">\",\"</span>``$<span class=\"number\">2</span>``<span class=\"string\">\",\"</span>``$<span class=\"number\">3</span>``&#125;``[root@Gin scripts]# awk -f awk.txt recode.txt``Jimmy the Weasel,<span class=\"number\">100</span> Pleasant Drive,San Francisco,CA <span class=\"number\">123456</span>`` ` `Big Tony,<span class=\"number\">200</span> Incognito Ave.,Suburbia,WA <span class=\"number\">64890</span>`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<h3 id=\"awk-正则\">awk 正则<a href=\"posts/Linux-awk命令#awk-正则\"></a></h3><p><img src=\"https://images2015.cnblogs.com/blog/1089507/201701/1089507-20170126232437800-1355193233.jpg\" alt=\"img\" class=\"article-img\"></p>\n<h4 id=\"正则应用\">正则应用<a href=\"posts/Linux-awk命令#正则应用\"></a></h4><p>规则表达式</p>\n<p>awk ‘/REG/{action} ‘ file,/REG/为正则表达式，可以将$0 中，满足条件的记录送入到：action 进行处理</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`[root@Gin scripts]# awk ``<span class=\"string\">'/root/&#123;print $0&#125;'</span>` `passwd ##匹配所有包含root的行``root:x:<span class=\"number\">0</span>:<span class=\"number\">0</span>:root:/root:/bin/bash``operator``:x:<span class=\"number\">11</span>:<span class=\"number\">0</span>:``operator``:/root:/sbin/nologin`` ` `[root@Gin scripts]# awk -F: ``<span class=\"string\">'$5~/root/&#123;print $0&#125;'</span>` `passwd  ## 以分号作为分隔符，匹配第<span class=\"number\">5</span>个字段是root的行``root:x:<span class=\"number\">0</span>:<span class=\"number\">0</span>:root:/root:/bin/bash`` ` `[root@Gin scripts]# ifconfig eth0|awk ``<span class=\"string\">'BEGIN&#123;FS=\"[[:space:]:]+\"&#125; NR==2&#123;print $4&#125;'</span>``<span class=\"number\">192.168</span><span class=\"number\">.17</span><span class=\"number\">.129</span>`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<p>布尔表达式<br>awk ‘布尔表达式{action}’ file 仅当对前面的布尔表达式求值为真时， awk 才执行代码块。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`[root@Gin scripts]# awk -F: ``<span class=\"string\">'$1==\"root\"&#123;print $0&#125;'</span>` `passwd``root:x:<span class=\"number\">0</span>:<span class=\"number\">0</span>:root:/root:/bin/bash``[root@Gin scripts]# awk -F: ``<span class=\"string\">'($1==\"root\")&amp;&amp;($5==\"root\") &#123;print $0&#125;'</span>` `passwd``root:x:<span class=\"number\">0</span>:<span class=\"number\">0</span>:root:/root:/bin/bash`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<h3 id=\"awk-的-if、循环和数组\">awk 的 if、循环和数组<a href=\"posts/Linux-awk命令#awk-的-if、循环和数组\"></a></h3><h4 id=\"条件语句\">条件语句<a href=\"posts/Linux-awk命令#条件语句\"></a></h4><p>awk 提供了非常好的类似于 C 语言的 if 语句。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`&#123;``        ``<span class=\"keyword\">if</span>` `($<span class=\"number\">1</span>==``<span class=\"string\">\"foo\"</span>``)&#123;``                ``<span class=\"keyword\">if</span>``($<span class=\"number\">2</span>==``<span class=\"string\">\"foo\"</span>``)&#123;``                        ``print ``<span class=\"string\">\"uno\"</span>``                ``&#125;``else``&#123;``                        ``print ``<span class=\"string\">\"one\"</span>``                ``&#125;``        ``&#125;elseif($<span class=\"number\">1</span>==``<span class=\"string\">\"bar\"</span>``)&#123;``                ``print ``<span class=\"string\">\"two\"</span>``        ``&#125;``else``&#123;``                ``print ``<span class=\"string\">\"three\"</span>``        ``&#125;``&#125;`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<p>使用 if 语句还可以将代码： </p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`! /matchme/ &#123; <span class=\"builtin-name\">print</span> <span class=\"variable\">$1</span> <span class=\"variable\">$3</span> <span class=\"variable\">$4</span> &#125;`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<p>转换成：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`&#123;``　　``<span class=\"keyword\">if</span>` `( $<span class=\"number\">0</span> !~ /matchme/ ) &#123;``　　　　print $<span class=\"number\">1</span> $<span class=\"number\">3</span> $<span class=\"number\">4</span>``　　&#125;``&#125;`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<h4 id=\"循环结构\">循环结构<a href=\"posts/Linux-awk命令#循环结构\"></a></h4><p>我们已经看到了 awk 的 while 循环结构，它等同于相应的 C 语言 while 循环。 awk 还有”do…while”循环，它在代码块结尾处对条件求值，而不像标准 while 循环那样在开始处求值。</p>\n<p>它类似于其它语言中的”repeat…until”循环。以下是一个示例：<br>do…while 示例</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`&#123;``    ``count=<span class=\"number\">1</span>do &#123;``        ``print ``<span class=\"string\">\"I get printed at least once no matter what\"</span>``    ``&#125; ``while` `( count !=<span class=\"number\">1</span> )``&#125;`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<p>与一般的 while 循环不同，由于在代码块之后对条件求值， “do…while”循环永远都至少执行一次。换句话说，当第一次遇到普通 while 循环时，如果条件为假，将永远不执行该循环。</p>\n<h4 id=\"for-循环\">for 循环<a href=\"posts/Linux-awk命令#for-循环\"></a></h4><p>awk 允许创建 for 循环，它就象 while 循环，也等同于 C 语言的 for 循环：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`for` `( initial assignment; comparison; increment ) &#123;``    ``<span class=\"keyword\">code</span> block``&#125;`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<p>以下是一个简短示例： </p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`for` `( x=<span class=\"number\">1</span>;x&lt;=<span class=\"number\">4</span>;x++ ) &#123;``    ``print ``<span class=\"string\">\"iteration\"</span>``, x``&#125;`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<p>此段代码将打印： </p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`iteration1``iteration2``iteration3``iteration4`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<h4 id=\"break-和-continue\">break 和 continue<a href=\"posts/Linux-awk命令#break-和-continue\"></a></h4><p>此外，如同 C 语言一样， awk 提供了 break 和 continue 语句。使用这些语句可以更好地控制 awk 的循环结构。以下是迫切需要 break 语句的代码片断：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`while` `死循环``while` `(<span class=\"number\">1</span>) &#123;``print ``<span class=\"string\">\"forever and ever...\"</span>``&#125;``while` `死循环 <span class=\"number\">1</span> 永远代表是真，这个 ``while` `循环将永远运行下去。`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<p>以下是一个只执行十次的循环： </p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`#break 语句示例``x=<span class=\"number\">1</span>``while``(<span class=\"number\">1</span>) &#123;``　　print ``<span class=\"string\">\"iteration\"</span>``, x``　　``<span class=\"keyword\">if</span>` `( x==<span class=\"number\">10</span> ) &#123;``　　　　``break``　　&#125;``　　x++``&#125;`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<p>这里， break 语句用于“逃出”最深层的循环。 “break”使循环立即终止，并继续执行循环代码块后面的语句。<br>continue 语句补充了 break，其作用如下：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`x=<span class=\"number\">1</span>while (<span class=\"number\">1</span>) &#123;``        ``<span class=\"keyword\">if</span>` `( x==<span class=\"number\">4</span> ) &#123;``        ``x++``        ``continue``    ``&#125;``    ``print ``<span class=\"string\">\"iteration\"</span>``, x``    ``<span class=\"keyword\">if</span>` `( x&gt;<span class=\"number\">20</span> ) &#123;``        ``break``    ``&#125;``    ``x++``&#125;`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<p>这段代码打印”iteration1”到”iteration21”， “iteration4”除外。如果迭代等于 4，则增加 x并调用 continue 语句，该语句立即使 awk 开始执行下一个循环迭代，而不执行代码块的其余部分。如同 break 一样，</p>\n<p>continue 语句适合各种 awk 迭代循环。在 for 循环主体中使用时， continue 将使循环控制变量自动增加。以下是一个等价循环：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`for` `( x=<span class=\"number\">1</span>;x&lt;=<span class=\"number\">21</span>;x++ ) &#123;``    ``<span class=\"keyword\">if</span>` `( x==<span class=\"number\">4</span> ) &#123;``        ``continue``    ``&#125;``    ``print ``<span class=\"string\">\"iteration\"</span>``, x``&#125;`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<p>在while 循环中时，在调用 continue 之前没有必要增加 x，因为 for 循环会自动增加 x。 </p>\n<h4 id=\"数组\">数组<a href=\"posts/Linux-awk命令#数组\"></a></h4><p>AWK 中的数组都是关联数组,数字索引也会转变为字符串索引 </p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`&#123;``    ``cities[<span class=\"number\">1</span>]=”beijing”``    ``cities[<span class=\"number\">2</span>]=”shanghai”``    ``cities[“three”]=”guangzhou”``    ``for``( c ``<span class=\"keyword\">in</span>` `cities) &#123;``        ``print cities[c]``    ``&#125;``    ``print cities[<span class=\"number\">1</span>]``    ``print cities[“<span class=\"number\">1</span>”]``    ``print cities[“three”]``&#125;`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<p>for…in 输出，因为数组是关联数组，默认是无序的。所以通过 for…in 得到是无序的数组。如果需要得到有序数组，需要通过下标获得。</p>\n<h4 id=\"数组的典型应用\">数组的典型应用<a href=\"posts/Linux-awk命令#数组的典型应用\"></a></h4><p>用 awk 中查看服务器连接状态并汇总 </p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`netstat -an|awk ``<span class=\"string\">'/^tcp/&#123;++s[$NF]&#125;END&#123;for(a in s)print a,s[a]&#125;'</span>``ESTABLISHED <span class=\"number\">1</span>``LISTEN <span class=\"number\">20</span>`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<p>统计 web 日志访问流量，要求输出访问次数，请求页面或图片，每个请求的总大小，总访问流量的大小汇总</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`awk '&#123;a[$7]+=$10;++b[$7];total+=$10&#125;<span class=\"keyword\">END</span>&#123;<span class=\"symbol\">``</span><span class=\"keyword\">for</span><span class=\"symbol\">``</span>(x <span class=\"symbol\">``</span><span class=\"keyword\">in</span><span class=\"symbol\">` `</span>a)print b[x],x,a[x]|<span class=\"symbol\">``</span><span class=\"string\">\"sort -rn -k1\"</span><span class=\"symbol\">``</span>;print``\"total size is :\"``total&#125;' /app/log/access_log``total size ``is` `:172230``21 /icons/poweredby.png 83076``14 / 70546``8 /icons/apache_pb.gif 18608``a[$7]+=$10 表示以第 <span class=\"number\">7</span> 列为下标的数组（ $<span class=\"number\">10</span> 列为$<span class=\"number\">7</span> 列的大小），把他们大小累加得到<span class=\"symbol\">``</span>$<span class=\"number\">7</span> 每次访问的大小，后面的 <span class=\"symbol\">``</span><span class=\"keyword\">for</span><span class=\"symbol\">` `</span>循环有个取巧的地方， a 和 b 数组的下标相同，所以一<span class=\"symbol\">``</span>条 <span class=\"symbol\">``</span><span class=\"keyword\">for</span><span class=\"symbol\">` `</span>语句足矣<span class=\"symbol\">`</span></span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<h3 id=\"常用字符串函数\">常用字符串函数<a href=\"posts/Linux-awk命令#常用字符串函数\"></a></h3><p><img src=\"https://images2015.cnblogs.com/blog/1089507/201701/1089507-20170126235509019-257728577.jpg\" alt=\"img\" class=\"article-img\"></p>\n<p><img src=\"https://images2015.cnblogs.com/blog/1089507/201701/1089507-20170126235518706-915272948.jpg\" alt=\"img\" class=\"article-img\"></p>\n<h4 id=\"字符串函数的应用\">字符串函数的应用<a href=\"posts/Linux-awk命令#字符串函数的应用\"></a></h4><p>替换 </p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`awk ``<span class=\"string\">'BEGIN&#123;info=\"this is a test2010test!\";gsub(/[0-9]+/,\"!\",info);print info&#125;'</span>` `this` `is` `a test!test!``在 info 中查找满足正则表达式， /[<span class=\"number\">0</span><span class=\"number\">-9</span>]+/ 用”!”替换，并且替换后的值，赋值给 info 未``给 info 值，默认是$<span class=\"number\">0</span>`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<p>查找 </p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`awk ``<span class=\"string\">'BEGIN&#123;info=\"this is a test2010test!\";print index(info,\"test\")?\"ok\":\"no found\";&#125;'</span>``ok #未找到，返回 <span class=\"number\">0</span>`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<p>匹配查找 </p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`awk ``<span class=\"string\">'BEGIN&#123;info=\"this is a test2010test!\";print match(info,/[0-9]+/)?\"ok\":\"no found\";&#125;'</span>``ok #如果查找到数字则匹配成功返回 ok，否则失败，返回未找到`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<p>截取 </p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`awk ``<span class=\"string\">'BEGIN&#123;info=\"this is a test2010test!\";print substr(info,4,10);&#125;'</span>``s ``is` `a tes #从第 <span class=\"number\">4</span> 个 字符开始，截取 <span class=\"number\">10</span> 个长度字符串`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　</p>\n<p>分割 </p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`awk ``<span class=\"string\">'BEGIN&#123;info=\"this is a test\";split(info,tA,\" \");print length(tA);for(k in tA)&#123;print k,tA[k];&#125;&#125;'</span>` `<span class=\"number\">4</span>``<span class=\"number\">4</span> test <span class=\"number\">1</span> ``this` `<span class=\"number\">2</span> ``is` `<span class=\"number\">3</span> a``#分割 info,动态创建数组 tA,awk for …<span class=\"keyword\">in</span> 循环，是一个无序的循环。 并不是从数组下标``<span class=\"number\">1</span>…n 开始`</span><br></pre></td></tr></table></div></figure>","slug":"Linux-awk命令","updated":"2019-09-19T07:25:44.596Z","comments":true,"link":"posts/Linux-awk命令","permalink":"https://shuntan.github.io/posts/Linux-awk命令/","excerpt":"一：awk简介​ awk其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。实际上 AWK 的确拥有自己的语言： AWK 程序设计语言 ， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。 ​ awk 是一种很棒的语言，它适合文本处理和报表生成，其语法较为常见，借鉴了某些语言的一些精华，如 C 语言等。在 linux 系统日常处理工作中，发挥很重要的作用，掌握了 awk将会使你的工作变的高大上。 awk 是三剑客的老大，利剑出鞘，必会不同凡响。","categories":[{"name":"awk","slug":"awk","permalink":"https://shuntan.github.io/categories/awk/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://shuntan.github.io/tags/Linux/"}]},{"title":"编译器架构的王者LLVM——使用JIT引擎","date":"2019-09-11T12:15:43.000Z","path":"posts/编译器架构的王者LLVM——使用JIT引擎/","text":"使用JIT引擎LLVM从设计之初就考虑了解释执行的功能,这非常其作为一款跨平台的中间字节码来使用,可以方便地跨平台运行。又具有编译型语言的优势，非常的方便。 我们使用的LLVM3.6版，移除了原版JIT，改换成了新版的MCJIT，性格有了不小的提升，本文就MCJIT的使用和注意事项，进行简要的介绍。 JIT技术Just-In-Time Compiler，是一种动态编译中间代码的方式，根据需要，在程序中编译并执行生成的机器码，能够大幅提升动态语言的执行速度。 像Java语言，.net平台，luajit等，广泛使用jit技术，使得程序达到了非常高的执行效率，逐渐接近原生机器语言代码的性能了。 JIT引擎的工作原理并没有那么复杂，本质上是将原来编译器要生成机器码的部分要直接写入到当前的内存中，然后通过函数指针的转换，找到对应的机器码并进行执行。 但实践中往往需要处理许多头疼的问题，例如内存的管理，符号的重定向，处理外部符号，相当于要处理编译器后端的诸多复杂的事情，真正要设计一款能用的JIT引擎还是非常困难的。 使用LLVM的MCJIT能开发什么当然基本的功能是提供一款解释器的底层工具，将LLVM字节码解释执行，具体能够做的事，例如可以制作一款跨平台的C++插件系统，使用clang将C/C++代码一次编译到.bc字节码，然后在各个平台上解释运行。也可以制作一款云调试系统，联网远程向系统注册方法，获取C++客户端的debug信息等等。当然，还有很多其他的用法等着大家来开发。 使用MCJIT做一款解释器制作LLVM字节码的解释器还是非常简单的，最棒的示例应该是LLVM源码中的工具：lli 一共700行左右的C++代码，调用LLVM工具集实现了LLVM字节码JIT引擎，如果想很好的学习llvm中的解释器和JIT，可以参考其在github上的源码。 初始化系统使用LLVM的JIT功能，需要调用几条初始化语句，可以放在main函数开始时。 123InitializeNativeTarget();InitializeNativeTargetAsmPrinter();InitializeNativeTargetAsmParser(); 这几句调用，主要是在处理JIT的TargetMachine，初始化机器相关编译目标。 引用相关的头文件这里的稍稍有点多余的，不去管了。，llvm的头文件是层次组织的，像执行引擎，都在llvm/ExecutionEngine/下，而IR相关的，也都在llvm/IR/下，初用LLVM往往搞不清需要哪些，这时就需要多查相关的文档，了解LLVM的各个模块的功能。 12345678910111213141516171819#include \"llvm/ExecutionEngine/GenericValue.h\"#include \"llvm/ExecutionEngine/MCJIT.h\"#include \"llvm/ExecutionEngine/Interpreter.h\"#include \"llvm/ExecutionEngine/SectionMemoryManager.h\"#include \"llvm/IR/Verifier.h\"#include \"llvm/IR/Constants.h\"#include \"llvm/IR/DerivedTypes.h\"#include \"llvm/IR/IRBuilder.h\"#include \"llvm/IR/Instructions.h\"#include \"llvm/IR/LLVMContext.h\"#include \"llvm/IR/Module.h\"#include &lt;llvm/IRReader/IRReader.h&gt;#include &lt;llvm/Support/SourceMgr.h&gt;#include \"llvm/Support/ManagedStatic.h\"#include \"llvm/Support/TargetSelect.h\"#include &lt;llvm/Support/MemoryBuffer.h&gt;#include \"llvm/Support/raw_ostream.h\"#include &lt;llvm/Support/DynamicLibrary.h&gt;#include \"llvm/Support/Debug.h\" 主要说要注意的几个细节，首先是 12#include \"llvm/ExecutionEngine/MCJIT.h\"#include \"llvm/ExecutionEngine/Interpreter.h\" C++编译时，这两个头文件居然不是必须的，如果你不注意时，编译不会报错。因为执行引擎是一个接口的模式，不对外暴露子类的细节，我们必须注意引用其中一个或两个都引用，否则会链接不到对应的引擎。 会报如下错误： Create Engine ErrorJIT has not been linked in. 使用EngineBuilder构建JIT引擎由于JIT引擎我们不需要创建多个，我们这里使用单例类的方式，使用一个LLVM中的Module进行初始化，如果引擎已经创建过，我们可以使用addModule方法，将LLVM的Module添加到引擎的Module集合中。 finalizeObject函数，是一个关键的函数，对应JIT引擎很重要，我们要保障我们在调用JIT编译后的代码前，要调用过该函数 1234567891011121314151617181920ExecutionEngine* EE = NULL;RTDyldMemoryManager* RTDyldMM = NULL;void initEE(std::unique_ptr&lt;Module&gt; Owner) &#123; string ErrStr; if (EE == NULL) &#123; RTDyldMM = new SectionMemoryManager(); EE = EngineBuilder(std::move(Owner)) .setEngineKind(EngineKind::JIT) .setErrorStr(&amp;ErrStr) .setVerifyModules(true) .setMCJITMemoryManager(std::unique_ptr&lt;RTDyldMemoryManager&gt;(RTDyldMM)) .setOptLevel(CodeGenOpt::Default) .create();&#125; else EE-&gt;addModule(std::move(Owner));if (ErrStr.length() != 0) cerr &lt;&lt; \"Create Engine Error\" &lt;&lt; endl &lt;&lt; ErrStr &lt;&lt; endl;EE-&gt;finalizeObject();&#125; 这里是finalizeObject的文档解释： finalizeObject - ensure the module is fully processed and is usable. It is the user-level function for completing the process of making the object usable for execution. It should be called after sections within an object have been relocated using mapSectionAddress. When this method is called the MCJIT execution engine will reapply relocations for a loaded object. This method has no effect for the interpeter. setEngineKind可选的有JIT和Interpreter，如果默认的话，则是优先JIT，检测到哪个引擎能用就用哪个。 setMCJITMemoryManager是一个关键的管理器，当然貌似默认不写也会构建，这里我们为了清晰所见，还是添加了这条配置，这个内存管理器在执行引擎中很重要，一般本地的应用我们要选择SectionMemoryManager类，而lli中甚至还包含着远程调用的相关类。 setOptLevel是设置代码的优化等级，默认是O2，可以修改为下面枚举值： NoneLessDefaultAggressiveMCJIT架构图 编写核心的调用方法12345678910111213141516171819202122232425typedef void (*func_type)(void*);// path是bc文件的路径，func_name是要执行的函数名void Run(const std::string&amp; path, const std::string&amp; func_name) &#123;// 首先要读取要执行的bc字节码SMDiagnostic error;std::unique_ptr&lt;Module&gt; Owner = parseIRFile(path, error, context);if(Owner == nullptr) &#123; cout &lt;&lt; \"Load Error: \" &lt;&lt; path &lt;&lt; endl; Owner-&gt;dump(); return;&#125;// 单例的方法进行初始化，暂未考虑多线程initEE(std::move(Owner));// 获取编译后的函数指针并执行uint64_t func_addr = EE-&gt;getFunctionAddress(func_name.c_str());if (func_addr == 0) &#123; printf(\"错误, 找不到函数: %s\\n\", func_name.c_str()); return;&#125;func_type func = (func_type) func_addr;func(NULL); // 需要传参数时可以从这里传递&#125; 解释器版本解释器效率稍低一下，不过能够做到惰性的一下代码载入和执行工作，有时也很有用途。下面我们就在jit的基础上，介绍一下简单的解释器功能。介绍器最主要需要做的就是将生成引擎改变： 12345678EE = EngineBuilder(std::move(Owner)) // 这里改完解释器 .setEngineKind(EngineKind::Interpreter) .setErrorStr(&amp;ErrStr) .setVerifyModules(true) .setMCJITMemoryManager(std::unique_ptr&lt;RTDyldMemoryManager&gt;(RTDyldMM)) .setOptLevel(CodeGenOpt::Default) .create(); 另外解释器可以使用getLazyIRFileModule函数可以替换parseIRFile实现.bc文件的惰性加载。 解释器的执行方式和JIT有一些不同，要使用FindFunctionNamed函数来寻找对应的函数对象，解释器能够获取更全的LLVM字节码的中间信息，例如一些属性和元数据，在做一些灵活的动态语言解释器时是非常有用的。 12345678910111213141516171819// 给解释器使用的部分Function* func = EE-&gt;FindFunctionNamed(func_name.c_str());if (func == NULL) &#123; printf(\"忽略, 找不到函数: %s\\n\", func_name.c_str()); return;&#125;// 如果需要传参数的话std::vector&lt;GenericValue&gt; args;args.push_back(GenericValue(NULL));EE-&gt;runFunction(func, args);创建测试的C代码我在是Elite编译器工程下开发的，所以会有接口调用的测试，大家可以，创建简单的C函数进行调用测试：extern voidtest２_elite_plugin_init(CodeGenContext* context) &#123; printf(\"test２_elite_plugin_init\\n\"); if (context == NULL) printf(\"Error for context\\n\"); else context-&gt;AddOrReplaceMacros(macro_funcs);&#125;执行结果： 最近研究的LLVM技术，大部分应用于正在进行的ELite编译器开发，欢迎朋友们关注和参与。github: https://github.com/elite-lang/Elite文档: http://elite-lang.org/doc/zh-cn/ 版权声明：本文为CSDN博主「西风逍遥游」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/xfxyy_sxfancy/article/details/50485090","raw":"---\ntitle: 编译器架构的王者LLVM——使用JIT引擎\ncopyright: true\ntags: C++\ncategories: 编译器\ncomments: true\nabbrlink: 52c08981\ndate: 2019-09-11 20:15:43\ntype:\nkeyword:\ntop:\npassword:\ndescription:\nthumbnail: /posts/编译器架构的王者LLVM——使用JIT引擎/c0c2f09d002c93057a08ccca749b0648.jpeg\n---\n\n# 使用JIT引擎\n\nLLVM从设计之初就考虑了解释执行的功能,这非常其作为一款跨平台的中间字节码来使用,可以方便地跨平台运行。又具有编译型语言的优势，非常的方便。\n\n我们使用的LLVM3.6版，移除了原版JIT，改换成了新版的MCJIT，性格有了不小的提升，本文就MCJIT的使用和注意事项，进行简要的介绍。\n\n<!--more-->\n\n# JIT技术\n\nJust-In-Time Compiler，是一种动态编译中间代码的方式，根据需要，在程序中编译并执行生成的机器码，能够大幅提升动态语言的执行速度。\n\n像Java语言，.net平台，luajit等，广泛使用jit技术，使得程序达到了非常高的执行效率，逐渐接近原生机器语言代码的性能了。\n\nJIT引擎的工作原理并没有那么复杂，本质上是将原来编译器要生成机器码的部分要直接写入到当前的内存中，然后通过函数指针的转换，找到对应的机器码并进行执行。\n\n但实践中往往需要处理许多头疼的问题，例如内存的管理，符号的重定向，处理外部符号，相当于要处理编译器后端的诸多复杂的事情，真正要设计一款能用的JIT引擎还是非常困难的。\n\n使用LLVM的MCJIT能开发什么\n当然基本的功能是提供一款解释器的底层工具，将LLVM字节码解释执行，具体能够做的事，例如可以制作一款跨平台的C++插件系统，使用clang将C/C++代码一次编译到.bc字节码，然后在各个平台上解释运行。也可以制作一款云调试系统，联网远程向系统注册方法，获取C++客户端的debug信息等等。当然，还有很多其他的用法等着大家来开发。\n\n# 使用MCJIT做一款解释器\n制作LLVM字节码的解释器还是非常简单的，最棒的示例应该是LLVM源码中的工具：lli\n\n一共700行左右的C++代码，调用LLVM工具集实现了LLVM字节码JIT引擎，如果想很好的学习llvm中的解释器和JIT，可以参考其在[github](https://github.com/llvm-mirror/llvm/blob/master/tools/lli/lli.cpp)上的源码。\n\n初始化系统\n使用LLVM的JIT功能，需要调用几条初始化语句，可以放在main函数开始时。\n\n```\nInitializeNativeTarget();\nInitializeNativeTargetAsmPrinter();\nInitializeNativeTargetAsmParser();\n```\n\n这几句调用，主要是在处理JIT的TargetMachine，初始化机器相关编译目标。\n\n# 引用相关的头文件\n\n这里的稍稍有点多余的，不去管了。，llvm的头文件是层次组织的，像执行引擎，都在llvm/ExecutionEngine/下，而IR相关的，也都在llvm/IR/下，初用LLVM往往搞不清需要哪些，这时就需要多查相关的文档，了解LLVM的各个模块的功能。\n\n```c++\n#include \"llvm/ExecutionEngine/GenericValue.h\"\n#include \"llvm/ExecutionEngine/MCJIT.h\"\n#include \"llvm/ExecutionEngine/Interpreter.h\"\n#include \"llvm/ExecutionEngine/SectionMemoryManager.h\"\n#include \"llvm/IR/Verifier.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/IRBuilder.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/Module.h\"\n#include <llvm/IRReader/IRReader.h>\n#include <llvm/Support/SourceMgr.h>\n#include \"llvm/Support/ManagedStatic.h\"\n#include \"llvm/Support/TargetSelect.h\"\n#include <llvm/Support/MemoryBuffer.h>\n#include \"llvm/Support/raw_ostream.h\"\n#include <llvm/Support/DynamicLibrary.h>\n#include \"llvm/Support/Debug.h\"\n```\n\n主要说要注意的几个细节，首先是\n\n```\n#include \"llvm/ExecutionEngine/MCJIT.h\"\n#include \"llvm/ExecutionEngine/Interpreter.h\"\n```\n\nC++编译时，这两个头文件居然不是必须的，如果你不注意时，编译不会报错。因为执行引擎是一个接口的模式，不对外暴露子类的细节，我们必须注意引用其中一个或两个都引用，否则会链接不到对应的引擎。\n\n会报如下错误：\n\nCreate Engine Error\nJIT has not been linked in.\n\n![ç±»ç»æ](https://img-blog.csdn.net/20160108201207936)\n\n# 使用EngineBuilder构建JIT引擎\n\n由于JIT引擎我们不需要创建多个，我们这里使用单例类的方式，使用一个LLVM中的Module进行初始化，如果引擎已经创建过，我们可以使用addModule方法，将LLVM的Module添加到引擎的Module集合中。\n\nfinalizeObject函数，是一个关键的函数，对应JIT引擎很重要，我们要保障我们在调用JIT编译后的代码前，要调用过该函数\n\n```c++\nExecutionEngine* EE = NULL;\nRTDyldMemoryManager* RTDyldMM = NULL;\n\nvoid initEE(std::unique_ptr<Module> Owner) {\n    string ErrStr;\n    if (EE == NULL) {\n        RTDyldMM = new SectionMemoryManager();\n        EE = EngineBuilder(std::move(Owner))\n            .setEngineKind(EngineKind::JIT)\n            .setErrorStr(&ErrStr)\n            .setVerifyModules(true)\n            .setMCJITMemoryManager(std::unique_ptr<RTDyldMemoryManager>(RTDyldMM))\n            .setOptLevel(CodeGenOpt::Default)\n            .create();\n} else\n    EE->addModule(std::move(Owner));\nif (ErrStr.length() != 0)\n    cerr << \"Create Engine Error\" << endl << ErrStr << endl;\nEE->finalizeObject();\n}\n```\n\n这里是finalizeObject的文档解释：\n\nfinalizeObject - ensure the module is fully processed and is usable.\n\nIt is the user-level function for completing the process of making the object usable for execution. It should be called after sections within an object have been relocated using mapSectionAddress. When this method is called the MCJIT execution engine will reapply relocations for a loaded object. This method has no effect for the interpeter.\n\nsetEngineKind可选的有JIT和Interpreter，如果默认的话，则是优先JIT，检测到哪个引擎能用就用哪个。\n\nsetMCJITMemoryManager是一个关键的管理器，当然貌似默认不写也会构建，这里我们为了清晰所见，还是添加了这条配置，这个内存管理器在执行引擎中很重要，一般本地的应用我们要选择SectionMemoryManager类，而lli中甚至还包含着远程调用的相关类。\n\nsetOptLevel是设置代码的优化等级，默认是O2，可以修改为下面枚举值：\n\nNone\nLess\nDefault\nAggressive\nMCJIT架构图\n\n\n\n# 编写核心的调用方法\n\n```c++\ntypedef void (*func_type)(void*);\n\n// path是bc文件的路径，func_name是要执行的函数名\nvoid Run(const std::string& path, const std::string& func_name) {\n// 首先要读取要执行的bc字节码\nSMDiagnostic error;\nstd::unique_ptr<Module> Owner = parseIRFile(path, error, context);\nif(Owner == nullptr) {\n    cout << \"Load Error: \" << path << endl;\n    Owner->dump();\n    return;\n}\n\n// 单例的方法进行初始化，暂未考虑多线程\ninitEE(std::move(Owner));\n\n// 获取编译后的函数指针并执行\nuint64_t func_addr = EE->getFunctionAddress(func_name.c_str());\nif (func_addr == 0) {\n    printf(\"错误, 找不到函数: %s\\n\", func_name.c_str());\n    return;\n}\nfunc_type func = (func_type) func_addr;\nfunc(NULL); // 需要传参数时可以从这里传递\n}\n```\n# 解释器版本\n\n解释器效率稍低一下，不过能够做到惰性的一下代码载入和执行工作，有时也很有用途。下面我们就在jit的基础上，介绍一下简单的解释器功能。介绍器最主要需要做的就是将生成引擎改变：\n\n```c++\nEE = EngineBuilder(std::move(Owner))\n    // 这里改完解释器\n    .setEngineKind(EngineKind::Interpreter)\n    .setErrorStr(&ErrStr)\n    .setVerifyModules(true)\n    .setMCJITMemoryManager(std::unique_ptr<RTDyldMemoryManager>(RTDyldMM))\n    .setOptLevel(CodeGenOpt::Default)\n    .create();\n```\n\n\n\n另外解释器可以使用getLazyIRFileModule函数可以替换parseIRFile实现.bc文件的惰性加载。\n\n解释器的执行方式和JIT有一些不同，要使用FindFunctionNamed函数来寻找对应的函数对象，解释器能够获取更全的LLVM字节码的中间信息，例如一些属性和元数据，在做一些灵活的动态语言解释器时是非常有用的。\n\n```c++\n// 给解释器使用的部分\nFunction* func = EE->FindFunctionNamed(func_name.c_str());\nif (func == NULL) {\n    printf(\"忽略, 找不到函数: %s\\n\", func_name.c_str());\n    return;\n}\n// 如果需要传参数的话\nstd::vector<GenericValue> args;\nargs.push_back(GenericValue(NULL));\nEE->runFunction(func, args);\n创建测试的C代码\n我在是Elite编译器工程下开发的，所以会有接口调用的测试，大家可以，创建简单的C函数进行调用测试：\nextern void\ntest２_elite_plugin_init(CodeGenContext* context) {\n    printf(\"test２_elite_plugin_init\\n\");\n    if (context == NULL) printf(\"Error for context\\n\");\n    else context->AddOrReplaceMacros(macro_funcs);\n}\n执行结果：\n```\n\n\n\n最近研究的LLVM技术，大部分应用于正在进行的ELite编译器开发，欢迎朋友们关注和参与。\ngithub: https://github.com/elite-lang/Elite\n文档: http://elite-lang.org/doc/zh-cn/\n\n------------------------------------------------\n版权声明：本文为CSDN博主「西风逍遥游」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/xfxyy_sxfancy/article/details/50485090","content":"<h1 id=\"使用JIT引擎\">使用JIT引擎<a href=\"posts/编译器架构的王者LLVM——使用JIT引擎#使用JIT引擎\"></a></h1><p>LLVM从设计之初就考虑了解释执行的功能,这非常其作为一款跨平台的中间字节码来使用,可以方便地跨平台运行。又具有编译型语言的优势，非常的方便。</p>\n<p>我们使用的LLVM3.6版，移除了原版JIT，改换成了新版的MCJIT，性格有了不小的提升，本文就MCJIT的使用和注意事项，进行简要的介绍。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"JIT技术\">JIT技术<a href=\"posts/编译器架构的王者LLVM——使用JIT引擎#JIT技术\"></a></h1><p>Just-In-Time Compiler，是一种动态编译中间代码的方式，根据需要，在程序中编译并执行生成的机器码，能够大幅提升动态语言的执行速度。</p>\n<p>像Java语言，.net平台，luajit等，广泛使用jit技术，使得程序达到了非常高的执行效率，逐渐接近原生机器语言代码的性能了。</p>\n<p>JIT引擎的工作原理并没有那么复杂，本质上是将原来编译器要生成机器码的部分要直接写入到当前的内存中，然后通过函数指针的转换，找到对应的机器码并进行执行。</p>\n<p>但实践中往往需要处理许多头疼的问题，例如内存的管理，符号的重定向，处理外部符号，相当于要处理编译器后端的诸多复杂的事情，真正要设计一款能用的JIT引擎还是非常困难的。</p>\n<p>使用LLVM的MCJIT能开发什么<br>当然基本的功能是提供一款解释器的底层工具，将LLVM字节码解释执行，具体能够做的事，例如可以制作一款跨平台的C++插件系统，使用clang将C/C++代码一次编译到.bc字节码，然后在各个平台上解释运行。也可以制作一款云调试系统，联网远程向系统注册方法，获取C++客户端的debug信息等等。当然，还有很多其他的用法等着大家来开发。</p>\n<h1 id=\"使用MCJIT做一款解释器\">使用MCJIT做一款解释器<a href=\"posts/编译器架构的王者LLVM——使用JIT引擎#使用MCJIT做一款解释器\"></a></h1><p>制作LLVM字节码的解释器还是非常简单的，最棒的示例应该是LLVM源码中的工具：lli</p>\n<p>一共700行左右的C++代码，调用LLVM工具集实现了LLVM字节码JIT引擎，如果想很好的学习llvm中的解释器和JIT，可以参考其在<a href=\"https://github.com/llvm-mirror/llvm/blob/master/tools/lli/lli.cpp\" target=\"_blank\" rel=\"noopener\">github</a>上的源码。</p>\n<p>初始化系统<br>使用LLVM的JIT功能，需要调用几条初始化语句，可以放在main函数开始时。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InitializeNativeTarget()<span class=\"comment\">;</span></span><br><span class=\"line\">InitializeNativeTargetAsmPrinter()<span class=\"comment\">;</span></span><br><span class=\"line\">InitializeNativeTargetAsmParser()<span class=\"comment\">;</span></span><br></pre></td></tr></table></div></figure>\n\n<p>这几句调用，主要是在处理JIT的TargetMachine，初始化机器相关编译目标。</p>\n<h1 id=\"引用相关的头文件\">引用相关的头文件<a href=\"posts/编译器架构的王者LLVM——使用JIT引擎#引用相关的头文件\"></a></h1><p>这里的稍稍有点多余的，不去管了。，llvm的头文件是层次组织的，像执行引擎，都在llvm/ExecutionEngine/下，而IR相关的，也都在llvm/IR/下，初用LLVM往往搞不清需要哪些，这时就需要多查相关的文档，了解LLVM的各个模块的功能。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"llvm/ExecutionEngine/GenericValue.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"llvm/ExecutionEngine/MCJIT.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"llvm/ExecutionEngine/Interpreter.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"llvm/ExecutionEngine/SectionMemoryManager.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"llvm/IR/Verifier.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"llvm/IR/Constants.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"llvm/IR/DerivedTypes.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"llvm/IR/IRBuilder.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"llvm/IR/Instructions.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"llvm/IR/LLVMContext.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"llvm/IR/Module.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;llvm/IRReader/IRReader.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;llvm/Support/SourceMgr.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"llvm/Support/ManagedStatic.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"llvm/Support/TargetSelect.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;llvm/Support/MemoryBuffer.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"llvm/Support/raw_ostream.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;llvm/Support/DynamicLibrary.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"llvm/Support/Debug.h\"</span></span></span><br></pre></td></tr></table></div></figure>\n\n<p>主要说要注意的几个细节，首先是</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"string\">\"llvm/ExecutionEngine/MCJIT.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"string\">\"llvm/ExecutionEngine/Interpreter.h\"</span></span></span><br></pre></td></tr></table></div></figure>\n\n<p>C++编译时，这两个头文件居然不是必须的，如果你不注意时，编译不会报错。因为执行引擎是一个接口的模式，不对外暴露子类的细节，我们必须注意引用其中一个或两个都引用，否则会链接不到对应的引擎。</p>\n<p>会报如下错误：</p>\n<p>Create Engine Error<br>JIT has not been linked in.</p>\n<p><img src=\"https://img-blog.csdn.net/20160108201207936\" alt=\"ç±»ç»æ\" class=\"article-img\"></p>\n<h1 id=\"使用EngineBuilder构建JIT引擎\">使用EngineBuilder构建JIT引擎<a href=\"posts/编译器架构的王者LLVM——使用JIT引擎#使用EngineBuilder构建JIT引擎\"></a></h1><p>由于JIT引擎我们不需要创建多个，我们这里使用单例类的方式，使用一个LLVM中的Module进行初始化，如果引擎已经创建过，我们可以使用addModule方法，将LLVM的Module添加到引擎的Module集合中。</p>\n<p>finalizeObject函数，是一个关键的函数，对应JIT引擎很重要，我们要保障我们在调用JIT编译后的代码前，要调用过该函数</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutionEngine* EE = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">RTDyldMemoryManager* RTDyldMM = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">initEE</span><span class=\"params\">(<span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;Module&gt; Owner)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> ErrStr;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (EE == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        RTDyldMM = <span class=\"keyword\">new</span> SectionMemoryManager();</span><br><span class=\"line\">        EE = EngineBuilder(<span class=\"built_in\">std</span>::move(Owner))</span><br><span class=\"line\">            .setEngineKind(EngineKind::JIT)</span><br><span class=\"line\">            .setErrorStr(&amp;ErrStr)</span><br><span class=\"line\">            .setVerifyModules(<span class=\"literal\">true</span>)</span><br><span class=\"line\">            .setMCJITMemoryManager(<span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;RTDyldMemoryManager&gt;(RTDyldMM))</span><br><span class=\"line\">            .setOptLevel(CodeGenOpt::Default)</span><br><span class=\"line\">            .create();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">    EE-&gt;addModule(<span class=\"built_in\">std</span>::move(Owner));</span><br><span class=\"line\"><span class=\"keyword\">if</span> (ErrStr.length() != <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"built_in\">cerr</span> &lt;&lt; <span class=\"string\">\"Create Engine Error\"</span> &lt;&lt; <span class=\"built_in\">endl</span> &lt;&lt; ErrStr &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">EE-&gt;finalizeObject();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>这里是finalizeObject的文档解释：</p>\n<p>finalizeObject - ensure the module is fully processed and is usable.</p>\n<p>It is the user-level function for completing the process of making the object usable for execution. It should be called after sections within an object have been relocated using mapSectionAddress. When this method is called the MCJIT execution engine will reapply relocations for a loaded object. This method has no effect for the interpeter.</p>\n<p>setEngineKind可选的有JIT和Interpreter，如果默认的话，则是优先JIT，检测到哪个引擎能用就用哪个。</p>\n<p>setMCJITMemoryManager是一个关键的管理器，当然貌似默认不写也会构建，这里我们为了清晰所见，还是添加了这条配置，这个内存管理器在执行引擎中很重要，一般本地的应用我们要选择SectionMemoryManager类，而lli中甚至还包含着远程调用的相关类。</p>\n<p>setOptLevel是设置代码的优化等级，默认是O2，可以修改为下面枚举值：</p>\n<p>None<br>Less<br>Default<br>Aggressive<br>MCJIT架构图</p>\n<h1 id=\"编写核心的调用方法\">编写核心的调用方法<a href=\"posts/编译器架构的王者LLVM——使用JIT引擎#编写核心的调用方法\"></a></h1><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(*func_type)</span><span class=\"params\">(<span class=\"keyword\">void</span>*)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// path是bc文件的路径，func_name是要执行的函数名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Run</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; path, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; func_name)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// 首先要读取要执行的bc字节码</span></span><br><span class=\"line\">SMDiagnostic error;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;Module&gt; Owner = parseIRFile(path, error, context);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(Owner == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Load Error: \"</span> &lt;&lt; path &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    Owner-&gt;dump();</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 单例的方法进行初始化，暂未考虑多线程</span></span><br><span class=\"line\">initEE(<span class=\"built_in\">std</span>::move(Owner));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取编译后的函数指针并执行</span></span><br><span class=\"line\"><span class=\"keyword\">uint64_t</span> func_addr = EE-&gt;getFunctionAddress(func_name.c_str());</span><br><span class=\"line\"><span class=\"keyword\">if</span> (func_addr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"错误, 找不到函数: %s\\n\"</span>, func_name.c_str());</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func_type func = (func_type) func_addr;</span><br><span class=\"line\">func(<span class=\"literal\">NULL</span>); <span class=\"comment\">// 需要传参数时可以从这里传递</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h1 id=\"解释器版本\">解释器版本<a href=\"posts/编译器架构的王者LLVM——使用JIT引擎#解释器版本\"></a></h1><p>解释器效率稍低一下，不过能够做到惰性的一下代码载入和执行工作，有时也很有用途。下面我们就在jit的基础上，介绍一下简单的解释器功能。介绍器最主要需要做的就是将生成引擎改变：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EE = EngineBuilder(<span class=\"built_in\">std</span>::move(Owner))</span><br><span class=\"line\">    <span class=\"comment\">// 这里改完解释器</span></span><br><span class=\"line\">    .setEngineKind(EngineKind::Interpreter)</span><br><span class=\"line\">    .setErrorStr(&amp;ErrStr)</span><br><span class=\"line\">    .setVerifyModules(<span class=\"literal\">true</span>)</span><br><span class=\"line\">    .setMCJITMemoryManager(<span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;RTDyldMemoryManager&gt;(RTDyldMM))</span><br><span class=\"line\">    .setOptLevel(CodeGenOpt::Default)</span><br><span class=\"line\">    .create();</span><br></pre></td></tr></table></div></figure>\n\n<p>另外解释器可以使用getLazyIRFileModule函数可以替换parseIRFile实现.bc文件的惰性加载。</p>\n<p>解释器的执行方式和JIT有一些不同，要使用FindFunctionNamed函数来寻找对应的函数对象，解释器能够获取更全的LLVM字节码的中间信息，例如一些属性和元数据，在做一些灵活的动态语言解释器时是非常有用的。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 给解释器使用的部分</span></span><br><span class=\"line\">Function* func = EE-&gt;FindFunctionNamed(func_name.c_str());</span><br><span class=\"line\"><span class=\"keyword\">if</span> (func == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"忽略, 找不到函数: %s\\n\"</span>, func_name.c_str());</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 如果需要传参数的话</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;GenericValue&gt; args;</span><br><span class=\"line\">args.push_back(GenericValue(<span class=\"literal\">NULL</span>));</span><br><span class=\"line\">EE-&gt;runFunction(func, args);</span><br><span class=\"line\">创建测试的C代码</span><br><span class=\"line\">我在是Elite编译器工程下开发的，所以会有接口调用的测试，大家可以，创建简单的C函数进行调用测试：</span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span></span><br><span class=\"line\">test２_elite_plugin_init(CodeGenContext* context) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"test２_elite_plugin_init\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (context == <span class=\"literal\">NULL</span>) <span class=\"built_in\">printf</span>(<span class=\"string\">\"Error for context\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> context-&gt;AddOrReplaceMacros(macro_funcs);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">执行结果：</span><br></pre></td></tr></table></div></figure>\n\n<p>最近研究的LLVM技术，大部分应用于正在进行的ELite编译器开发，欢迎朋友们关注和参与。<br>github: <a href=\"https://github.com/elite-lang/Elite\" target=\"_blank\" rel=\"noopener\">https://github.com/elite-lang/Elite</a><br>文档: <a href=\"http://elite-lang.org/doc/zh-cn/\" target=\"_blank\" rel=\"noopener\">http://elite-lang.org/doc/zh-cn/</a></p>\n<hr>\n<p>版权声明：本文为CSDN博主「西风逍遥游」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/xfxyy_sxfancy/article/details/50485090\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xfxyy_sxfancy/article/details/50485090</a></p>\n","slug":"编译器架构的王者LLVM——使用JIT引擎","updated":"2019-09-16T11:54:18.150Z","comments":true,"link":"posts/编译器架构的王者LLVM——使用JIT引擎","permalink":"https://shuntan.github.io/posts/编译器架构的王者LLVM——使用JIT引擎/","excerpt":"使用JIT引擎LLVM从设计之初就考虑了解释执行的功能,这非常其作为一款跨平台的中间字节码来使用,可以方便地跨平台运行。又具有编译型语言的优势，非常的方便。 我们使用的LLVM3.6版，移除了原版JIT，改换成了新版的MCJIT，性格有了不小的提升，本文就MCJIT的使用和注意事项，进行简要的介绍。","categories":[{"name":"编译器","slug":"编译器","permalink":"https://shuntan.github.io/categories/编译器/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://shuntan.github.io/tags/C/"}]},{"title":"源码解读Linux的limits.conf文件","date":"2019-09-09T12:19:38.000Z","path":"posts/源码解读Linux的limits-conf文件/","text":"目录 前言 1 PAM 2 pam_limits 2 limits.conf的由来 3 模块入口函数 4 解析limits.conf 6 生效limits.conf 7 systemctl和systemd 8 总结 10 附1：资源 11 附2：编译ninja 11 附3：使用meson编译systemd 11 附4：安装Python-3.7.2 12 附5：安装libcap 12 前言本文不一定适合比较老版本的Linux，如果只关心使用，请直接看“总结”，本文主要针对CentOS，其它Linux发行版本类似，但细节可能有出入，比如重启服务可能不是用systemctl，而是service等。 当需要调整一个进程可打开的最多文件数或SOCKET连接数等，以CentOS为例，通常的做法是修改文件/etc/security/limits.conf，比如将最多可打开数调整为10万： vi /etc/security/limits.conf soft nofile 100000 hard nofile 100000 读取limit.conf文件的并不是Linux内核，而是一个内核模块PAM，对应的模块文件为： /usr/lib64/security/pam_limits.so/usr/lib/security/pam_limits.so 而/etc/pam.d目录下的配置文件，则由libpam.so读取，实际上所有的模块均由libpam.so加载，可将libpam.so看成是所有PAM模块的框架或容器，而且libpam.so本身也不是内核的组成部分。 多个不同Linux版本上查看，并没有叫libpam.so的文件名，均是libpam.so.0（不清楚是否所有都这样），但是编译Linux-PAM-1.3.1源代码有名为libpam.so软链接，指向libpam.so.0.84.2。 /usr/lib64/libpam.so.0 -&gt; libpam.so.0.83.1/usr/lib64/libpam.so.0.83.1/usr/lib64/libpam_misc.so.0.82.0 /usr/lib/libpam.so.0 -&gt; libpam.so.0.83.1/usr/lib/libpam.so.0.83.1/usr/lib/libpam_misc.so.0.82.0 libpam.so会被加载到crond等进程空间（那当然也可以不加载），如果没有加载libpam.so，则limits.conf不会生效。crond等不会主动加载libpam.so，那么是谁让libpam.so进入crond等进程空间的了？（执行“grep libpam /proc/pidof crond/maps”可查看libpam是否在crond的进程空间）。 在CentOS，可用service来启动或重启crond，所以跟它应当是相关的，而service实际调用的是systemctl这一系统工具（非Shell脚本，service为老版本使用方式，使用systemctl启动和重启服务，使用方式和service相同）。 service crond restartRedirecting to /bin/systemctl restart crond.service file /bin/systemctl/bin/systemctl: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV) systemctl crond restart # 重启crontab服务进程crondPAMPAM的全称为“Pluggable Authentication Modules”，即可插入认证模块。最初由太阳微系统公司（Sun Microsystems，已于2009年被甲骨文收购）于1995年在Solaris开发。PAM代码不包含在Linux内核中，并有专门的网站：http://linux-pam.org/，源代码托管在Github上（https://github.com/linux-pam/linux-pam/releases）。 pam_limitspam_limits是PAM其中的一个模块（模块文件名为pam_limits.so），也是程序员接触较多的模型之一，对应的源代码文件为pam_limits.c，代码规模为几百行，加上所有注释和空格有1100多行： 123#if !defined(linux) &amp;&amp; !defined(__linux)#warning THIS CODE IS KNOWN TO WORK ONLY ON LINUX !!!#endif 源代码提供autoconf编译，尝试在Linux-3.10上可编译成功： ~/Linux-PAM-1.3.1]$ ./configure –prefix=/usr/local/Linux-PAM-1.3.1make limits.conf的由来确定模块pam_limits的配置文件，由宏CONF_FILE决定： // pam_limits.c #define CONF_FILE (pl-&gt;conf_file != NULL)?pl-&gt;conf_file:LIMITS_FILE 使用的地方： 12345678910111213141516// pam_limits.cstatic intparse_config_file(pam_handle_t *pamh, const char *uname, uid_t uid, gid_t gid, int ctrl, struct pam_limit_s *pl)&#123; FILE *fil; char buf[LINE_LENGTH];/* check for the LIMITS_FILE */if (ctrl &amp; PAM_DEBUG_ARG) pam_syslog(pamh, LOG_DEBUG, \"reading settings from '%s'\", CONF_FILE);fil = fopen(CONF_FILE, \"r\"); // 打开配置文件，跟参数“pl”有关系if (fil == NULL) &#123; pam_syslog (pamh, LOG_WARNING,\"cannot read settings from %s: %m\", CONF_FILE); return PAM_SERVICE_ERR;&#125; 如果函数parse_config_file的参数“pl”值为NULL，则配置文件名在编译时决定，这种情况下，配置文件名被固定为limits.conf： Makefile.ammodules/pam_limits/Makefile.am: -DLIMITS_FILE_DIR=&quot;$(limits_conf_dir)/*.conf&quot; modules/pam_limits/Makefile.am: -DLIMITS_FILE=&quot;$(SCONFIGDIR)/limits.conf&quot; 只是limits.conf所在目录可由编译时决定，也就是看SCONFIGDIR，决定在automake的configure.ac文件： configure.ac1234567891011121314AC_ARG_ENABLE(sconfigdir, AS_HELP_STRING([--enable-sconfigdir=DIR],[path to module conf files @&lt;:@default=$sysconfdir/security@:&gt;@]), SCONFIGDIR=$enableval, SCONFIGDIR=$sysconfdir/security)AC_SUBST(SCONFIGDIR)dnl and some hacks to use /etc and /libtest \"$&#123;prefix&#125;\" = \"NONE\" &amp;&amp; prefix=\"/usr\"if test $&#123;prefix&#125; = '/usr'thendnl If we use /usr as prefix, use /etc for config files if test $&#123;sysconfdir&#125; = '$&#123;prefix&#125;/etc' then sysconfdir=\"/etc\" fi 推导出默认为“/etc/security/limits.conf”，但从前面的分析，可看到实际还可参数动态指定，这个参数怎么来？可进入Linux的/etc/pam.d目录，找一个看一看： vi /etc/pam.d/loginsession required pam_selinux.so closesession required pam_selinux.so open 上述最后一个配置项即为模型的参数值，参数值可有0、一个或多个。通常pam_limits.so使用默认参数值，因此它的配置文件limits.conf完整路径为：/etc/security/limits.conf。 模块入口函数会话（Session）类的PAM模块的入口函数均为pam_sm_open_session（授权类的为pam_sm_authenticate，密码类的为pam_sm_chauthtok），意为创建（打开）一个会话： intpam_sm_open_session (pam_handle_t pamh, int flags UNUSED, int argc, const char *argv);// libpam/pam_handlers.c: sym = “pam_sm_open_session”; 加载模块在pam_handlers.c中完成，实际上一个模块可加载多次（可在/etc/security下看到有些配置文件中同一模型有多行）。类似于iptables，每加载一次创建一个handler，依次组成一个handler调用链（实际由配置文件中的每一行配置组成链）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// pam_handlers.c// 被_pam_parse_conf_file直接调用，// 和被_pam_init_handlers、_pam_load_conf_file一级间接调用int _pam_add_handler(pam_handle_t *pamh , int handler_type, int other, int stack_level, int type , int *actions, const char *mod_path , int argc, char **argv, int argvlen)&#123; struct loaded_module *mod = NULL; 。。。。。。 if ((handler_type == PAM_HT_MODULE || handler_type == PAM_HT_SILENT_MODULE) &amp;&amp; mod_path != NULL) &#123;if (mod_path[0] == '/') &#123; mod = _pam_load_module(pamh, mod_path, handler_type);&#125; else if (asprintf(&amp;mod_full_path, \"%s%s\", DEFAULT_MODULE_PATH, mod_path) &gt;= 0) &#123; mod = _pam_load_module(pamh, mod_full_path, handler_type); _pam_drop(mod_full_path);&#125; else &#123; pam_syslog(pamh, LOG_CRIT, \"cannot malloc full mod path\"); return PAM_ABORT;&#125;if (mod == NULL) &#123; /* if we get here with NULL it means allocation error */ return PAM_ABORT;&#125; 。。。。。。 /* point handler_p's at the root addresses of the function stacks */ switch (type) &#123; 。。。。。。 case PAM_T_SESS: handler_p = &amp;the_handlers-&gt;open_session; sym = \"pam_sm_open_session\"; handler_p2 = &amp;the_handlers-&gt;close_session; sym2 = \"pam_sm_close_session\"; break; 。。。。。。 &#125;if ((mod_type == PAM_MT_DYNAMIC_MOD) &amp;&amp; !(func = _pam_dlsym(mod-&gt;dl_handle, sym)) ) &#123; pam_syslog(pamh, LOG_ERR, \"unable to resolve symbol: %s\", sym);&#125;。。。。。。&#125; 每个模块的结果可能是成功PAM_SUCCESS(0)，全定义在文件libpam/include/security/_pam_types.h中，下列展示小部分： 1234567/* ----------------- The Linux-PAM return values ------------------ */#define PAM_SUCCESS 0 /* Successful function return */#define PAM_OPEN_ERR 1 /* dlopen() failure when dynamically *//* loading a service module */#define PAM_SYMBOL_ERR 2 /* Symbol not found */#define PAM_SERVICE_ERR 3 /* Error in service module */#define PAM_SYSTEM_ERR 4 /* System error */ 解析limits.conf重聚焦到pam_limits模块，看看它的配置文件解析，这发生在函数pam_limits.c中的parse_config_file函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// pam_limits.cstatic intparse_config_file(pam_handle_t *pamh, const char *uname, uid_t uid, gid_t gid, int ctrl, struct pam_limit_s *pl)&#123; FILE *fil; char buf[LINE_LENGTH]; // #define LINE_LENGTH 1024 // 以只读方式打开limits.conf fil = fopen(CONF_FILE, \"r\"); if (fil == NULL) &#123; pam_syslog (pamh, LOG_WARNING,\"cannot read settings from %s: %m\", CONF_FILE); return PAM_SERVICE_ERR;&#125;/* start the show */// 一行行遍历limits.confwhile (fgets(buf, LINE_LENGTH, fil) != NULL) &#123; line = buf; /* skip the leading white space */ while (*line &amp;&amp; isspace(*line)) // 跳过空行 line++; /* Rip off the comments */ tptr = strchr(line,'#'); // 去掉注释 if (tptr) *tptr = '\\0'; /* Rip off the newline char */ tptr = strchr(line,'\\n'); // 删除换行符，注意并不包括回车符 if (tptr) *tptr = '\\0'; /* Anything left ? */ if (!strlen(line)) // 经过上面几步折腾，可能成了空行 continue; // 直接调用sscanf解析配置项 // // 配置行示例： // * soft nofile 100000 // // domain：作用域名，“*”表示对所有用户有效 i = sscanf(line,\"%s%s%s%s\", domain, ltype, item, value); 。。。。。。 // 下面只看两个常用配置：domain配置为“*”或指定的用户名 // 可以看到在加载limits.conf，主要是设置输出参数pl的值。 // 而parse_config_file由pam_sm_open_session调用，亦即模块被加载时被调用。 // // 也因此修改limits.conf是不能立即生效的， // 除非重启该进程，而子进程又继承父进程的设置。 // // 假设程序跑在crontab中，则应重启crond进程， // 比如CentOS中重启crond：service crond restart // 虽然crontab中的进程是由crond拉起来的，但它并加载PAM模块， // 原因是crond在拉起子进程时，对子进程关闭了所有描述符。 // // process_limit针对当前调用进程进行limit设置 if (strcmp(domain, \"*\") == 0) // limit was set by a default entry process_limit(pamh, LIMITS_DEF_DEFAULT, ltype, item, value, ctrl, pl); 。。。。。。 if (strcmp(uname, domain) == 0) /* this user have a limit */ // limit was set by an user entry process_limit(pamh, LIMITS_DEF_USER, ltype, item, value, ctrl, pl);&#125;&#125; 生效limits.conf加载PAM模块时，即会生效limits.conf，因为这个在pam_sm_open_session就已执行了： 1234567891011121314151617/* now the session stuff */intpam_sm_open_session (pam_handle_t *pamh, int flags UNUSED, int argc, const char **argv)&#123; struct pam_limit_s plstruct; struct pam_limit_s *pl = &amp;plstruct; 。。。。。。 // 调用parse_config_file解析limits.conf， // 配置行解析结果存储在pl中（亦即plstruct） retval = parse_config_file(pamh, pwd-&gt;pw_name, pwd-&gt;pw_uid, pwd-&gt;pw_gid, ctrl, pl); 。。。。。。 // 使配置立即生效（setup_limits调用系统函数setrlimit） retval = setup_limits(pamh, pwd-&gt;pw_name, pwd-&gt;pw_uid, ctrl, pl); 。。。。。。 return PAM_SUCCESS;&#125; 模块pam_limits.so是由PAM模块libpam.so加载的，crond加载的只是libpam.so。“/etc/pam.d”目录下的文件什么时候生效？加载libpam.so时生效： 123456789101112131415161718192021222324// pam_start.cint pam_start ( const char *service_name, const char *user, const struct pam_conv *pam_conversation, pam_handle_t **pamh)&#123; 。。。。。。 if ( _pam_init_handlers(*pamh) != PAM_SUCCESS ) &#123; 。。。。。。&#125;// pam_handlers.cint _pam_init_handlers(pam_handle_t *pamh)&#123; 。。。。。。 // 函数_pam_parse_conf_file负责解析libpam.so的配置文件， // 这些配置文件一般位于目录/etc/pam.d下，如： // # ls -l /etc/pam.d/pass* // -rw-r--r-- 1 root root 188 6月 10 2014 /etc/pam.d/passwd // -rw-r--r-- 1 root root 974 12月 29 2016 /etc/pam.d/password-auth retval = _pam_parse_conf_file(pamh, f, NULL, PAM_T_ANY, 0); 。。。。。。&#125; systemctl和systemdCentOS上的systemctl（CentOS-7.X之前为service脚本）类似于Windows平台的服务管理器，替代老版本中的service脚本来管理服务。Systemctl功能非常多，有关systemctl的功能不在本文过多描述。 sytemctl的工作原理是通过与服务systemd交互，来完成各项工作，比如重启crond进程。在CentOS，systemctl替代了inittab。 可以看到正是systemd加载了pam，从ldd结果可以看出systemd也不是动态加载pam模块，而是编译时就绑定了，因此libpam.so成了系统的必须部分（但pam_limits.so仍然不是，总是可插拔）： ldd /usr/lib/systemd/systemdlinux-vdso.so.1 =&gt; (0x00007ffce5b72000) /$LIB/libonion.so =&gt; /lib64/libonion.so (0x00007f2430f56000) libselinux.so.1 =&gt; /lib64/libselinux.so.1 (0x00007f2430d31000) libcap.so.2 =&gt; /lib64/libcap.so.2 (0x00007f2430b2c000) libpam.so.0 =&gt; /lib64/libpam.so.0 (0x00007f243091d000) libaudit.so.1 =&gt; /lib64/libaudit.so.1 (0x00007f24306f5000) libkmod.so.2 =&gt; /lib64/libkmod.so.2 (0x00007f24304df000) libmount.so.1 =&gt; /lib64/libmount.so.1 (0x00007f24302a0000) librt.so.1 =&gt; /lib64/librt.so.1 (0x00007f2430098000) libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00007f242fe82000) libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007f242fc66000) libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f242f8a2000) /lib64/ld-linux-x86-64.so.2 (0x00007f243105c000) libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f242f69e000) libpcre.so.1 =&gt; /lib64/libpcre.so.1 (0x00007f242f43d000) liblzma.so.5 =&gt; /lib64/liblzma.so.5 (0x00007f242f218000) libattr.so.1 =&gt; /lib64/libattr.so.1 (0x00007f242f013000) libcap-ng.so.0 =&gt; /lib64/libcap-ng.so.0 (0x00007f242ee0d000) libz.so.1 =&gt; /lib64/libz.so.1 (0x00007f242ebf7000) libblkid.so.1 =&gt; /lib64/libblkid.so.1 (0x00007f242e9ba000) libuuid.so.1 =&gt; /lib64/libuuid.so.1 (0x00007f242e7b5000)ldd /usr/sbin/crondlinux-vdso.so.1 =&gt; (0x00007ffef31a5000) /$LIB/libonion.so =&gt; /lib64/libonion.so (0x00007f87b89e5000) libselinux.so.1 =&gt; /lib64/libselinux.so.1 (0x00007f87b8416000) libpam.so.0 =&gt; /lib64/libpam.so.0 (0x00007f87b8207000) libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f87b8003000) libaudit.so.1 =&gt; /lib64/libaudit.so.1 (0x00007f87b7ddb000) libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f87b7a17000) libpcre.so.1 =&gt; /lib64/libpcre.so.1 (0x00007f87b77b6000) liblzma.so.5 =&gt; /lib64/liblzma.so.5 (0x00007f87b7591000) /lib64/ld-linux-x86-64.so.2 (0x00007f87b88cc000) libcap-ng.so.0 =&gt; /lib64/libcap-ng.so.0 (0x00007f87b738b000) libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007f87b716f000)实际上，systemd为Linux系统（CentOS如此，像Ubuntu未必）的第一个进程，取代了以前的init进程，可以看到systemd进程和init进程不会同时存在，低版本为init，高版本为systemd。Ubuntu使用的是upstart，但也可能用systemd替代upstart。 在systemd源代码的编译文件meson.build（类似于CMake的CMakeLists.txt文件，或bazel的BUILD文件）中可以看到systemd对libpam的依赖。 systemctl部分用法： 1) 重启crond systemctl restart crond2) 显示系统状态 systemctl status● Jian.mooon State: degraded Jobs: 0 queued Failed: 2 units Since: 二 2017-10-24 02:38:50 CST; 1 years 3 months ago CGroup: / 。。。。。。 3) 重启系统 systemctl reboot4) 关闭电源 systemctl poweroff5) 待机 systemctl suspend6) 休眠 systemctl hibernate有关systemctl的更多信息，可浏览： https://wiki.archlinux.org/index.php/systemd_(简体中文)。 总结修改limits.conf不会立即生效，除非重启相关的父进程，比如crontab的crond，而有些老版本的Linux可能只能重启以生效。 1) 系统启动 -&gt; 启动初始化进程systemd -&gt; 进程sytemd加载libpam.so模块2) libpam.so根据/etc/pam.d决定是否加载pam_limits.so等3) 在加载pam_limits.so时，会读取/etc/security/limits.conf4) 重启crond等，实际是向systemd发重启指令5) 一句话：如果要使用limits.conf生效，一定要有加载pam_limits.so，如果修改limits.conf，至少要让pam_limits.so重读limits.conf。附1：资源 1) PAM官方 http://linux-pam.org/ 2) PAM源代码 https://github.com/linux-pam/linux-pam/releases 3) systemd源代码 https://github.com/systemd/systemd（使用meson编译，Meson is an open source build system，依赖ninja） 4) Vixie-cron源代码 http://ftp.isc.org/isc/cron/ https://github.com/svagner/vixie-cron ftp://ftp.riken.jp/Linux/cern/updates/slc52/SRPMS/repoview/vixie-cron.html 附2：编译ninja ninja类似于make，使用meson之前必须先准备好ninja。 1) 从https://github.com/ninja-build/ninja下载ninja源代码 2) 解压源代码包，然后进入解压后的目录 3) 执行“./configure.py –bootstrap” 4) 成功后会在目录下生成名为ninja的可执行程序文件 5) 将可执行程序文件复制到PATH目录下，比如：/usr/local/bin或/usr/bin等目录 6) 完成。 附3：使用meson编译systemd Meson-0.49.1要求3.5或更高版本的Python（https://www.python.org/），和1.5或更高版本的Ninja，还依赖gperf（简单安装：yum install -y gperf），还依赖libcap-dev（执行yum install -y libcap安装，如果仍然不行，从https://git.kernel.org/pub/scm/linux/kernel/git/morgan/libcap.git/下载源代码安装），除此之外还有一些其它的依赖，需逐个解决。 1) 从https://github.com/mesonbuild/meson下载meson源代码 2) 解压后，将meson目录添加到PATH中，比如：export PATH=/root/X/meson-0.49.1:$PATH 3) 进入systemd源代码目录 4) 执行“meson.py build”（如果出错，可能是Python版本不够） 5) 成功后会生成build子目录 6) 进入build目录，执行ninja开始编译（ninja类似于make） 附4：安装Python-3.7.2 Python-3.7.2采用automake编译： 1) 执行configure生成Makefile文件：./configure –prefix=/usr/local/Python-3.7.2 2) 执行make开始编译Python（编译时间会有点长） 3) 执行make install，安装Python（安装时间稍有点长） 4) 将Python的bin目录加入到PATH中，如：export PATH=/usr/local/Python-3.7.2/bin:$PATH 5) 可以开始使用Python-3.7.2了。 如果遇到错误“ModuleNotFoundError: No module named ‘_ctypes’”，是因为依赖的libffi-devel版本不够（可执行“yum install -y libffi-devel”安装libffi，或源码方式安装libffi）。 附5：安装libcap 1) 从https://git.kernel.org/pub/scm/linux/kernel/git/morgan/libcap.git/下载源代码包 2) 解压后进入解压目录 3) 执行make编译 4) 执行make install安装 5) 完成。 版权声明：本文为CSDN博主「一见」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/Aquester/article/details/86694644","raw":"---\ntitle: 源码解读Linux的limits.conf文件\ncopyright: true\ntags: Linux\ncategories: Linux\nabbrlink: eff71b7\ndate: 2019-09-09 20:19:38\ntype:\nkeyword:\ntop:\ncomments: true\npassword:\ndescription: 本文不一定适合比较老版本的Linux，如果只关心使用，请直接看“总结”，本文主要针对CentOS，其它Linux发行版本类似，但细节可能有出入，比如重启服务可能不是用systemctl，而是service等。 \nthumbnail: /posts/源码解读Linux的limits-conf文件/20190910105208.png\n---\n\n目录 \n\n1. 前言 1\n2. PAM 2\n3. pam_limits 2\n4. limits.conf的由来 3\n\n5. 模块入口函数 4\n6. 解析limits.conf 6\n7. 生效limits.conf 7\n8. systemctl和systemd 8\n9. 总结 10\n\n附1：资源 11\n\n附2：编译ninja 11\n\n附3：使用meson编译systemd 11\n\n附4：安装Python-3.7.2 12\n\n附5：安装libcap 12\n\n <!--more-->\n\n# 前言\n\n本文不一定适合比较老版本的Linux，如果只关心使用，请直接看“总结”，本文主要针对CentOS，其它Linux发行版本类似，但细节可能有出入，比如重启服务可能不是用systemctl，而是service等。\n\n当需要调整一个进程可打开的最多文件数或SOCKET连接数等，以CentOS为例，通常的做法是修改文件/etc/security/limits.conf，比如将最多可打开数调整为10万：\n\n## vi /etc/security/limits.conf\n\n* soft nofile 100000\n* hard nofile 100000\n\n\n读取limit.conf文件的并不是Linux内核，而是一个内核模块PAM，对应的模块文件为：\n\n/usr/lib64/security/pam_limits.so\n/usr/lib/security/pam_limits.so\n\n\n而/etc/pam.d目录下的配置文件，则由libpam.so读取，实际上所有的模块均由libpam.so加载，可将libpam.so看成是所有PAM模块的框架或容器，而且libpam.so本身也不是内核的组成部分。\n\n多个不同Linux版本上查看，并没有叫libpam.so的文件名，均是libpam.so.0（不清楚是否所有都这样），但是编译Linux-PAM-1.3.1源代码有名为libpam.so软链接，指向libpam.so.0.84.2。\n\n/usr/lib64/libpam.so.0 -> libpam.so.0.83.1\n/usr/lib64/libpam.so.0.83.1\n/usr/lib64/libpam_misc.so.0.82.0\n\n/usr/lib/libpam.so.0 -> libpam.so.0.83.1\n/usr/lib/libpam.so.0.83.1\n/usr/lib/libpam_misc.so.0.82.0\n\n\nlibpam.so会被加载到crond等进程空间（那当然也可以不加载），如果没有加载libpam.so，则limits.conf不会生效。crond等不会主动加载libpam.so，那么是谁让libpam.so进入crond等进程空间的了？（执行“grep libpam /proc/`pidof crond`/maps”可查看libpam是否在crond的进程空间）。\n\n在CentOS，可用service来启动或重启crond，所以跟它应当是相关的，而service实际调用的是systemctl这一系统工具（非Shell脚本，service为老版本使用方式，使用systemctl启动和重启服务，使用方式和service相同）。\n\n## service crond restart\n\nRedirecting to /bin/systemctl restart  crond.service\n\n## file /bin/systemctl\n\n/bin/systemctl: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV)\n\n## systemctl crond restart # 重启crontab服务进程crond\n\n\n\n# PAM\n\nPAM的全称为“Pluggable Authentication Modules”，即可插入认证模块。最初由太阳微系统公司（Sun Microsystems，已于2009年被甲骨文收购）于1995年在Solaris开发。PAM代码不包含在Linux内核中，并有专门的网站：http://linux-pam.org/，源代码托管在Github上（https://github.com/linux-pam/linux-pam/releases）。\n\n# pam_limits\n\npam_limits是PAM其中的一个模块（模块文件名为pam_limits.so），也是程序员接触较多的模型之一，对应的源代码文件为pam_limits.c，代码规模为几百行，加上所有注释和空格有1100多行：\n\n```c++\n#if !defined(linux) && !defined(__linux)\n#warning THIS CODE IS KNOWN TO WORK ONLY ON LINUX !!!\n#endif\n```\n\n\n源代码提供autoconf编译，尝试在Linux-3.10上可编译成功：\n\n~/Linux-PAM-1.3.1]$ ./configure --prefix=/usr/local/Linux-PAM-1.3.1\nmake\n\n# limits.conf的由来\n\n确定模块pam_limits的配置文件，由宏CONF_FILE决定：\n\n// pam_limits.c\n#define CONF_FILE (pl->conf_file != NULL)?pl->conf_file:LIMITS_FILE\n\n\n使用的地方：\n\n```c++\n// pam_limits.c\nstatic int\nparse_config_file(pam_handle_t *pamh, const char *uname, uid_t uid, gid_t gid,\n     int ctrl, struct pam_limit_s *pl)\n{\n    FILE *fil;\n    char buf[LINE_LENGTH];\n/* check for the LIMITS_FILE */\nif (ctrl & PAM_DEBUG_ARG)\n    pam_syslog(pamh, LOG_DEBUG, \"reading settings from '%s'\", CONF_FILE);\nfil = fopen(CONF_FILE, \"r\"); // 打开配置文件，跟参数“pl”有关系\nif (fil == NULL) {\n    pam_syslog (pamh, LOG_WARNING,\n\"cannot read settings from %s: %m\", CONF_FILE);\n    return PAM_SERVICE_ERR;\n}\n```\n\n\n如果函数parse_config_file的参数“pl”值为NULL，则配置文件名在编译时决定，这种情况下，配置文件名被固定为limits.conf：\n\n## Makefile.am\n\nmodules/pam_limits/Makefile.am: -DLIMITS_FILE_DIR=\\\"$(limits_conf_dir)/*.conf\\\" \\\nmodules/pam_limits/Makefile.am: -DLIMITS_FILE=\\\"$(SCONFIGDIR)/limits.conf\\\"\n\n\n只是limits.conf所在目录可由编译时决定，也就是看SCONFIGDIR，决定在automake的configure.ac文件：\n\n## configure.ac\n\n```c++\nAC_ARG_ENABLE(sconfigdir,\n        AS_HELP_STRING([--enable-sconfigdir=DIR],[path to module conf files @<:@default=$sysconfdir/security@:>@]),\n        SCONFIGDIR=$enableval, SCONFIGDIR=$sysconfdir/security)\nAC_SUBST(SCONFIGDIR)\n\ndnl and some hacks to use /etc and /lib\ntest \"${prefix}\" = \"NONE\" && prefix=\"/usr\"\nif test ${prefix} = '/usr'\nthen\ndnl If we use /usr as prefix, use /etc for config files\n        if test ${sysconfdir} = '${prefix}/etc'\n        then\n                sysconfdir=\"/etc\"\n        fi\n```\n\n\n推导出默认为“/etc/security/limits.conf”，但从前面的分析，可看到实际还可参数动态指定，这个参数怎么来？可进入Linux的/etc/pam.d目录，找一个看一看：\n\n## vi /etc/pam.d/login\n\nsession    required     pam_selinux.so close\nsession    required     pam_selinux.so open\n\n\n上述最后一个配置项即为模型的参数值，参数值可有0、一个或多个。通常pam_limits.so使用默认参数值，因此它的配置文件limits.conf完整路径为：/etc/security/limits.conf。\n\n# 模块入口函数\n\n会话（Session）类的PAM模块的入口函数均为pam_sm_open_session（授权类的为pam_sm_authenticate，密码类的为pam_sm_chauthtok），意为创建（打开）一个会话：\n\nint\npam_sm_open_session (pam_handle_t *pamh, int flags UNUSED, int argc, const char **argv);\n// libpam/pam_handlers.c:  sym = \"pam_sm_open_session\";\n\n加载模块在pam_handlers.c中完成，实际上一个模块可加载多次（可在/etc/security下看到有些配置文件中同一模型有多行）。类似于iptables，每加载一次创建一个handler，依次组成一个handler调用链（实际由配置文件中的每一行配置组成链）：\n\n```c++\n// pam_handlers.c\n// 被_pam_parse_conf_file直接调用，\n// 和被_pam_init_handlers、_pam_load_conf_file一级间接调用\nint _pam_add_handler(pam_handle_t *pamh\n     , int handler_type, int other, int stack_level, int type\n     , int *actions, const char *mod_path\n     , int argc, char **argv, int argvlen)\n{\n    struct loaded_module *mod = NULL;\n    。。。。。。\n    if ((handler_type == PAM_HT_MODULE ||\n         handler_type == PAM_HT_SILENT_MODULE) &&\n        mod_path != NULL) {\nif (mod_path[0] == '/') {\n    mod = _pam_load_module(pamh, mod_path, handler_type);\n} else if (asprintf(&mod_full_path, \"%s%s\",\n     DEFAULT_MODULE_PATH, mod_path) >= 0) {\n    mod = _pam_load_module(pamh, mod_full_path, handler_type);\n    _pam_drop(mod_full_path);\n} else {\n    pam_syslog(pamh, LOG_CRIT, \"cannot malloc full mod path\");\n    return PAM_ABORT;\n}\nif (mod == NULL) {\n    /* if we get here with NULL it means allocation error */\n    return PAM_ABORT;\n}\n    。。。。。。\n        /* point handler_p's at the root addresses of the function stacks */\n    switch (type) {\n        。。。。。。\n        case PAM_T_SESS:\n            handler_p = &the_handlers->open_session;\n            sym = \"pam_sm_open_session\";\n            handler_p2 = &the_handlers->close_session;\n            sym2 = \"pam_sm_close_session\";\n            break;\n        。。。。。。\n    }\nif ((mod_type == PAM_MT_DYNAMIC_MOD) &&\n    !(func = _pam_dlsym(mod->dl_handle, sym)) ) {\n    pam_syslog(pamh, LOG_ERR, \"unable to resolve symbol: %s\", sym);\n}\n。。。。。。\n}\n```\n\n\n每个模块的结果可能是成功PAM_SUCCESS(0)，全定义在文件libpam/include/security/_pam_types.h中，下列展示小部分：\n\n```c++\n/* ----------------- The Linux-PAM return values ------------------ */\n#define PAM_SUCCESS 0 /* Successful function return */\n#define PAM_OPEN_ERR 1 /* dlopen() failure when dynamically */\n/* loading a service module */\n#define PAM_SYMBOL_ERR 2 /* Symbol not found */\n#define PAM_SERVICE_ERR 3 /* Error in service module */\n#define PAM_SYSTEM_ERR 4 /* System error */\n```\n\n# 解析limits.conf\n\n重聚焦到pam_limits模块，看看它的配置文件解析，这发生在函数pam_limits.c中的parse_config_file函数。\n\n```c++\n// pam_limits.c\nstatic int\nparse_config_file(pam_handle_t *pamh, const char *uname, uid_t uid, gid_t gid,\n     int ctrl, struct pam_limit_s *pl)\n{\n    FILE *fil;\n    char buf[LINE_LENGTH]; // #define LINE_LENGTH 1024\n    // 以只读方式打开limits.conf\n\t\tfil = fopen(CONF_FILE, \"r\");\n\t\tif (fil == NULL) {\n    pam_syslog (pamh, LOG_WARNING,\n\"cannot read settings from %s: %m\", CONF_FILE);\n    return PAM_SERVICE_ERR;\n}\n\n/* start the show */\n// 一行行遍历limits.conf\nwhile (fgets(buf, LINE_LENGTH, fil) != NULL) {\n    line = buf;\n    /* skip the leading white space */\n    while (*line && isspace(*line)) // 跳过空行\n        line++;\n        \n    /* Rip off the comments */\n    tptr = strchr(line,'#'); // 去掉注释\n    if (tptr)\n        *tptr = '\\0';\n    /* Rip off the newline char */\n    tptr = strchr(line,'\\n'); // 删除换行符，注意并不包括回车符\n    if (tptr)\n        *tptr = '\\0';\n    /* Anything left ? */\n    if (!strlen(line)) // 经过上面几步折腾，可能成了空行\n        continue;\n    \n    // 直接调用sscanf解析配置项\n    //\n    // 配置行示例：\n    // * soft nofile 100000\n    //\n    // domain：作用域名，“*”表示对所有用户有效\n    i = sscanf(line,\"%s%s%s%s\", domain, ltype, item, value);\n    。。。。。。\n    // 下面只看两个常用配置：domain配置为“*”或指定的用户名\n    // 可以看到在加载limits.conf，主要是设置输出参数pl的值。\n    // 而parse_config_file由pam_sm_open_session调用，亦即模块被加载时被调用。\n    //\n    // 也因此修改limits.conf是不能立即生效的，\n    // 除非重启该进程，而子进程又继承父进程的设置。\n    //\n    // 假设程序跑在crontab中，则应重启crond进程，\n    // 比如CentOS中重启crond：service crond restart\n    // 虽然crontab中的进程是由crond拉起来的，但它并加载PAM模块，\n    // 原因是crond在拉起子进程时，对子进程关闭了所有描述符。\n    //\n    // process_limit针对当前调用进程进行limit设置\n    if (strcmp(domain, \"*\") == 0)\n        // limit was set by a default entry\n        process_limit(pamh, LIMITS_DEF_DEFAULT, ltype, item, value, ctrl, pl);\n    。。。。。。        \n    if (strcmp(uname, domain) == 0) /* this user have a limit */\n        // limit was set by an user entry\n        process_limit(pamh, LIMITS_DEF_USER, ltype, item, value, ctrl, pl);\n}\n}\n```\n# 生效limits.conf\n\n加载PAM模块时，即会生效limits.conf，因为这个在pam_sm_open_session就已执行了：\n\n```c++\n/* now the session stuff */\nint\npam_sm_open_session (pam_handle_t *pamh, int flags UNUSED,\n     int argc, const char **argv)\n{\n    struct pam_limit_s plstruct;\n    struct pam_limit_s *pl = &plstruct;\n    。。。。。。\n    // 调用parse_config_file解析limits.conf，\n    // 配置行解析结果存储在pl中（亦即plstruct）\n    retval = parse_config_file(pamh, pwd->pw_name, pwd->pw_uid, pwd->pw_gid, ctrl, pl);\n    。。。。。。\n    // 使配置立即生效（setup_limits调用系统函数setrlimit）\n    retval = setup_limits(pamh, pwd->pw_name, pwd->pw_uid, ctrl, pl);\n    。。。。。。\n    return PAM_SUCCESS;\n}\n```\n\n模块pam_limits.so是由PAM模块libpam.so加载的，crond加载的只是libpam.so。“/etc/pam.d”目录下的文件什么时候生效？加载libpam.so时生效：\n\n```c++\n// pam_start.c\nint pam_start (\n    const char *service_name,\n    const char *user,\n    const struct pam_conv *pam_conversation,\n    pam_handle_t **pamh)\n{\n    。。。。。。\n    if ( _pam_init_handlers(*pamh) != PAM_SUCCESS ) {\n    。。。。。。\n}\n\n// pam_handlers.c\nint _pam_init_handlers(pam_handle_t *pamh)\n{\n    。。。。。。\n    // 函数_pam_parse_conf_file负责解析libpam.so的配置文件，\n    // 这些配置文件一般位于目录/etc/pam.d下，如：\n    // # ls -l /etc/pam.d/pass*\n    // -rw-r--r-- 1 root root 188 6月  10 2014 /etc/pam.d/passwd\n    // -rw-r--r-- 1 root root 974 12月 29 2016 /etc/pam.d/password-auth\n    retval = _pam_parse_conf_file(pamh, f, NULL, PAM_T_ANY, 0);\n    。。。。。。\n}\n```\n\n# systemctl和systemd\n\nCentOS上的systemctl（CentOS-7.X之前为service脚本）类似于Windows平台的服务管理器，替代老版本中的service脚本来管理服务。Systemctl功能非常多，有关systemctl的功能不在本文过多描述。\n\nsytemctl的工作原理是通过与服务systemd交互，来完成各项工作，比如重启crond进程。在CentOS，systemctl替代了inittab。\n\n可以看到正是systemd加载了pam，从ldd结果可以看出systemd也不是动态加载pam模块，而是编译时就绑定了，因此libpam.so成了系统的必须部分（但pam_limits.so仍然不是，总是可插拔）：\n\n## ldd /usr/lib/systemd/systemd\n\n        linux-vdso.so.1 =>  (0x00007ffce5b72000)\n        /$LIB/libonion.so => /lib64/libonion.so (0x00007f2430f56000)\n        libselinux.so.1 => /lib64/libselinux.so.1 (0x00007f2430d31000)\n        libcap.so.2 => /lib64/libcap.so.2 (0x00007f2430b2c000)\n        libpam.so.0 => /lib64/libpam.so.0 (0x00007f243091d000)\n        libaudit.so.1 => /lib64/libaudit.so.1 (0x00007f24306f5000)\n        libkmod.so.2 => /lib64/libkmod.so.2 (0x00007f24304df000)\n        libmount.so.1 => /lib64/libmount.so.1 (0x00007f24302a0000)\n        librt.so.1 => /lib64/librt.so.1 (0x00007f2430098000)\n        libgcc_s.so.1 => /lib64/libgcc_s.so.1 (0x00007f242fe82000)\n        libpthread.so.0 => /lib64/libpthread.so.0 (0x00007f242fc66000)\n        libc.so.6 => /lib64/libc.so.6 (0x00007f242f8a2000)\n        /lib64/ld-linux-x86-64.so.2 (0x00007f243105c000)\n        libdl.so.2 => /lib64/libdl.so.2 (0x00007f242f69e000)\n        libpcre.so.1 => /lib64/libpcre.so.1 (0x00007f242f43d000)\n        liblzma.so.5 => /lib64/liblzma.so.5 (0x00007f242f218000)\n        libattr.so.1 => /lib64/libattr.so.1 (0x00007f242f013000)\n        libcap-ng.so.0 => /lib64/libcap-ng.so.0 (0x00007f242ee0d000)\n        libz.so.1 => /lib64/libz.so.1 (0x00007f242ebf7000)\n        libblkid.so.1 => /lib64/libblkid.so.1 (0x00007f242e9ba000)\n        libuuid.so.1 => /lib64/libuuid.so.1 (0x00007f242e7b5000)\n\n## ldd /usr/sbin/crond\n\n        linux-vdso.so.1 =>  (0x00007ffef31a5000)\n        /$LIB/libonion.so => /lib64/libonion.so (0x00007f87b89e5000)\n        libselinux.so.1 => /lib64/libselinux.so.1 (0x00007f87b8416000)\n        libpam.so.0 => /lib64/libpam.so.0 (0x00007f87b8207000)\n        libdl.so.2 => /lib64/libdl.so.2 (0x00007f87b8003000)\n        libaudit.so.1 => /lib64/libaudit.so.1 (0x00007f87b7ddb000)\n        libc.so.6 => /lib64/libc.so.6 (0x00007f87b7a17000)\n        libpcre.so.1 => /lib64/libpcre.so.1 (0x00007f87b77b6000)\n        liblzma.so.5 => /lib64/liblzma.so.5 (0x00007f87b7591000)\n        /lib64/ld-linux-x86-64.so.2 (0x00007f87b88cc000)\n        libcap-ng.so.0 => /lib64/libcap-ng.so.0 (0x00007f87b738b000)\n        libpthread.so.0 => /lib64/libpthread.so.0 (0x00007f87b716f000)\n\n\n实际上，systemd为Linux系统（CentOS如此，像Ubuntu未必）的第一个进程，取代了以前的init进程，可以看到systemd进程和init进程不会同时存在，低版本为init，高版本为systemd。Ubuntu使用的是upstart，但也可能用systemd替代upstart。\n\n在systemd源代码的编译文件meson.build（类似于CMake的CMakeLists.txt文件，或bazel的BUILD文件）中可以看到systemd对libpam的依赖。\n\n \n\nsystemctl部分用法：\n\n1) 重启crond\n\n## systemctl restart crond\n\n2) 显示系统状态\n\n## systemctl status\n\n● Jian.mooon\n    State: degraded\n     Jobs: 0 queued\n   Failed: 2 units\n    Since: 二 2017-10-24 02:38:50 CST; 1 years 3 months ago\n   CGroup: /\n   。。。。。。\n\n3) 重启系统\n\n## systemctl reboot\n\n\n4) 关闭电源\n\n## systemctl poweroff\n\n\n5) 待机\n\n## systemctl suspend\n\n6) 休眠\n\n## systemctl hibernate\n\n\n有关systemctl的更多信息，可浏览：\n\nhttps://wiki.archlinux.org/index.php/systemd_(简体中文)。\n\n# 总结\n\n修改limits.conf不会立即生效，除非重启相关的父进程，比如crontab的crond，而有些老版本的Linux可能只能重启以生效。\n\n1) 系统启动 -> 启动初始化进程systemd -> 进程sytemd加载libpam.so模块\n2) libpam.so根据/etc/pam.d决定是否加载pam_limits.so等\n3) 在加载pam_limits.so时，会读取/etc/security/limits.conf\n4) 重启crond等，实际是向systemd发重启指令\n5) 一句话：如果要使用limits.conf生效，一定要有加载pam_limits.so，如果修改limits.conf，至少要让pam_limits.so重读limits.conf。\n附1：资源\n\n1) PAM官方\n\nhttp://linux-pam.org/\n\n2) PAM源代码\n\nhttps://github.com/linux-pam/linux-pam/releases\n\n3) systemd源代码\n\nhttps://github.com/systemd/systemd（使用meson编译，Meson is an open source build system，依赖ninja）\n\n4) Vixie-cron源代码\n\nhttp://ftp.isc.org/isc/cron/\n\nhttps://github.com/svagner/vixie-cron\n\nftp://ftp.riken.jp/Linux/cern/updates/slc52/SRPMS/repoview/vixie-cron.html\n\n附2：编译ninja\n\nninja类似于make，使用meson之前必须先准备好ninja。\n\n1) 从https://github.com/ninja-build/ninja下载ninja源代码\n\n2) 解压源代码包，然后进入解压后的目录\n\n3) 执行“./configure.py --bootstrap”\n\n4) 成功后会在目录下生成名为ninja的可执行程序文件\n\n5) 将可执行程序文件复制到PATH目录下，比如：/usr/local/bin或/usr/bin等目录\n\n6) 完成。\n\n附3：使用meson编译systemd\n\nMeson-0.49.1要求3.5或更高版本的Python（https://www.python.org/），和1.5或更高版本的Ninja，还依赖gperf（简单安装：yum install -y gperf），还依赖libcap-dev（执行yum install -y libcap安装，如果仍然不行，从https://git.kernel.org/pub/scm/linux/kernel/git/morgan/libcap.git/下载源代码安装），除此之外还有一些其它的依赖，需逐个解决。\n\n1) 从https://github.com/mesonbuild/meson下载meson源代码\n\n2) 解压后，将meson目录添加到PATH中，比如：export PATH=/root/X/meson-0.49.1:$PATH\n\n3) 进入systemd源代码目录\n\n4) 执行“meson.py build”（如果出错，可能是Python版本不够）\n\n5) 成功后会生成build子目录\n\n6) 进入build目录，执行ninja开始编译（ninja类似于make）\n\n附4：安装Python-3.7.2\n\nPython-3.7.2采用automake编译：\n\n1) 执行configure生成Makefile文件：./configure --prefix=/usr/local/Python-3.7.2\n\n2) 执行make开始编译Python（编译时间会有点长）\n\n3) 执行make install，安装Python（安装时间稍有点长）\n\n4) 将Python的bin目录加入到PATH中，如：export PATH=/usr/local/Python-3.7.2/bin:$PATH\n\n5) 可以开始使用Python-3.7.2了。\n\n \n\n如果遇到错误“ModuleNotFoundError: No module named '_ctypes'”，是因为依赖的libffi-devel版本不够（可执行“yum install -y libffi-devel”安装libffi，或源码方式安装libffi）。\n\n附5：安装libcap\n\n1) 从https://git.kernel.org/pub/scm/linux/kernel/git/morgan/libcap.git/下载源代码包\n\n2) 解压后进入解压目录\n\n3) 执行make编译\n\n4) 执行make install安装\n\n5) 完成。\n\n------------------------------------------------\n版权声明：本文为CSDN博主「一见」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/Aquester/article/details/86694644","content":"<p>目录 </p>\n<ol>\n<li><p>前言 1</p>\n</li>\n<li><p>PAM 2</p>\n</li>\n<li><p>pam_limits 2</p>\n</li>\n<li><p>limits.conf的由来 3</p>\n</li>\n<li><p>模块入口函数 4</p>\n</li>\n<li><p>解析limits.conf 6</p>\n</li>\n<li><p>生效limits.conf 7</p>\n</li>\n<li><p>systemctl和systemd 8</p>\n</li>\n<li><p>总结 10</p>\n</li>\n</ol>\n<p>附1：资源 11</p>\n<p>附2：编译ninja 11</p>\n<p>附3：使用meson编译systemd 11</p>\n<p>附4：安装Python-3.7.2 12</p>\n<p>附5：安装libcap 12</p>\n <a id=\"more\"></a>\n\n<h1 id=\"前言\">前言<a href=\"posts/源码解读Linux的limits-conf文件#前言\"></a></h1><p>本文不一定适合比较老版本的Linux，如果只关心使用，请直接看“总结”，本文主要针对CentOS，其它Linux发行版本类似，但细节可能有出入，比如重启服务可能不是用systemctl，而是service等。</p>\n<p>当需要调整一个进程可打开的最多文件数或SOCKET连接数等，以CentOS为例，通常的做法是修改文件/etc/security/limits.conf，比如将最多可打开数调整为10万：</p>\n<h2 id=\"vi-etc-security-limits-conf\">vi /etc/security/limits.conf<a href=\"posts/源码解读Linux的limits-conf文件#vi-etc-security-limits-conf\"></a></h2><ul>\n<li>soft nofile 100000</li>\n<li>hard nofile 100000</li>\n</ul>\n<p>读取limit.conf文件的并不是Linux内核，而是一个内核模块PAM，对应的模块文件为：</p>\n<p>/usr/lib64/security/pam_limits.so<br>/usr/lib/security/pam_limits.so</p>\n<p>而/etc/pam.d目录下的配置文件，则由libpam.so读取，实际上所有的模块均由libpam.so加载，可将libpam.so看成是所有PAM模块的框架或容器，而且libpam.so本身也不是内核的组成部分。</p>\n<p>多个不同Linux版本上查看，并没有叫libpam.so的文件名，均是libpam.so.0（不清楚是否所有都这样），但是编译Linux-PAM-1.3.1源代码有名为libpam.so软链接，指向libpam.so.0.84.2。</p>\n<p>/usr/lib64/libpam.so.0 -&gt; libpam.so.0.83.1<br>/usr/lib64/libpam.so.0.83.1<br>/usr/lib64/libpam_misc.so.0.82.0</p>\n<p>/usr/lib/libpam.so.0 -&gt; libpam.so.0.83.1<br>/usr/lib/libpam.so.0.83.1<br>/usr/lib/libpam_misc.so.0.82.0</p>\n<p>libpam.so会被加载到crond等进程空间（那当然也可以不加载），如果没有加载libpam.so，则limits.conf不会生效。crond等不会主动加载libpam.so，那么是谁让libpam.so进入crond等进程空间的了？（执行“grep libpam /proc/<code>pidof crond</code>/maps”可查看libpam是否在crond的进程空间）。</p>\n<p>在CentOS，可用service来启动或重启crond，所以跟它应当是相关的，而service实际调用的是systemctl这一系统工具（非Shell脚本，service为老版本使用方式，使用systemctl启动和重启服务，使用方式和service相同）。</p>\n<h2 id=\"service-crond-restart\">service crond restart<a href=\"posts/源码解读Linux的limits-conf文件#service-crond-restart\"></a></h2><p>Redirecting to /bin/systemctl restart  crond.service</p>\n<h2 id=\"file-bin-systemctl\">file /bin/systemctl<a href=\"posts/源码解读Linux的limits-conf文件#file-bin-systemctl\"></a></h2><p>/bin/systemctl: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV)</p>\n<h2 id=\"systemctl-crond-restart-重启crontab服务进程crond\">systemctl crond restart # 重启crontab服务进程crond<a href=\"posts/源码解读Linux的limits-conf文件#systemctl-crond-restart-重启crontab服务进程crond\"></a></h2><h1 id=\"PAM\">PAM<a href=\"posts/源码解读Linux的limits-conf文件#PAM\"></a></h1><p>PAM的全称为“Pluggable Authentication Modules”，即可插入认证模块。最初由太阳微系统公司（Sun Microsystems，已于2009年被甲骨文收购）于1995年在Solaris开发。PAM代码不包含在Linux内核中，并有专门的网站：<a href=\"http://linux-pam.org/，源代码托管在Github上（https://github.com/linux-pam/linux-pam/releases）。\" target=\"_blank\" rel=\"noopener\">http://linux-pam.org/，源代码托管在Github上（https://github.com/linux-pam/linux-pam/releases）。</a></p>\n<h1 id=\"pam-limits\">pam_limits<a href=\"posts/源码解读Linux的limits-conf文件#pam-limits\"></a></h1><p>pam_limits是PAM其中的一个模块（模块文件名为pam_limits.so），也是程序员接触较多的模型之一，对应的源代码文件为pam_limits.c，代码规模为几百行，加上所有注释和空格有1100多行：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> !defined(linux) &amp;&amp; !defined(__linux)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">warning</span> THIS CODE IS KNOWN TO WORK ONLY ON LINUX !!!</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></div></figure>\n\n<p>源代码提供autoconf编译，尝试在Linux-3.10上可编译成功：</p>\n<p>~/Linux-PAM-1.3.1]$ ./configure –prefix=/usr/local/Linux-PAM-1.3.1<br>make</p>\n<h1 id=\"limits-conf的由来\">limits.conf的由来<a href=\"posts/源码解读Linux的limits-conf文件#limits-conf的由来\"></a></h1><p>确定模块pam_limits的配置文件，由宏CONF_FILE决定：</p>\n<p>// pam_limits.c</p>\n<p>#define CONF_FILE (pl-&gt;conf_file != NULL)?pl-&gt;conf_file:LIMITS_FILE</p>\n<p>使用的地方：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pam_limits.c</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span></span><br><span class=\"line\">parse_config_file(<span class=\"keyword\">pam_handle_t</span> *pamh, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *uname, <span class=\"keyword\">uid_t</span> uid, <span class=\"keyword\">gid_t</span> gid,</span><br><span class=\"line\">     <span class=\"keyword\">int</span> ctrl, struct pam_limit_s *pl)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    FILE *fil;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[LINE_LENGTH];</span><br><span class=\"line\"><span class=\"comment\">/* check for the LIMITS_FILE */</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (ctrl &amp; PAM_DEBUG_ARG)</span><br><span class=\"line\">    pam_syslog(pamh, LOG_DEBUG, <span class=\"string\">\"reading settings from '%s'\"</span>, CONF_FILE);</span><br><span class=\"line\">fil = fopen(CONF_FILE, <span class=\"string\">\"r\"</span>); <span class=\"comment\">// 打开配置文件，跟参数“pl”有关系</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (fil == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    pam_syslog (pamh, LOG_WARNING,</span><br><span class=\"line\"><span class=\"string\">\"cannot read settings from %s: %m\"</span>, CONF_FILE);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> PAM_SERVICE_ERR;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>如果函数parse_config_file的参数“pl”值为NULL，则配置文件名在编译时决定，这种情况下，配置文件名被固定为limits.conf：</p>\n<h2 id=\"Makefile-am\">Makefile.am<a href=\"posts/源码解读Linux的limits-conf文件#Makefile-am\"></a></h2><p>modules/pam_limits/Makefile.am: -DLIMITS_FILE_DIR=&quot;$(limits_conf_dir)/*.conf&quot; <br>modules/pam_limits/Makefile.am: -DLIMITS_FILE=&quot;$(SCONFIGDIR)/limits.conf&quot;</p>\n<p>只是limits.conf所在目录可由编译时决定，也就是看SCONFIGDIR，决定在automake的configure.ac文件：</p>\n<h2 id=\"configure-ac\">configure.ac<a href=\"posts/源码解读Linux的limits-conf文件#configure-ac\"></a></h2><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AC_ARG_ENABLE(sconfigdir,</span><br><span class=\"line\">        AS_HELP_STRING([--enable-sconfigdir=DIR],[path to <span class=\"keyword\">module</span> conf files @&lt;:@<span class=\"keyword\">default</span>=$sysconfdir/security@:&gt;@]),</span><br><span class=\"line\">        SCONFIGDIR=$enableval, SCONFIGDIR=$sysconfdir/security)</span><br><span class=\"line\">AC_SUBST(SCONFIGDIR)</span><br><span class=\"line\"></span><br><span class=\"line\">dnl <span class=\"keyword\">and</span> some hacks to use /etc <span class=\"keyword\">and</span> /lib</span><br><span class=\"line\">test <span class=\"string\">\"$&#123;prefix&#125;\"</span> = <span class=\"string\">\"NONE\"</span> &amp;&amp; prefix=<span class=\"string\">\"/usr\"</span></span><br><span class=\"line\">if test $&#123;prefix&#125; = '/usr'</span><br><span class=\"line\">then</span><br><span class=\"line\">dnl If we use /usr as prefix, use /etc <span class=\"keyword\">for</span> config files</span><br><span class=\"line\">        if test $&#123;sysconfdir&#125; = '$&#123;prefix&#125;/etc'</span><br><span class=\"line\">        then</span><br><span class=\"line\">                sysconfdir=<span class=\"string\">\"/etc\"</span></span><br><span class=\"line\">        fi</span><br></pre></td></tr></table></div></figure>\n\n<p>推导出默认为“/etc/security/limits.conf”，但从前面的分析，可看到实际还可参数动态指定，这个参数怎么来？可进入Linux的/etc/pam.d目录，找一个看一看：</p>\n<h2 id=\"vi-etc-pam-d-login\">vi /etc/pam.d/login<a href=\"posts/源码解读Linux的limits-conf文件#vi-etc-pam-d-login\"></a></h2><p>session    required     pam_selinux.so close<br>session    required     pam_selinux.so open</p>\n<p>上述最后一个配置项即为模型的参数值，参数值可有0、一个或多个。通常pam_limits.so使用默认参数值，因此它的配置文件limits.conf完整路径为：/etc/security/limits.conf。</p>\n<h1 id=\"模块入口函数\">模块入口函数<a href=\"posts/源码解读Linux的limits-conf文件#模块入口函数\"></a></h1><p>会话（Session）类的PAM模块的入口函数均为pam_sm_open_session（授权类的为pam_sm_authenticate，密码类的为pam_sm_chauthtok），意为创建（打开）一个会话：</p>\n<p>int<br>pam_sm_open_session (pam_handle_t <em>pamh, int flags UNUSED, int argc, const char *</em>argv);<br>// libpam/pam_handlers.c:  sym = “pam_sm_open_session”;</p>\n<p>加载模块在pam_handlers.c中完成，实际上一个模块可加载多次（可在/etc/security下看到有些配置文件中同一模型有多行）。类似于iptables，每加载一次创建一个handler，依次组成一个handler调用链（实际由配置文件中的每一行配置组成链）：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pam_handlers.c</span></span><br><span class=\"line\"><span class=\"comment\">// 被_pam_parse_conf_file直接调用，</span></span><br><span class=\"line\"><span class=\"comment\">// 和被_pam_init_handlers、_pam_load_conf_file一级间接调用</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> _pam_add_handler(<span class=\"keyword\">pam_handle_t</span> *pamh</span><br><span class=\"line\">     , <span class=\"keyword\">int</span> handler_type, <span class=\"keyword\">int</span> other, <span class=\"keyword\">int</span> stack_level, <span class=\"keyword\">int</span> type</span><br><span class=\"line\">     , <span class=\"keyword\">int</span> *actions, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *mod_path</span><br><span class=\"line\">     , <span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> **argv, <span class=\"keyword\">int</span> argvlen)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">loaded_module</span> *<span class=\"title\">mod</span> = <span class=\"title\">NULL</span>;</span></span><br><span class=\"line\">    。。。。。。</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((handler_type == PAM_HT_MODULE ||</span><br><span class=\"line\">         handler_type == PAM_HT_SILENT_MODULE) &amp;&amp;</span><br><span class=\"line\">        mod_path != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (mod_path[<span class=\"number\">0</span>] == <span class=\"string\">'/'</span>) &#123;</span><br><span class=\"line\">    mod = _pam_load_module(pamh, mod_path, handler_type);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (asprintf(&amp;mod_full_path, <span class=\"string\">\"%s%s\"</span>,</span><br><span class=\"line\">     DEFAULT_MODULE_PATH, mod_path) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    mod = _pam_load_module(pamh, mod_full_path, handler_type);</span><br><span class=\"line\">    _pam_drop(mod_full_path);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    pam_syslog(pamh, LOG_CRIT, <span class=\"string\">\"cannot malloc full mod path\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> PAM_ABORT;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (mod == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* if we get here with NULL it means allocation error */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> PAM_ABORT;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    。。。。。。</span><br><span class=\"line\">        <span class=\"comment\">/* point handler_p's at the root addresses of the function stacks */</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (type) &#123;</span><br><span class=\"line\">        。。。。。。</span><br><span class=\"line\">        <span class=\"keyword\">case</span> PAM_T_SESS:</span><br><span class=\"line\">            handler_p = &amp;the_handlers-&gt;open_session;</span><br><span class=\"line\">            sym = <span class=\"string\">\"pam_sm_open_session\"</span>;</span><br><span class=\"line\">            handler_p2 = &amp;the_handlers-&gt;close_session;</span><br><span class=\"line\">            sym2 = <span class=\"string\">\"pam_sm_close_session\"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        。。。。。。</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> ((mod_type == PAM_MT_DYNAMIC_MOD) &amp;&amp;</span><br><span class=\"line\">    !(func = _pam_dlsym(mod-&gt;dl_handle, sym)) ) &#123;</span><br><span class=\"line\">    pam_syslog(pamh, LOG_ERR, <span class=\"string\">\"unable to resolve symbol: %s\"</span>, sym);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">。。。。。。</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>每个模块的结果可能是成功PAM_SUCCESS(0)，全定义在文件libpam/include/security/_pam_types.h中，下列展示小部分：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* ----------------- The Linux-PAM return values ------------------ */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PAM_SUCCESS 0 <span class=\"comment\">/* Successful function return */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PAM_OPEN_ERR 1 <span class=\"comment\">/* dlopen() failure when dynamically */</span></span></span><br><span class=\"line\"><span class=\"comment\">/* loading a service module */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PAM_SYMBOL_ERR 2 <span class=\"comment\">/* Symbol not found */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PAM_SERVICE_ERR 3 <span class=\"comment\">/* Error in service module */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PAM_SYSTEM_ERR 4 <span class=\"comment\">/* System error */</span></span></span><br></pre></td></tr></table></div></figure>\n\n<h1 id=\"解析limits-conf\">解析limits.conf<a href=\"posts/源码解读Linux的limits-conf文件#解析limits-conf\"></a></h1><p>重聚焦到pam_limits模块，看看它的配置文件解析，这发生在函数pam_limits.c中的parse_config_file函数。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pam_limits.c</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span></span><br><span class=\"line\">parse_config_file(<span class=\"keyword\">pam_handle_t</span> *pamh, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *uname, <span class=\"keyword\">uid_t</span> uid, <span class=\"keyword\">gid_t</span> gid,</span><br><span class=\"line\">     <span class=\"keyword\">int</span> ctrl, struct pam_limit_s *pl)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    FILE *fil;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[LINE_LENGTH]; <span class=\"comment\">// #define LINE_LENGTH 1024</span></span><br><span class=\"line\">    <span class=\"comment\">// 以只读方式打开limits.conf</span></span><br><span class=\"line\">\t\tfil = fopen(CONF_FILE, <span class=\"string\">\"r\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (fil == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    pam_syslog (pamh, LOG_WARNING,</span><br><span class=\"line\"><span class=\"string\">\"cannot read settings from %s: %m\"</span>, CONF_FILE);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> PAM_SERVICE_ERR;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* start the show */</span></span><br><span class=\"line\"><span class=\"comment\">// 一行行遍历limits.conf</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (fgets(buf, LINE_LENGTH, fil) != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    line = buf;</span><br><span class=\"line\">    <span class=\"comment\">/* skip the leading white space */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (*line &amp;&amp; <span class=\"built_in\">isspace</span>(*line)) <span class=\"comment\">// 跳过空行</span></span><br><span class=\"line\">        line++;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\">/* Rip off the comments */</span></span><br><span class=\"line\">    tptr = <span class=\"built_in\">strchr</span>(line,<span class=\"string\">'#'</span>); <span class=\"comment\">// 去掉注释</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tptr)</span><br><span class=\"line\">        *tptr = <span class=\"string\">'\\0'</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* Rip off the newline char */</span></span><br><span class=\"line\">    tptr = <span class=\"built_in\">strchr</span>(line,<span class=\"string\">'\\n'</span>); <span class=\"comment\">// 删除换行符，注意并不包括回车符</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tptr)</span><br><span class=\"line\">        *tptr = <span class=\"string\">'\\0'</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* Anything left ? */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">strlen</span>(line)) <span class=\"comment\">// 经过上面几步折腾，可能成了空行</span></span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 直接调用sscanf解析配置项</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// 配置行示例：</span></span><br><span class=\"line\">    <span class=\"comment\">// * soft nofile 100000</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// domain：作用域名，“*”表示对所有用户有效</span></span><br><span class=\"line\">    i = <span class=\"built_in\">sscanf</span>(line,<span class=\"string\">\"%s%s%s%s\"</span>, domain, ltype, item, value);</span><br><span class=\"line\">    。。。。。。</span><br><span class=\"line\">    <span class=\"comment\">// 下面只看两个常用配置：domain配置为“*”或指定的用户名</span></span><br><span class=\"line\">    <span class=\"comment\">// 可以看到在加载limits.conf，主要是设置输出参数pl的值。</span></span><br><span class=\"line\">    <span class=\"comment\">// 而parse_config_file由pam_sm_open_session调用，亦即模块被加载时被调用。</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// 也因此修改limits.conf是不能立即生效的，</span></span><br><span class=\"line\">    <span class=\"comment\">// 除非重启该进程，而子进程又继承父进程的设置。</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// 假设程序跑在crontab中，则应重启crond进程，</span></span><br><span class=\"line\">    <span class=\"comment\">// 比如CentOS中重启crond：service crond restart</span></span><br><span class=\"line\">    <span class=\"comment\">// 虽然crontab中的进程是由crond拉起来的，但它并加载PAM模块，</span></span><br><span class=\"line\">    <span class=\"comment\">// 原因是crond在拉起子进程时，对子进程关闭了所有描述符。</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// process_limit针对当前调用进程进行limit设置</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(domain, <span class=\"string\">\"*\"</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// limit was set by a default entry</span></span><br><span class=\"line\">        process_limit(pamh, LIMITS_DEF_DEFAULT, ltype, item, value, ctrl, pl);</span><br><span class=\"line\">    。。。。。。        </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(uname, domain) == <span class=\"number\">0</span>) <span class=\"comment\">/* this user have a limit */</span></span><br><span class=\"line\">        <span class=\"comment\">// limit was set by an user entry</span></span><br><span class=\"line\">        process_limit(pamh, LIMITS_DEF_USER, ltype, item, value, ctrl, pl);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h1 id=\"生效limits-conf\">生效limits.conf<a href=\"posts/源码解读Linux的limits-conf文件#生效limits-conf\"></a></h1><p>加载PAM模块时，即会生效limits.conf，因为这个在pam_sm_open_session就已执行了：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* now the session stuff */</span></span><br><span class=\"line\"><span class=\"keyword\">int</span></span><br><span class=\"line\">pam_sm_open_session (<span class=\"keyword\">pam_handle_t</span> *pamh, <span class=\"keyword\">int</span> flags UNUSED,</span><br><span class=\"line\">     <span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **argv)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pam_limit_s</span> <span class=\"title\">plstruct</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pam_limit_s</span> *<span class=\"title\">pl</span> = &amp;<span class=\"title\">plstruct</span>;</span></span><br><span class=\"line\">    。。。。。。</span><br><span class=\"line\">    <span class=\"comment\">// 调用parse_config_file解析limits.conf，</span></span><br><span class=\"line\">    <span class=\"comment\">// 配置行解析结果存储在pl中（亦即plstruct）</span></span><br><span class=\"line\">    retval = parse_config_file(pamh, pwd-&gt;pw_name, pwd-&gt;pw_uid, pwd-&gt;pw_gid, ctrl, pl);</span><br><span class=\"line\">    。。。。。。</span><br><span class=\"line\">    <span class=\"comment\">// 使配置立即生效（setup_limits调用系统函数setrlimit）</span></span><br><span class=\"line\">    retval = setup_limits(pamh, pwd-&gt;pw_name, pwd-&gt;pw_uid, ctrl, pl);</span><br><span class=\"line\">    。。。。。。</span><br><span class=\"line\">    <span class=\"keyword\">return</span> PAM_SUCCESS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>模块pam_limits.so是由PAM模块libpam.so加载的，crond加载的只是libpam.so。“/etc/pam.d”目录下的文件什么时候生效？加载libpam.so时生效：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pam_start.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pam_start</span> <span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *service_name,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *user,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">const</span> struct pam_conv *pam_conversation,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">pam_handle_t</span> **pamh)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    。。。。。。</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( _pam_init_handlers(*pamh) != PAM_SUCCESS ) &#123;</span><br><span class=\"line\">    。。。。。。</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// pam_handlers.c</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> _pam_init_handlers(<span class=\"keyword\">pam_handle_t</span> *pamh)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    。。。。。。</span><br><span class=\"line\">    <span class=\"comment\">// 函数_pam_parse_conf_file负责解析libpam.so的配置文件，</span></span><br><span class=\"line\">    <span class=\"comment\">// 这些配置文件一般位于目录/etc/pam.d下，如：</span></span><br><span class=\"line\">    <span class=\"comment\">// # ls -l /etc/pam.d/pass*</span></span><br><span class=\"line\">    <span class=\"comment\">// -rw-r--r-- 1 root root 188 6月  10 2014 /etc/pam.d/passwd</span></span><br><span class=\"line\">    <span class=\"comment\">// -rw-r--r-- 1 root root 974 12月 29 2016 /etc/pam.d/password-auth</span></span><br><span class=\"line\">    retval = _pam_parse_conf_file(pamh, f, <span class=\"literal\">NULL</span>, PAM_T_ANY, <span class=\"number\">0</span>);</span><br><span class=\"line\">    。。。。。。</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h1 id=\"systemctl和systemd\">systemctl和systemd<a href=\"posts/源码解读Linux的limits-conf文件#systemctl和systemd\"></a></h1><p>CentOS上的systemctl（CentOS-7.X之前为service脚本）类似于Windows平台的服务管理器，替代老版本中的service脚本来管理服务。Systemctl功能非常多，有关systemctl的功能不在本文过多描述。</p>\n<p>sytemctl的工作原理是通过与服务systemd交互，来完成各项工作，比如重启crond进程。在CentOS，systemctl替代了inittab。</p>\n<p>可以看到正是systemd加载了pam，从ldd结果可以看出systemd也不是动态加载pam模块，而是编译时就绑定了，因此libpam.so成了系统的必须部分（但pam_limits.so仍然不是，总是可插拔）：</p>\n<h2 id=\"ldd-usr-lib-systemd-systemd\">ldd /usr/lib/systemd/systemd<a href=\"posts/源码解读Linux的limits-conf文件#ldd-usr-lib-systemd-systemd\"></a></h2><pre><code>linux-vdso.so.1 =&gt;  (0x00007ffce5b72000)\n/$LIB/libonion.so =&gt; /lib64/libonion.so (0x00007f2430f56000)\nlibselinux.so.1 =&gt; /lib64/libselinux.so.1 (0x00007f2430d31000)\nlibcap.so.2 =&gt; /lib64/libcap.so.2 (0x00007f2430b2c000)\nlibpam.so.0 =&gt; /lib64/libpam.so.0 (0x00007f243091d000)\nlibaudit.so.1 =&gt; /lib64/libaudit.so.1 (0x00007f24306f5000)\nlibkmod.so.2 =&gt; /lib64/libkmod.so.2 (0x00007f24304df000)\nlibmount.so.1 =&gt; /lib64/libmount.so.1 (0x00007f24302a0000)\nlibrt.so.1 =&gt; /lib64/librt.so.1 (0x00007f2430098000)\nlibgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00007f242fe82000)\nlibpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007f242fc66000)\nlibc.so.6 =&gt; /lib64/libc.so.6 (0x00007f242f8a2000)\n/lib64/ld-linux-x86-64.so.2 (0x00007f243105c000)\nlibdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f242f69e000)\nlibpcre.so.1 =&gt; /lib64/libpcre.so.1 (0x00007f242f43d000)\nliblzma.so.5 =&gt; /lib64/liblzma.so.5 (0x00007f242f218000)\nlibattr.so.1 =&gt; /lib64/libattr.so.1 (0x00007f242f013000)\nlibcap-ng.so.0 =&gt; /lib64/libcap-ng.so.0 (0x00007f242ee0d000)\nlibz.so.1 =&gt; /lib64/libz.so.1 (0x00007f242ebf7000)\nlibblkid.so.1 =&gt; /lib64/libblkid.so.1 (0x00007f242e9ba000)\nlibuuid.so.1 =&gt; /lib64/libuuid.so.1 (0x00007f242e7b5000)</code></pre><h2 id=\"ldd-usr-sbin-crond\">ldd /usr/sbin/crond<a href=\"posts/源码解读Linux的limits-conf文件#ldd-usr-sbin-crond\"></a></h2><pre><code>linux-vdso.so.1 =&gt;  (0x00007ffef31a5000)\n/$LIB/libonion.so =&gt; /lib64/libonion.so (0x00007f87b89e5000)\nlibselinux.so.1 =&gt; /lib64/libselinux.so.1 (0x00007f87b8416000)\nlibpam.so.0 =&gt; /lib64/libpam.so.0 (0x00007f87b8207000)\nlibdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f87b8003000)\nlibaudit.so.1 =&gt; /lib64/libaudit.so.1 (0x00007f87b7ddb000)\nlibc.so.6 =&gt; /lib64/libc.so.6 (0x00007f87b7a17000)\nlibpcre.so.1 =&gt; /lib64/libpcre.so.1 (0x00007f87b77b6000)\nliblzma.so.5 =&gt; /lib64/liblzma.so.5 (0x00007f87b7591000)\n/lib64/ld-linux-x86-64.so.2 (0x00007f87b88cc000)\nlibcap-ng.so.0 =&gt; /lib64/libcap-ng.so.0 (0x00007f87b738b000)\nlibpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007f87b716f000)</code></pre><p>实际上，systemd为Linux系统（CentOS如此，像Ubuntu未必）的第一个进程，取代了以前的init进程，可以看到systemd进程和init进程不会同时存在，低版本为init，高版本为systemd。Ubuntu使用的是upstart，但也可能用systemd替代upstart。</p>\n<p>在systemd源代码的编译文件meson.build（类似于CMake的CMakeLists.txt文件，或bazel的BUILD文件）中可以看到systemd对libpam的依赖。</p>\n<p>systemctl部分用法：</p>\n<p>1) 重启crond</p>\n<h2 id=\"systemctl-restart-crond\">systemctl restart crond<a href=\"posts/源码解读Linux的limits-conf文件#systemctl-restart-crond\"></a></h2><p>2) 显示系统状态</p>\n<h2 id=\"systemctl-status\">systemctl status<a href=\"posts/源码解读Linux的limits-conf文件#systemctl-status\"></a></h2><p>● Jian.mooon<br>    State: degraded<br>     Jobs: 0 queued<br>   Failed: 2 units<br>    Since: 二 2017-10-24 02:38:50 CST; 1 years 3 months ago<br>   CGroup: /<br>   。。。。。。</p>\n<p>3) 重启系统</p>\n<h2 id=\"systemctl-reboot\">systemctl reboot<a href=\"posts/源码解读Linux的limits-conf文件#systemctl-reboot\"></a></h2><p>4) 关闭电源</p>\n<h2 id=\"systemctl-poweroff\">systemctl poweroff<a href=\"posts/源码解读Linux的limits-conf文件#systemctl-poweroff\"></a></h2><p>5) 待机</p>\n<h2 id=\"systemctl-suspend\">systemctl suspend<a href=\"posts/源码解读Linux的limits-conf文件#systemctl-suspend\"></a></h2><p>6) 休眠</p>\n<h2 id=\"systemctl-hibernate\">systemctl hibernate<a href=\"posts/源码解读Linux的limits-conf文件#systemctl-hibernate\"></a></h2><p>有关systemctl的更多信息，可浏览：</p>\n<p><a href=\"https://wiki.archlinux.org/index.php/systemd_(简体中文)。\" target=\"_blank\" rel=\"noopener\">https://wiki.archlinux.org/index.php/systemd_(简体中文)。</a></p>\n<h1 id=\"总结\">总结<a href=\"posts/源码解读Linux的limits-conf文件#总结\"></a></h1><p>修改limits.conf不会立即生效，除非重启相关的父进程，比如crontab的crond，而有些老版本的Linux可能只能重启以生效。</p>\n<p>1) 系统启动 -&gt; 启动初始化进程systemd -&gt; 进程sytemd加载libpam.so模块<br>2) libpam.so根据/etc/pam.d决定是否加载pam_limits.so等<br>3) 在加载pam_limits.so时，会读取/etc/security/limits.conf<br>4) 重启crond等，实际是向systemd发重启指令<br>5) 一句话：如果要使用limits.conf生效，一定要有加载pam_limits.so，如果修改limits.conf，至少要让pam_limits.so重读limits.conf。<br>附1：资源</p>\n<p>1) PAM官方</p>\n<p><a href=\"http://linux-pam.org/\" target=\"_blank\" rel=\"noopener\">http://linux-pam.org/</a></p>\n<p>2) PAM源代码</p>\n<p><a href=\"https://github.com/linux-pam/linux-pam/releases\" target=\"_blank\" rel=\"noopener\">https://github.com/linux-pam/linux-pam/releases</a></p>\n<p>3) systemd源代码</p>\n<p><a href=\"https://github.com/systemd/systemd（使用meson编译，Meson\" target=\"_blank\" rel=\"noopener\">https://github.com/systemd/systemd（使用meson编译，Meson</a> is an open source build system，依赖ninja）</p>\n<p>4) Vixie-cron源代码</p>\n<p><a href=\"http://ftp.isc.org/isc/cron/\" target=\"_blank\" rel=\"noopener\">http://ftp.isc.org/isc/cron/</a></p>\n<p><a href=\"https://github.com/svagner/vixie-cron\" target=\"_blank\" rel=\"noopener\">https://github.com/svagner/vixie-cron</a></p>\n<p><a href=\"ftp://ftp.riken.jp/Linux/cern/updates/slc52/SRPMS/repoview/vixie-cron.html\" target=\"_blank\" rel=\"noopener\">ftp://ftp.riken.jp/Linux/cern/updates/slc52/SRPMS/repoview/vixie-cron.html</a></p>\n<p>附2：编译ninja</p>\n<p>ninja类似于make，使用meson之前必须先准备好ninja。</p>\n<p>1) 从<a href=\"https://github.com/ninja-build/ninja下载ninja源代码\" target=\"_blank\" rel=\"noopener\">https://github.com/ninja-build/ninja下载ninja源代码</a></p>\n<p>2) 解压源代码包，然后进入解压后的目录</p>\n<p>3) 执行“./configure.py –bootstrap”</p>\n<p>4) 成功后会在目录下生成名为ninja的可执行程序文件</p>\n<p>5) 将可执行程序文件复制到PATH目录下，比如：/usr/local/bin或/usr/bin等目录</p>\n<p>6) 完成。</p>\n<p>附3：使用meson编译systemd</p>\n<p>Meson-0.49.1要求3.5或更高版本的Python（<a href=\"https://www.python.org/），和1.5或更高版本的Ninja，还依赖gperf（简单安装：yum\" target=\"_blank\" rel=\"noopener\">https://www.python.org/），和1.5或更高版本的Ninja，还依赖gperf（简单安装：yum</a> install -y gperf），还依赖libcap-dev（执行yum install -y libcap安装，如果仍然不行，从<a href=\"https://git.kernel.org/pub/scm/linux/kernel/git/morgan/libcap.git/下载源代码安装），除此之外还有一些其它的依赖，需逐个解决。\" target=\"_blank\" rel=\"noopener\">https://git.kernel.org/pub/scm/linux/kernel/git/morgan/libcap.git/下载源代码安装），除此之外还有一些其它的依赖，需逐个解决。</a></p>\n<p>1) 从<a href=\"https://github.com/mesonbuild/meson下载meson源代码\" target=\"_blank\" rel=\"noopener\">https://github.com/mesonbuild/meson下载meson源代码</a></p>\n<p>2) 解压后，将meson目录添加到PATH中，比如：export PATH=/root/X/meson-0.49.1:$PATH</p>\n<p>3) 进入systemd源代码目录</p>\n<p>4) 执行“meson.py build”（如果出错，可能是Python版本不够）</p>\n<p>5) 成功后会生成build子目录</p>\n<p>6) 进入build目录，执行ninja开始编译（ninja类似于make）</p>\n<p>附4：安装Python-3.7.2</p>\n<p>Python-3.7.2采用automake编译：</p>\n<p>1) 执行configure生成Makefile文件：./configure –prefix=/usr/local/Python-3.7.2</p>\n<p>2) 执行make开始编译Python（编译时间会有点长）</p>\n<p>3) 执行make install，安装Python（安装时间稍有点长）</p>\n<p>4) 将Python的bin目录加入到PATH中，如：export PATH=/usr/local/Python-3.7.2/bin:$PATH</p>\n<p>5) 可以开始使用Python-3.7.2了。</p>\n<p>如果遇到错误“ModuleNotFoundError: No module named ‘_ctypes’”，是因为依赖的libffi-devel版本不够（可执行“yum install -y libffi-devel”安装libffi，或源码方式安装libffi）。</p>\n<p>附5：安装libcap</p>\n<p>1) 从<a href=\"https://git.kernel.org/pub/scm/linux/kernel/git/morgan/libcap.git/下载源代码包\" target=\"_blank\" rel=\"noopener\">https://git.kernel.org/pub/scm/linux/kernel/git/morgan/libcap.git/下载源代码包</a></p>\n<p>2) 解压后进入解压目录</p>\n<p>3) 执行make编译</p>\n<p>4) 执行make install安装</p>\n<p>5) 完成。</p>\n<hr>\n<p>版权声明：本文为CSDN博主「一见」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/Aquester/article/details/86694644\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/Aquester/article/details/86694644</a></p>\n","slug":"源码解读Linux的limits-conf文件","updated":"2019-09-10T03:01:00.463Z","comments":true,"link":"posts/源码解读Linux的limits-conf文件","permalink":"https://shuntan.github.io/posts/源码解读Linux的limits-conf文件/","excerpt":"目录 前言 1 PAM 2 pam_limits 2 limits.conf的由来 3 模块入口函数 4 解析limits.conf 6 生效limits.conf 7 systemctl和systemd 8 总结 10 附1：资源 11 附2：编译ninja 11 附3：使用meson编译systemd 11 附4：安装Python-3.7.2 12 附5：安装libcap 12","categories":[{"name":"Linux","slug":"Linux","permalink":"https://shuntan.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://shuntan.github.io/tags/Linux/"}]},{"title":"模版元编程应用","date":"2019-06-19T02:34:15.000Z","path":"posts/模版元编程应用/","text":"1.概述 关于C++11模板元的基本用法和常用技巧，在常规编程中可能很少遇到，那么C++11模版元编程用来解决什么实际问题呢，在实际工程中又该如何应用呢？本文将侧重介绍C++11模板的一些具体应用，向读者展示模版元编程的具体应用。 我们将展示如何通过C++11模版元来实现function_traits、Vairant类型和泛型bind绑定器。function_traits侧重于如何萃取可调用对象的一些元信息，Variant则是一种能接受多种类型数据的“万能”类型，bind则是一个泛化的绑定器，下面来看看这些具体的例子。 类型萃取 C++模板中的类型参数T是抽象的，我们并不能在模板内部直接获得它的具体特征。类型萃取（抽取）技术就是要抽取类型的一些具体特征(trait)，比如它是哪种具体类型，它是引用类型，内建类型，还是类类型等。可见，类型萃取技术其实就是trait模板技术的具体体现。获取类型的具体特征在Java、C#等语言中也称为反射(reflection)，C++中通过模板技术也可以实现一定的反射行为。 类型信息是编译期的实体，现在要针对类型来进行编程，这其实就是模板元编程的一个方面。我们平常使用的if/else，while，for等基本的逻辑结构都是运行期的行为，在面向类型的编程中并不能使用，这就需要用到一些特殊的模板技术。实现类型萃取要用到的基本思想一个是特化，一个就是用typedef来携带类型信息。实际上，我们在用模板做设计时，一般建议在模板定义内部，为模板的每个类型参数提供typedef定义，这样在泛型代码中可以很容易地访问或抽取这些类型。 在C和C++中，普通的函数可以称为值函数，它们接受的参数是某些值，返回的结果也是值。而所谓的类型函数接受的实参是类型，返回的是被抽取出来的类型或常量值等（即用typedef定义的类型别名，一般不同的具体类型都定义统一的别名）。如类模板就是类型函数，sizeof是内建的类型函数，返回给定类型实参的大小。在类型编程中，很多地方都要用到sizeof。//下面演示一些有用的类型萃取实现，这些都是类型函数。 2.function_traits function_traits用来获取函数语义的可调用对象的一些属性，比如函数类型、返回类型、函数指针类型和参数类型等。下面来看看如何实现function_traits。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;functional&gt;template&lt;typename T&gt;struct function_traits;//普通函数萃取template&lt;typename Ret, typename... Args&gt;struct function_traits&lt;Ret(Args...)&gt;&#123;public: enum &#123; arity = sizeof...(Args) &#125;; typedef Ret function_type(Args...); typedef Ret return_type; using stl_function_type = std::function&lt;function_type&gt;; typedef Ret(*pointer)(Args...); template&lt;size_t I&gt; struct args &#123; static_assert(I &lt; arity, \"index is out of range, index must less than sizeof Args\"); using type = typename std::tuple_element&lt;I, std::tuple&lt;Args...&gt;&gt;::type; &#125;;&#125;;//类函数萃取template&lt;typename Ret, typename Class, typename... Args&gt;struct function_traits&lt;Ret(Class::*) (Args...)&gt;&#123;public: enum &#123; arity = sizeof...(Args) &#125;; typedef Ret function_type(Args...); typedef Ret return_type; using stl_function_type = std::function&lt;function_type&gt;; typedef Ret(Class::* pointer)(Args...); typedef Class class_type; template&lt;size_t I&gt; struct args &#123; static_assert(I &lt; arity, \"index is out of range, index must less than sizeof Args\"); using type = typename std::tuple_element&lt;I, std::tuple&lt;Args...&gt;&gt;::type; &#125;;&#125;;//函数指针template&lt;typename Ret, typename... Args&gt;struct function_traits&lt;Ret(*)(Args...)&gt; : function_traits&lt;Ret(Args...)&gt; &#123;&#125;;//std::functiontemplate &lt;typename Ret, typename... Args&gt;struct function_traits&lt;std::function&lt;Ret(Args...)&gt;&gt; : function_traits&lt;Ret(Args...)&gt; &#123;&#125;;//member functiontemplate &lt;typename ReturnType, typename ClassType, typename... Args&gt;struct function_traits&lt;ReturnType(ClassType::*)(Args...) const&gt; : function_traits&lt;ReturnType(ClassType::*)(Args...)&gt; &#123;&#125;;//函数对象template&lt;typename Callable&gt;struct function_traits : function_traits&lt;decltype(&amp;Callable::operator())&gt; &#123;&#125;; 由于可调用对象可能是普通的函数、函数指针、lambda、std::function和成员函数，所以我们需要针对这些类型分别做偏特化，然后萃取出可调用对象的元信息。其中，成员函数的偏特化稍微复杂一点，因为涉及到cv符的处理，这里通过定义一个宏来消除重复的模板类定义。参数类型的获取我们是借助于tuple，将参数转换为tuple类型，然后根据索引来获取对应类型。它的用法比较简单： 1234567891011121314151617181920212223242526272829303132333435363738394041424344//类函数struct S&#123; inline void fun(const char*) &#123;&#125;;&#125;;//普通函数double fun() &#123; return 0.1; &#125;;template&lt;typename T&gt;void PrintType()&#123; std::cout &lt;&lt; typeid(T).name() &lt;&lt; std::endl;&#125;int main()&#123; void (S::* cfptr)(const char*) = &amp;S::fun; // class fnptr double (*fptr)() = fun; //fnptr std::function&lt;int(int)&gt; f = [](int a) &#123;return a; &#125;; //function auto lambda = [](int a) &#123;return a; &#125;; // lambda //打印函数类型 PrintType&lt;function_traits&lt;decltype(fptr)&gt;::function_type&gt;(); //将输出double __cdecl&lt;void&gt; //打印类函数指针类型 PrintType&lt;function_traits&lt;decltype(&amp;cfptr)&gt;::pointer&gt;(); //将输出void &lt;__thiscall S::*&gt;&lt;char const *&gt; //打印函数的第一个参数类型 PrintType&lt;function_traits&lt;std::function&lt;int(bool)&gt;&gt;::args&lt;0&gt;::type&gt;();//将输出bool //打印函数的返回类型 PrintType&lt;function_traits&lt;decltype(f)&gt;::return_type&gt;(); //将输出int //打印函数指针类型 PrintType&lt;function_traits&lt;decltype(f)&gt;::pointer&gt;(); //将输出int &lt;__cdecl*&gt;&lt;int&gt; //打印function函数类型 PrintType&lt;function_traits&lt;decltype(f)&gt;::stl_function_type&gt;(); //将输出class std::function&lt;int __cdecl&lt;int&gt;&gt; //lambda =&gt; 隐式转化为了匿名类对象 PrintType&lt;function_traits&lt;decltype(lambda)&gt;::class_type&gt;(); //将输出class &lt;lambda_13vr3tgewf32rt23rfgt435g41239da&gt;&#125; gun gcc下： 1234567FdvEbiPFiiESt8functionIFiiEEZ4mainEUliE0_M1SFvPKcE Visual studio下： 1234567double __cdecl(void)void (__thiscall S::*)(char const *)boolintint (__cdecl*)(int)class std::function&lt;int __cdecl(int)&gt;class &lt;lambda_173ed6f42b6e4df55bf9ec2e4778d93a&gt; 其实结果是一样的，至于为什么可以参考这里 可以看到这个function_traits通过类型萃取，可以很方便地获取可调用对象（函数、函数指针、函数对象、std::function和lambda表达式）的一些元信息，功能非常强大，这个function_traits经常会用到是更高层模版元程序的基础。比如Variant类型的实现就要用到这个function_traits，下面来看看Variant的实现。 3.Variant 借助上面的function_traits和前文实现的一些元函数，我们就能方便的实现一个“万能类型”—Variant，Variant实际上一个泛化的类型，这个Variant和boost.variant的用法类似，需要预定义一些类型作为可接受的类型。boost.variant的基本用法如下： 1234typedef variant&lt;int,char, double&gt; vt;vt v = 1;v = 'a';v = 12.32; 这个variant可以接受已经定义的那些类型，看起来有点类似于c#和java中的object类型，实际上variant是擦除了类型，要获取它的实际类型的时候就稍显麻烦，需要通过boost.visitor来访问： 12345678910111213141516171819202122232425struct VariantVisitor : public boost::static_visitor&lt;void&gt;&#123; void operator() (int a) &#123; cout &lt;&lt; \"int\" &lt;&lt; endl; &#125; void operator() (short val) &#123; cout &lt;&lt; \"short\" &lt;&lt; endl; &#125; void operator() (double val) &#123; cout &lt;&lt; \"double\" &lt;&lt; endl; &#125; void operator() (std::string val) &#123; cout &lt;&lt; \"string\" &lt;&lt; endl; &#125;&#125;;boost::variant&lt;int,short,double,std::string&gt; v = 1;boost::apply_visitor(visitor, v); //将输出int ​ 通过C++11模版元实现的Variant将改进值的获取，将获取实际值的方式改为内置的，即通过下面的方式来访问： 123typedef Variant&lt;int, double, string, int&gt; cv;cv v = 10;v.Visit([&amp;](double i)&#123;cout &lt;&lt; i &lt;&lt; endl; &#125;, [](short i)&#123;cout &lt;&lt; i &lt;&lt; endl; &#125;, [=](int i)&#123;cout &lt;&lt; i &lt;&lt; endl; &#125;,[](const string&amp; i)&#123;cout &lt;&lt; i &lt;&lt; endl; &#125;);//结果将输出10 这种方式更方便直观。Variant的实现需要借助前文中实现的一些元函数MaxInteger、MaxAlign、Contains和At等等。可以在下面的tab中展开观看，下面来看看Variant实现的关键代码。IntegerMax代码： 1234567891011121314/** 获取整数列表中最大的整数 */template &lt;std::size_t arg, std::size_t... rest&gt;struct IntegerMax;template &lt;std::size_t arg&gt;struct IntegerMax&lt;arg&gt; : std::integral_constant&lt;std::size_t, arg&gt;&#123;&#125;;template &lt;std::size_t arg1, std::size_t arg2, std::size_t... rest&gt;struct IntegerMax&lt;arg1, arg2, rest...&gt; : std::integral_constant&lt;std::size_t, arg1 &gt;= arg2 ? IntegerMax&lt;arg1, rest...&gt;::value : IntegerMax&lt;arg2, rest...&gt;::value&gt;&#123;&#125;; MaxAlign代码： 12345/** 获取最大的align */template&lt;typename... Args&gt;struct MaxAlign : std::integral_constant&lt;int, IntegerMax&lt;std::alignment_of&lt;Args&gt;::value...&gt;::value&gt;&#123;&#125;; Contains代码： 1234567891011121314/** 是否包含某个类型 */template &lt;typename T, typename... List&gt;struct Contains;template &lt;typename T, typename Head, typename... Rest&gt;struct Contains&lt;T, Head, Rest...&gt; : std::conditional&lt;std::is_same&lt;T, Head&gt;::value, std::true_type, Contains&lt;T, Rest... &gt;&gt; ::type&#123;&#125;;template &lt;typename T&gt;struct Contains&lt;T&gt; : std::false_type&#123;&#125;; IndexOf代码： 1234567891011121314151617181920template &lt;typename T, typename... List&gt;struct IndexOf;template &lt;typename T, typename Head, typename... Rest&gt;struct IndexOf&lt;T, Head, Rest...&gt;&#123; enum &#123; value = IndexOf&lt;T, Rest...&gt;::value + 1 &#125;;&#125;;template &lt;typename T, typename... Rest&gt;struct IndexOf&lt;T, T, Rest...&gt;&#123; enum &#123; value = 0 &#125;;&#125;;template &lt;typename T&gt;struct IndexOf&lt;T&gt;&#123; enum&#123;value = -1&#125;;&#125;; At代码： 1234567891011121314template&lt;int index, typename... Types&gt;struct At;template&lt;int index, typename First, typename... Types&gt;struct At&lt;index, First, Types...&gt;&#123; using type = typename At&lt;index - 1, Types...&gt;::type;&#125;;template&lt;typename T, typename... Types&gt;struct At&lt;0, T, Types...&gt;&#123; using type = T;&#125;; Variant关键代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697template&lt;typename... Types&gt;class Variant&#123; enum&#123; data_size = IntegerMax&lt;sizeof(Types)...&gt;::value, //参数个数 align_size = MaxAlign&lt;Types...&gt;::value //参数最大字节数 &#125;; using data_t = typename std::aligned_storage&lt;data_size, align_size&gt;::type;public: template&lt;int index&gt; using IndexType = typename At&lt;index, Types...&gt;::type; Variant(void) :m_typeIndex(typeid(void))&#123;&#125; ~Variant()&#123; Destroy(m_typeIndex, &amp;m_data); &#125; Variant(Variant&lt;Types...&gt;&amp;&amp; old) : m_typeIndex(old.m_typeIndex)&#123; Move(old.m_typeIndex, &amp;old.m_data, &amp;m_data); &#125; Variant(const Variant&lt;Types...&gt;&amp; old) : m_typeIndex(old.m_typeIndex)&#123; Copy(old.m_typeIndex, &amp;old.m_data, &amp;m_data); &#125; template &lt;class T, class = typename std::enable_if&lt;Contains&lt;typename std::remove_reference&lt;T&gt;::type, Types...&gt;::value&gt;::type&gt; Variant(T&amp;&amp; value) : m_typeIndex(typeid(void))&#123; Destroy(m_typeIndex, &amp;m_data); typedef typename std::remove_reference&lt;T&gt;::type U; new(&amp;m_data) U(std::forward&lt;T&gt;(value)); m_typeIndex = type_index(typeid(U)); &#125; template&lt;typename T&gt; bool Is() const&#123; return (m_typeIndex == type_index(typeid(T))); &#125; template&lt;typename T&gt; typename std::decay&lt;T&gt;::type&amp; Get()&#123; using U = typename std::decay&lt;T&gt;::type; if (!Is&lt;U&gt;()) &#123; cout &lt;&lt; typeid(U).name() &lt;&lt; \" is not defined. \" &lt;&lt; \"current type is \" &lt;&lt; m_typeIndex.name() &lt;&lt; endl; throw std::bad_cast(); &#125; return *(U*)(&amp;m_data); &#125; template&lt;typename F&gt; void Visit(F&amp;&amp; f)&#123; using T = typename Function_Traits&lt;F&gt;::template arg&lt;0&gt;::type; if (Is&lt;T&gt;()) f(Get&lt;T&gt;()); &#125; template&lt;typename F, typename... Rest&gt; void Visit(F&amp;&amp; f, Rest&amp;&amp;... rest)&#123; using T = typename Function_Traits&lt;F&gt;::template arg&lt;0&gt;::type; if (Is&lt;T&gt;()) Visit(std::forward&lt;F&gt;(f)); else Visit(std::forward&lt;Rest&gt;(rest)...); &#125;private: void Destroy(const type_index&amp; index, void * buf)&#123; std::initializer_list&lt;int&gt;&#123;(Destroy0&lt;Types&gt;(index, buf), 0)...&#125;; &#125; template&lt;typename T&gt; void Destroy0(const type_index&amp; id, void* data)&#123; if (id == type_index(typeid(T))) reinterpret_cast&lt;T*&gt;(data)-&gt;~T(); &#125; void Move(const type_index&amp; old_t, void* old_v, void* new_v) &#123; std::initializer_list&lt;int&gt;&#123;(Move0&lt;Types&gt;(old_t, old_v, new_v), 0)...&#125;; &#125; template&lt;typename T&gt; void Move0(const type_index&amp; old_t, void* old_v, void* new_v)&#123; if (old_t == type_index(typeid(T))) new (new_v)T(std::move(*reinterpret_cast&lt;T*&gt;(old_v))); &#125; void Copy(const type_index&amp; old_t, void* old_v, void* new_v)&#123; std::initializer_list&lt;int&gt;&#123;(Copy0&lt;Types&gt;(old_t, old_v, new_v), 0)...&#125;; &#125; template&lt;typename T&gt; void Copy0(const type_index&amp; old_t, void* old_v, void* new_v)&#123; if (old_t == type_index(typeid(T))) new (new_v)T(*reinterpret_cast&lt;const T*&gt;(old_v)); &#125;private: data_t m_data; std::type_index m_typeIndex;//类型ID&#125;; 实现Variant首先需要定义一个足够大的缓冲区用来存放不同的类型的值，这个缓类型冲区实际上就是用来擦除类型，不同的类型都通过placement new在这个缓冲区上创建对象，因为类型长度不同，所以需要考虑内存对齐，C++11刚好提供了内存对齐的缓冲区aligned_storage： 12template&lt; std::size_t Len, std::size_t Align = /*default-alignment*/ &gt;struct aligned_storage; 它的第一个参数是缓冲区的长度，第二个参数是缓冲区内存对齐的大小，由于Varaint可以接受多种类型，所以我们需要获取最大的类型长度，保证缓冲区足够大，然后还要获取最大的内存对齐大小，这里我们通过前面实现的MaxInteger和MaxAlign就可以了，Varaint中内存对齐的缓冲区定义如下： 1234567enum&#123; data_size = IntegerMax&lt;sizeof(Types)...&gt;::value, align_size = MaxAlign&lt;Types...&gt;::value&#125;;using data_t = typename std::aligned_storage&lt;data_size, align_size&gt;::type; //内存对齐的缓冲区类型 其次，我们还要实现对缓冲区的构造、拷贝、析构和移动，因为Variant重新赋值的时候需要将缓冲区中原来的类型析构掉，拷贝构造和移动构造时则需要拷贝和移动。这里以析构为例，我们需要根据当前的type_index来遍历Variant的所有类型，找到对应的类型然后调用该类型的析构函数。 123456789101112 void Destroy(const type_index&amp; index, void * buf)&#123; std::initializer_list&lt;int&gt;&#123;(Destroy0&lt;Types&gt;(index, buf), 0)...&#125;; //这里通过一个初始化列表来初始化一个变长数组，int数组的目的就是为了在数组构造的过程展开参数包&#125;template&lt;typename T&gt;void Destroy0(const type_index&amp; id, void* data)&#123; if (id == type_index(typeid(T))) reinterpret_cast&lt;T*&gt;(data)-&gt;~T();&#125; 这里，我们通过初始化列表和逗号表达式来展开可变模板参数，在展开的过程中查找对应的类型，如果找到了则析构。在Variant构造时还需要注意一个细节是，Variant不能接受没有预先定义的类型，所以在构造Variant时，需要限定类型必须在预定义的类型范围当中，这里通过type_traits的enable_if来限定模板参数的类型。 1234567template &lt;class T, class = typename std::enable_if&lt;Contains&lt;typename std::remove_reference&lt;T&gt;::type, Types...&gt;::value&gt;::type&gt; Variant(T&amp;&amp; value) : m_typeIndex(typeid(void))&#123; Destroy(m_typeIndex, &amp;m_data); typedef typename std::remove_reference&lt;T&gt;::type U; new(&amp;m_data) U(std::forward&lt;T&gt;(value)); m_typeIndex = type_index(typeid(U)); &#125; 这里enbale_if的条件就是前面实现的元函数Contains的值，当没有在预定义的类型中找到对应的类型时，即Contains返回false时，编译期会报一个编译错误。 最后还需要实现内置的Vistit功能，Visit的实现需要先通过定义一系列的访问函数，然后再遍历这些函数，遍历过程中，判断函数的第一个参数类型的type_index是否与当前的type_index相同，如果相同则获取当前类型的值。 123456789101112131415template&lt;typename F&gt; void Visit(F&amp;&amp; f)&#123; using T = typename Function_Traits&lt;F&gt;::template arg&lt;0&gt;::type; if (Is&lt;T&gt;()) f(Get&lt;T&gt;()); &#125; template&lt;typename F, typename... Rest&gt; void Visit(F&amp;&amp; f, Rest&amp;&amp;... rest)&#123; using T = typename Function_Traits&lt;F&gt;::template arg&lt;0&gt;::type; if (Is&lt;T&gt;()) Visit(std::forward&lt;F&gt;(f)); else Visit(std::forward&lt;Rest&gt;(rest)...); &#125; Visit功能的实现利用了可变模板参数和function_traits，通过可变模板参数来遍历一系列的访问函数，遍历过程中，通过function_traits来获取第一个参数的类型，和Variant当前的type_index相同时则取值。为什么要获取访问函数第一个参数的类型呢？因为Variant的值是唯一的，只有一个值，所以获取的访问函数的第一个参数的类型就是Variant中存储的对象的实际类型。 未完待续。。。","raw":"---\ntitle: 模版元编程应用\ntags: C++\ncategories: C++\nabbrlink: 5f8019f8\ndate: 2019-06-19 10:34:15\ncopyright: true\ntype:\nkeyword:\ntop:\ncomments:\npassword:\ndescription:\nthumbnail: /posts/模版元编程应用/20190905201147.jpg\n---\n\n### 1.概述\n\n　　关于C++11模板元的基本用法和常用技巧，在常规编程中可能很少遇到，那么C++11模版元编程用来解决什么实际问题呢，在实际工程中又该如何应用呢？本文将侧重介绍C++11模板的一些具体应用，向读者展示模版元编程的具体应用。\n\n　　我们将展示如何通过C++11模版元来实现function_traits、Vairant类型和泛型bind绑定器。function_traits侧重于如何萃取可调用对象的一些元信息，Variant则是一种能接受多种类型数据的“万能”类型，bind则是一个泛化的绑定器，下面来看看这些具体的例子。\n\n<!-- more -->\n\n#### 类型萃取\n\n　　C++模板中的类型参数T是抽象的，我们并不能在模板内部直接获得它的具体特征。类型萃取（抽取）技术就是要抽取类型的一些具体特征(trait)，比如它是哪种具体类型，它是引用类型，内建类型，还是类类型等。可见，类型萃取技术其实就是trait模板技术的具体体现。获取类型的具体特征在Java、C#等语言中也称为反射(reflection)，C++中通过模板技术也可以实现一定的反射行为。\n　　类型信息是编译期的实体，现在要针对类型来进行编程，这其实就是模板元编程的一个方面。我们平常使用的if/else，while，for等基本的逻辑结构都是运行期的行为，在面向类型的编程中并不能使用，这就需要用到一些特殊的模板技术。实现类型萃取要用到的基本思想一个是特化，一个就是用typedef来携带类型信息。实际上，我们在用模板做设计时，一般建议在模板定义内部，为模板的每个类型参数提供typedef定义，这样在泛型代码中可以很容易地访问或抽取这些类型。\n　　在C和C++中，普通的函数可以称为值函数，它们接受的参数是某些值，返回的结果也是值。而所谓的类型函数接受的实参是类型，返回的是被抽取出来的类型或常量值等（即用typedef定义的类型别名，一般不同的具体类型都定义统一的别名）。如类模板就是类型函数，sizeof是内建的类型函数，返回给定类型实参的大小。在类型编程中，很多地方都要用到sizeof。\n//下面演示一些有用的类型萃取实现，这些都是类型函数。\n\n\n\n### 2.function_traits\n\n　　function_traits用来获取函数语义的可调用对象的一些属性，比如函数类型、返回类型、函数指针类型和参数类型等。下面来看看如何实现function_traits。\n\n```c++\n#include <iostream>\n#include <functional>\n\ntemplate<typename T>\nstruct function_traits;\n\n//普通函数萃取\ntemplate<typename Ret, typename... Args>\nstruct function_traits<Ret(Args...)>\n{\npublic:\n    enum { arity = sizeof...(Args) };\n    typedef Ret function_type(Args...);\n    typedef Ret return_type;\n    using stl_function_type = std::function<function_type>;\n    typedef Ret(*pointer)(Args...);\n\n    template<size_t I>\n    struct args\n    {\n        static_assert(I < arity, \"index is out of range, index must less than sizeof Args\");\n        using type = typename std::tuple_element<I, std::tuple<Args...>>::type;\n    };\n};\n\n//类函数萃取\ntemplate<typename Ret, typename Class, typename... Args>\nstruct function_traits<Ret(Class::*) (Args...)>\n{\npublic:\n    enum { arity = sizeof...(Args) };\n    typedef Ret function_type(Args...);\n    typedef Ret return_type;\n    using stl_function_type = std::function<function_type>;\n    typedef Ret(Class::* pointer)(Args...);\n    typedef Class class_type;\n\n    template<size_t I>\n    struct args\n    {\n        static_assert(I < arity, \"index is out of range, index must less than sizeof Args\");\n        using type = typename std::tuple_element<I, std::tuple<Args...>>::type;\n    };\n};\n\n//函数指针\ntemplate<typename Ret, typename... Args>\nstruct function_traits<Ret(*)(Args...)> : function_traits<Ret(Args...)> {};\n\n//std::function\ntemplate <typename Ret, typename... Args>\nstruct function_traits<std::function<Ret(Args...)>> : function_traits<Ret(Args...)> {};\n\n//member function\ntemplate <typename ReturnType, typename ClassType, typename... Args>\nstruct function_traits<ReturnType(ClassType::*)(Args...) const> : function_traits<ReturnType(ClassType::*)(Args...)> {};\n\n//函数对象\ntemplate<typename Callable>\nstruct function_traits : function_traits<decltype(&Callable::operator())> {};\n```\n\n由于可调用对象可能是普通的函数、函数指针、lambda、std::function和成员函数，所以我们需要针对这些类型分别做偏特化，然后萃取出可调用对象的元信息。其中，成员函数的偏特化稍微复杂一点，因为涉及到cv符的处理，这里通过定义一个宏来消除重复的模板类定义。参数类型的获取我们是借助于tuple，将参数转换为tuple类型，然后根据索引来获取对应类型。它的用法比较简单：\n\n```c++\n\n//类函数\nstruct S\n{\n    inline void fun(const char*) {};\n};\n\n//普通函数\ndouble fun() { return 0.1; };\n\ntemplate<typename T>\nvoid PrintType()\n{\n    std::cout << typeid(T).name() << std::endl;\n}\n\nint main()\n{\n\t\tvoid (S::* cfptr)(const char*) = &S::fun; // class fnptr\n    double (*fptr)() = fun; //fnptr\n    std::function<int(int)> f = [](int a) {return a; };  //function\n    auto lambda = [](int a) {return a; }; // lambda\n\n    //打印函数类型\n    PrintType<function_traits<decltype(fptr)>::function_type>(); //将输出double __cdecl<void>\n  \n    //打印类函数指针类型\n    PrintType<function_traits<decltype(&cfptr)>::pointer>(); //将输出void <__thiscall S::*><char const *>\n\n    //打印函数的第一个参数类型\n    PrintType<function_traits<std::function<int(bool)>>::args<0>::type>();//将输出bool\n\n    //打印函数的返回类型\n    PrintType<function_traits<decltype(f)>::return_type>(); //将输出int\n\n    //打印函数指针类型\n    PrintType<function_traits<decltype(f)>::pointer>(); //将输出int <__cdecl*><int>\n\n    //打印function函数类型\n    PrintType<function_traits<decltype(f)>::stl_function_type>(); //将输出class std::function<int __cdecl<int>>\n\n    //lambda => 隐式转化为了匿名类对象\n    PrintType<function_traits<decltype(lambda)>::class_type>(); //将输出class <lambda_13vr3tgewf32rt23rfgt435g41239da>\n}\n```\n\ngun gcc下：\n\n```c++\nFdvE\nb\ni\nPFiiE\nSt8functionIFiiEE\nZ4mainEUliE0_\nM1SFvPKcE\n```\n\nVisual studio下：\n\n```c++\ndouble __cdecl(void)\nvoid (__thiscall S::*)(char const *)\nbool\nint\nint (__cdecl*)(int)\nclass std::function<int __cdecl(int)>\nclass <lambda_173ed6f42b6e4df55bf9ec2e4778d93a>\n```\n\n其实结果是一样的，至于为什么可以参考[这里](http://www.cppblog.com/smagle/archive/2010/05/14/115286.html )\n\n\n\n可以看到这个function_traits通过类型萃取，可以很方便地获取可调用对象（函数、函数指针、函数对象、std::function和lambda表达式）的一些元信息，功能非常强大，这个function_traits经常会用到是更高层模版元程序的基础。比如Variant类型的实现就要用到这个function_traits，下面来看看Variant的实现。\n\n\n\n### 3.Variant\n\n　　借助上面的function_traits和前文实现的一些元函数，我们就能方便的实现一个“万能类型”—Variant，Variant实际上一个泛化的类型，这个Variant和boost.variant的用法类似，需要预定义一些类型作为可接受的类型。boost.variant的基本用法如下：\n\n```c++\ntypedef variant<int,char, double> vt;\nvt v = 1;\nv = 'a';\nv = 12.32;\n```\n\n　　这个variant可以接受已经定义的那些类型，看起来有点类似于c#和java中的object类型，实际上variant是擦除了类型，要获取它的实际类型的时候就稍显麻烦，需要通过boost.visitor来访问：\n\n```c++\nstruct VariantVisitor : public boost::static_visitor<void>\n{\n    void operator() (int a)\n    {\n        cout << \"int\" << endl;\n    }\n\n    void operator() (short val)\n    {\n        cout << \"short\" << endl;\n    }\n\n    void operator() (double val)\n    {\n        cout << \"double\" << endl;\n    }\n\n    void operator() (std::string val)\n    {\n        cout << \"string\" << endl;\n    }\n};\n\nboost::variant<int,short,double,std::string> v = 1;\nboost::apply_visitor(visitor, v); //将输出int\n```\n\n​\t　通过C++11模版元实现的Variant将改进值的获取，将获取实际值的方式改为内置的，即通过下面的方式来访问：\n\n```c++\ntypedef Variant<int, double, string, int> cv;\ncv v = 10;\nv.Visit([&](double i){cout << i << endl; }, [](short i){cout << i << endl; }, [=](int i){cout << i << endl; },[](const string& i){cout << i << endl; });//结果将输出10\n```\n\n　这种方式更方便直观。Variant的实现需要借助前文中实现的一些元函数MaxInteger、MaxAlign、Contains和At等等。可以在下面的tab中展开观看，下面来看看Variant实现的关键代码。\nIntegerMax代码：\n\n```c++\n/** 获取整数列表中最大的整数 */\ntemplate <std::size_t arg, std::size_t... rest>\nstruct IntegerMax;\n\ntemplate <std::size_t arg>\nstruct IntegerMax<arg> : std::integral_constant<std::size_t, arg>\n{\n};\n\ntemplate <std::size_t arg1, std::size_t arg2, std::size_t... rest>\nstruct IntegerMax<arg1, arg2, rest...> : std::integral_constant<std::size_t, arg1 >= arg2 ? IntegerMax<arg1, rest...>::value\n    : IntegerMax<arg2, rest...>::value>\n{\n};\n```\nMaxAlign代码：\n\n```c++\n/** 获取最大的align */\ntemplate<typename... Args>\nstruct MaxAlign : std::integral_constant<int, IntegerMax<std::alignment_of<Args>::value...>::value>\n{\n};\n```\nContains代码：\n\n```c++\n/** 是否包含某个类型 */\ntemplate <typename T, typename... List>\nstruct Contains;\n\ntemplate <typename T, typename Head, typename... Rest>\nstruct Contains<T, Head, Rest...>\n    : std::conditional<std::is_same<T, Head>::value, std::true_type, Contains<T, Rest... >> ::type\n{\n};\n\ntemplate <typename T>\nstruct Contains<T> : std::false_type\n{\n};\n```\nIndexOf代码：\n\n```c++\ntemplate <typename T, typename... List>\nstruct IndexOf;\n\ntemplate <typename T, typename Head, typename... Rest>\nstruct IndexOf<T, Head, Rest...>\n{\n    enum { value = IndexOf<T, Rest...>::value + 1 };\n};\n\ntemplate <typename T, typename... Rest>\nstruct IndexOf<T, T, Rest...>\n{\n    enum { value = 0 };\n};\n\ntemplate <typename T>\nstruct IndexOf<T>\n{\n    enum{value = -1};\n};\n```\nAt代码：\n\n```c++\ntemplate<int index, typename... Types>\nstruct At;\n\ntemplate<int index, typename First, typename... Types>\nstruct At<index, First, Types...>\n{\n    using type = typename At<index - 1, Types...>::type;\n};\n\ntemplate<typename T, typename... Types>\nstruct At<0, T, Types...>\n{\n    using type = T;\n};\n```\n\n\nVariant关键代码：\n\n\n```c++\ntemplate<typename... Types>\nclass Variant{\n    enum{\n        data_size = IntegerMax<sizeof(Types)...>::value, //参数个数\n        align_size = MaxAlign<Types...>::value\t//参数最大字节数\n    };\n    using data_t = typename std::aligned_storage<data_size, align_size>::type;\npublic:\n    template<int index>\n    using IndexType = typename At<index, Types...>::type;\n\n    Variant(void) :m_typeIndex(typeid(void)){}\n    ~Variant(){ Destroy(m_typeIndex, &m_data); }\n\n    Variant(Variant<Types...>&& old) : m_typeIndex(old.m_typeIndex){\n        Move(old.m_typeIndex, &old.m_data, &m_data);\n    }\n\n    Variant(const Variant<Types...>& old) : m_typeIndex(old.m_typeIndex){\n        Copy(old.m_typeIndex, &old.m_data, &m_data);\n    }\n\n    template <class T,\n    class = typename std::enable_if<Contains<typename std::remove_reference<T>::type, Types...>::value>::type> Variant(T&& value) : m_typeIndex(typeid(void)){\n            Destroy(m_typeIndex, &m_data);\n            typedef typename std::remove_reference<T>::type U;\n            new(&m_data) U(std::forward<T>(value));\n            m_typeIndex = type_index(typeid(U));\n    }\n\n    template<typename T>\n    bool Is() const{\n        return (m_typeIndex == type_index(typeid(T)));\n    }\n\n    template<typename T>\n    typename std::decay<T>::type& Get(){\n        using U = typename std::decay<T>::type;\n        if (!Is<U>())\n        {\n            cout << typeid(U).name() << \" is not defined. \" << \"current type is \" <<\n                m_typeIndex.name() << endl;\n            throw std::bad_cast();\n        }\n\n        return *(U*)(&m_data);\n    }\n\n    template<typename F>\n    void Visit(F&& f){\n        using T = typename Function_Traits<F>::template arg<0>::type;\n        if (Is<T>())\n            f(Get<T>());\n    }\n\n    template<typename F, typename... Rest>\n    void Visit(F&& f, Rest&&... rest){\n        using T = typename Function_Traits<F>::template arg<0>::type;\n        if (Is<T>())\n            Visit(std::forward<F>(f));\n        else\n            Visit(std::forward<Rest>(rest)...);\n    }\nprivate:\n    void Destroy(const type_index& index, void * buf){\n        std::initializer_list<int>{(Destroy0<Types>(index, buf), 0)...};\n    }\n\n    template<typename T>\n    void Destroy0(const type_index& id, void* data){\n        if (id == type_index(typeid(T)))\n            reinterpret_cast<T*>(data)->~T();\n    }\n\n    void Move(const type_index& old_t, void* old_v, void* new_v) {\n        std::initializer_list<int>{(Move0<Types>(old_t, old_v, new_v), 0)...};\n    }\n\n    template<typename T>\n    void Move0(const type_index& old_t, void* old_v, void* new_v){\n        if (old_t == type_index(typeid(T)))\n            new (new_v)T(std::move(*reinterpret_cast<T*>(old_v)));\n    }\n\n    void Copy(const type_index& old_t, void* old_v, void* new_v){\n        std::initializer_list<int>{(Copy0<Types>(old_t, old_v, new_v), 0)...};\n    }\n\n    template<typename T>\n    void Copy0(const type_index& old_t, void* old_v, void* new_v){\n        if (old_t == type_index(typeid(T)))\n            new (new_v)T(*reinterpret_cast<const T*>(old_v));\n    }\nprivate:\n    data_t m_data;\n    std::type_index m_typeIndex;//类型ID\n};\n```\n\n　实现Variant首先需要定义一个足够大的缓冲区用来存放不同的类型的值，这个缓类型冲区实际上就是用来擦除类型，不同的类型都通过placement new在这个缓冲区上创建对象，因为类型长度不同，所以需要考虑内存对齐，C++11刚好提供了内存对齐的缓冲区aligned_storage：\n\n```c++\ntemplate< std::size_t Len, std::size_t Align = /*default-alignment*/ >\nstruct aligned_storage;\n```\n\n它的第一个参数是缓冲区的长度，第二个参数是缓冲区内存对齐的大小，由于Varaint可以接受多种类型，所以我们需要获取最大的类型长度，保证缓冲区足够大，然后还要获取最大的内存对齐大小，这里我们通过前面实现的MaxInteger和MaxAlign就可以了，Varaint中内存对齐的缓冲区定义如下：\n\n```c++\nenum\n{\n        data_size = IntegerMax<sizeof(Types)...>::value,\n        align_size = MaxAlign<Types...>::value\n};\n\nusing data_t = typename std::aligned_storage<data_size, align_size>::type; //内存对齐的缓冲区类型\n```\n\n其次，我们还要实现对缓冲区的构造、拷贝、析构和移动，因为Variant重新赋值的时候需要将缓冲区中原来的类型析构掉，拷贝构造和移动构造时则需要拷贝和移动。这里以析构为例，我们需要根据当前的type_index来遍历Variant的所有类型，找到对应的类型然后调用该类型的析构函数。\n\n```c++\n　　 void Destroy(const type_index& index, void * buf)\n    {\n        std::initializer_list<int>{(Destroy0<Types>(index, buf), 0)...};\n     //这里通过一个初始化列表来初始化一个变长数组，int数组的目的就是为了在数组构造的过程展开参数包\n    }\n\n    template<typename T>\n    void Destroy0(const type_index& id, void* data)\n    {\n        if (id == type_index(typeid(T)))\n            reinterpret_cast<T*>(data)->~T();\n    }\n```\n\n这里，我们通过初始化列表和逗号表达式来展开可变模板参数，在展开的过程中查找对应的类型，如果找到了则析构。在Variant构造时还需要注意一个细节是，Variant不能接受没有预先定义的类型，所以在构造Variant时，需要限定类型必须在预定义的类型范围当中，这里通过type_traits的enable_if来限定模板参数的类型。\n\n```c++\ntemplate <class T,\n    class = typename std::enable_if<Contains<typename std::remove_reference<T>::type, Types...>::value>::type> Variant(T&& value) : m_typeIndex(typeid(void)){\n            Destroy(m_typeIndex, &m_data);\n            typedef typename std::remove_reference<T>::type U;\n            new(&m_data) U(std::forward<T>(value));\n            m_typeIndex = type_index(typeid(U));\n    }\n```\n\n这里enbale_if的条件就是前面实现的元函数Contains的值，当没有在预定义的类型中找到对应的类型时，即Contains返回false时，编译期会报一个编译错误。\n\n最后还需要实现内置的Vistit功能，Visit的实现需要先通过定义一系列的访问函数，然后再遍历这些函数，遍历过程中，判断函数的第一个参数类型的type_index是否与当前的type_index相同，如果相同则获取当前类型的值。\n\n```c++\ntemplate<typename F>\n    void Visit(F&& f){\n        using T = typename Function_Traits<F>::template arg<0>::type;\n        if (Is<T>())\n            f(Get<T>());\n    }\n\n    template<typename F, typename... Rest>\n    void Visit(F&& f, Rest&&... rest){\n        using T = typename Function_Traits<F>::template arg<0>::type;\n        if (Is<T>())\n            Visit(std::forward<F>(f));\n        else\n            Visit(std::forward<Rest>(rest)...);\n    }\n```\n\n　Visit功能的实现利用了可变模板参数和function_traits，通过可变模板参数来遍历一系列的访问函数，遍历过程中，通过function_traits来获取第一个参数的类型，和Variant当前的type_index相同时则取值。为什么要获取访问函数第一个参数的类型呢？因为Variant的值是唯一的，只有一个值，所以获取的访问函数的第一个参数的类型就是Variant中存储的对象的实际类型。\n\n未完待续。。。","content":"<h3 id=\"1-概述\">1.概述<a href=\"posts/模版元编程应用#1-概述\"></a></h3><p>　　关于C++11模板元的基本用法和常用技巧，在常规编程中可能很少遇到，那么C++11模版元编程用来解决什么实际问题呢，在实际工程中又该如何应用呢？本文将侧重介绍C++11模板的一些具体应用，向读者展示模版元编程的具体应用。</p>\n<p>　　我们将展示如何通过C++11模版元来实现function_traits、Vairant类型和泛型bind绑定器。function_traits侧重于如何萃取可调用对象的一些元信息，Variant则是一种能接受多种类型数据的“万能”类型，bind则是一个泛化的绑定器，下面来看看这些具体的例子。</p>\n<a id=\"more\"></a>\n\n<h4 id=\"类型萃取\">类型萃取<a href=\"posts/模版元编程应用#类型萃取\"></a></h4><p>　　C++模板中的类型参数T是抽象的，我们并不能在模板内部直接获得它的具体特征。类型萃取（抽取）技术就是要抽取类型的一些具体特征(trait)，比如它是哪种具体类型，它是引用类型，内建类型，还是类类型等。可见，类型萃取技术其实就是trait模板技术的具体体现。获取类型的具体特征在Java、C#等语言中也称为反射(reflection)，C++中通过模板技术也可以实现一定的反射行为。<br>　　类型信息是编译期的实体，现在要针对类型来进行编程，这其实就是模板元编程的一个方面。我们平常使用的if/else，while，for等基本的逻辑结构都是运行期的行为，在面向类型的编程中并不能使用，这就需要用到一些特殊的模板技术。实现类型萃取要用到的基本思想一个是特化，一个就是用typedef来携带类型信息。实际上，我们在用模板做设计时，一般建议在模板定义内部，为模板的每个类型参数提供typedef定义，这样在泛型代码中可以很容易地访问或抽取这些类型。<br>　　在C和C++中，普通的函数可以称为值函数，它们接受的参数是某些值，返回的结果也是值。而所谓的类型函数接受的实参是类型，返回的是被抽取出来的类型或常量值等（即用typedef定义的类型别名，一般不同的具体类型都定义统一的别名）。如类模板就是类型函数，sizeof是内建的类型函数，返回给定类型实参的大小。在类型编程中，很多地方都要用到sizeof。<br>//下面演示一些有用的类型萃取实现，这些都是类型函数。</p>\n<h3 id=\"2-function-traits\">2.function_traits<a href=\"posts/模版元编程应用#2-function-traits\"></a></h3><p>　　function_traits用来获取函数语义的可调用对象的一些属性，比如函数类型、返回类型、函数指针类型和参数类型等。下面来看看如何实现function_traits。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">function_traits</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//普通函数萃取</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Ret, <span class=\"keyword\">typename</span>... Args&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">function_traits</span>&lt;Ret(Args...)&gt;</span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">enum</span> &#123; arity = <span class=\"keyword\">sizeof</span>...(Args) &#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">typedef</span> Ret <span class=\"title\">function_type</span><span class=\"params\">(Args...)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> Ret return_type;</span><br><span class=\"line\">    <span class=\"keyword\">using</span> stl_function_type = <span class=\"built_in\">std</span>::function&lt;function_type&gt;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">Ret</span><span class=\"params\">(*pointer)</span><span class=\"params\">(Args...)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">template</span>&lt;<span class=\"keyword\">size_t</span> I&gt;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">args</span></span></span><br><span class=\"line\"><span class=\"class\">    &#123;</span></span><br><span class=\"line\">        <span class=\"keyword\">static_assert</span>(I &lt; arity, <span class=\"string\">\"index is out of range, index must less than sizeof Args\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">using</span> type = <span class=\"keyword\">typename</span> <span class=\"built_in\">std</span>::tuple_element&lt;I, <span class=\"built_in\">std</span>::tuple&lt;Args...&gt;&gt;::type;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//类函数萃取</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Ret, <span class=\"keyword\">typename</span> Class, <span class=\"keyword\">typename</span>... Args&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">function_traits</span>&lt;Ret(Class::*) (Args...)&gt;</span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">enum</span> &#123; arity = <span class=\"keyword\">sizeof</span>...(Args) &#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">typedef</span> Ret <span class=\"title\">function_type</span><span class=\"params\">(Args...)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> Ret return_type;</span><br><span class=\"line\">    <span class=\"keyword\">using</span> stl_function_type = <span class=\"built_in\">std</span>::function&lt;function_type&gt;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">Ret</span><span class=\"params\">(Class::* pointer)</span><span class=\"params\">(Args...)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> Class class_type;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">template</span>&lt;<span class=\"keyword\">size_t</span> I&gt;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">args</span></span></span><br><span class=\"line\"><span class=\"class\">    &#123;</span></span><br><span class=\"line\">        <span class=\"keyword\">static_assert</span>(I &lt; arity, <span class=\"string\">\"index is out of range, index must less than sizeof Args\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">using</span> type = <span class=\"keyword\">typename</span> <span class=\"built_in\">std</span>::tuple_element&lt;I, <span class=\"built_in\">std</span>::tuple&lt;Args...&gt;&gt;::type;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//函数指针</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Ret, <span class=\"keyword\">typename</span>... Args&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">function_traits</span>&lt;Ret(*)(Args...)&gt; :</span> function_traits&lt;Ret(Args...)&gt; &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//std::function</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Ret, <span class=\"keyword\">typename</span>... Args&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">function_traits</span>&lt;std::function&lt;Ret(Args...)&gt;&gt; :</span> function_traits&lt;Ret(Args...)&gt; &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//member function</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> ReturnType, <span class=\"keyword\">typename</span> ClassType, <span class=\"keyword\">typename</span>... Args&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">function_traits</span>&lt;ReturnType(ClassType::*)(Args...) const&gt; :</span> function_traits&lt;ReturnType(ClassType::*)(Args...)&gt; &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//函数对象</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Callable&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">function_traits</span> :</span> function_traits&lt;<span class=\"keyword\">decltype</span>(&amp;Callable::<span class=\"keyword\">operator</span>())&gt; &#123;&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p>由于可调用对象可能是普通的函数、函数指针、lambda、std::function和成员函数，所以我们需要针对这些类型分别做偏特化，然后萃取出可调用对象的元信息。其中，成员函数的偏特化稍微复杂一点，因为涉及到cv符的处理，这里通过定义一个宏来消除重复的模板类定义。参数类型的获取我们是借助于tuple，将参数转换为tuple类型，然后根据索引来获取对应类型。它的用法比较简单：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//类函数</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">S</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>*)</span> </span>&#123;&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//普通函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">fun</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">0.1</span>; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintType</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"keyword\">typeid</span>(T).name() &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">void</span> (S::* cfptr)(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>*) = &amp;S::fun; <span class=\"comment\">// class fnptr</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> (*fptr)() = fun; <span class=\"comment\">//fnptr</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">int</span>(<span class=\"keyword\">int</span>)&gt; f = [](<span class=\"keyword\">int</span> a) &#123;<span class=\"keyword\">return</span> a; &#125;;  <span class=\"comment\">//function</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> lambda = [](<span class=\"keyword\">int</span> a) &#123;<span class=\"keyword\">return</span> a; &#125;; <span class=\"comment\">// lambda</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//打印函数类型</span></span><br><span class=\"line\">    PrintType&lt;function_traits&lt;<span class=\"keyword\">decltype</span>(fptr)&gt;::function_type&gt;(); <span class=\"comment\">//将输出double __cdecl&lt;void&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//打印类函数指针类型</span></span><br><span class=\"line\">    PrintType&lt;function_traits&lt;<span class=\"keyword\">decltype</span>(&amp;cfptr)&gt;::pointer&gt;(); <span class=\"comment\">//将输出void &lt;__thiscall S::*&gt;&lt;char const *&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//打印函数的第一个参数类型</span></span><br><span class=\"line\">    PrintType&lt;function_traits&lt;<span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">int</span>(<span class=\"keyword\">bool</span>)&gt;&gt;::args&lt;<span class=\"number\">0</span>&gt;::type&gt;();<span class=\"comment\">//将输出bool</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//打印函数的返回类型</span></span><br><span class=\"line\">    PrintType&lt;function_traits&lt;<span class=\"keyword\">decltype</span>(f)&gt;::return_type&gt;(); <span class=\"comment\">//将输出int</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//打印函数指针类型</span></span><br><span class=\"line\">    PrintType&lt;function_traits&lt;<span class=\"keyword\">decltype</span>(f)&gt;::pointer&gt;(); <span class=\"comment\">//将输出int &lt;__cdecl*&gt;&lt;int&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//打印function函数类型</span></span><br><span class=\"line\">    PrintType&lt;function_traits&lt;<span class=\"keyword\">decltype</span>(f)&gt;::stl_function_type&gt;(); <span class=\"comment\">//将输出class std::function&lt;int __cdecl&lt;int&gt;&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//lambda =&gt; 隐式转化为了匿名类对象</span></span><br><span class=\"line\">    PrintType&lt;function_traits&lt;<span class=\"keyword\">decltype</span>(lambda)&gt;::class_type&gt;(); <span class=\"comment\">//将输出class &lt;lambda_13vr3tgewf32rt23rfgt435g41239da&gt;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>gun gcc下：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FdvE</span><br><span class=\"line\">b</span><br><span class=\"line\">i</span><br><span class=\"line\">PFiiE</span><br><span class=\"line\">St8functionIFiiEE</span><br><span class=\"line\">Z4mainEUliE0_</span><br><span class=\"line\">M1SFvPKcE</span><br></pre></td></tr></table></div></figure>\n\n<p>Visual studio下：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> __cdecl(<span class=\"keyword\">void</span>)</span><br><span class=\"line\"><span class=\"keyword\">void</span> (__thiscall S::*)(<span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *)</span><br><span class=\"line\"><span class=\"keyword\">bool</span></span><br><span class=\"line\"><span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> (__cdecl*)(<span class=\"keyword\">int</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">std</span>:</span>:function&lt;<span class=\"keyword\">int</span> __cdecl(<span class=\"keyword\">int</span>)&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> &lt;lambda_173ed6f42b6e4df55bf9ec2e4778d93a&gt;</span></span><br></pre></td></tr></table></div></figure>\n\n<p>其实结果是一样的，至于为什么可以参考<a href=\"http://www.cppblog.com/smagle/archive/2010/05/14/115286.html\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<p>可以看到这个function_traits通过类型萃取，可以很方便地获取可调用对象（函数、函数指针、函数对象、std::function和lambda表达式）的一些元信息，功能非常强大，这个function_traits经常会用到是更高层模版元程序的基础。比如Variant类型的实现就要用到这个function_traits，下面来看看Variant的实现。</p>\n<h3 id=\"3-Variant\">3.Variant<a href=\"posts/模版元编程应用#3-Variant\"></a></h3><p>　　借助上面的function_traits和前文实现的一些元函数，我们就能方便的实现一个“万能类型”—Variant，Variant实际上一个泛化的类型，这个Variant和boost.variant的用法类似，需要预定义一些类型作为可接受的类型。boost.variant的基本用法如下：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> variant&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">char</span>, <span class=\"keyword\">double</span>&gt; vt;</span><br><span class=\"line\">vt v = <span class=\"number\">1</span>;</span><br><span class=\"line\">v = <span class=\"string\">'a'</span>;</span><br><span class=\"line\">v = <span class=\"number\">12.32</span>;</span><br></pre></td></tr></table></div></figure>\n\n<p>　　这个variant可以接受已经定义的那些类型，看起来有点类似于c#和java中的object类型，实际上variant是擦除了类型，要获取它的实际类型的时候就稍显麻烦，需要通过boost.visitor来访问：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">VariantVisitor</span> :</span> <span class=\"keyword\">public</span> boost::static_visitor&lt;<span class=\"keyword\">void</span>&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span> <span class=\"params\">(<span class=\"keyword\">int</span> a)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"int\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span> <span class=\"params\">(<span class=\"keyword\">short</span> val)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"short\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span> <span class=\"params\">(<span class=\"keyword\">double</span> val)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"double\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span> <span class=\"params\">(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> val)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"string\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">boost::variant&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">short</span>,<span class=\"keyword\">double</span>,<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt; v = <span class=\"number\">1</span>;</span><br><span class=\"line\">boost::apply_visitor(visitor, v); <span class=\"comment\">//将输出int</span></span><br></pre></td></tr></table></div></figure>\n\n<p>​    　通过C++11模版元实现的Variant将改进值的获取，将获取实际值的方式改为内置的，即通过下面的方式来访问：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> Variant&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">double</span>, <span class=\"built_in\">string</span>, <span class=\"keyword\">int</span>&gt; cv;</span><br><span class=\"line\">cv v = <span class=\"number\">10</span>;</span><br><span class=\"line\">v.Visit([&amp;](<span class=\"keyword\">double</span> i)&#123;<span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"built_in\">endl</span>; &#125;, [](<span class=\"keyword\">short</span> i)&#123;<span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"built_in\">endl</span>; &#125;, [=](<span class=\"keyword\">int</span> i)&#123;<span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"built_in\">endl</span>; &#125;,[](<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; i)&#123;<span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"built_in\">endl</span>; &#125;);<span class=\"comment\">//结果将输出10</span></span><br></pre></td></tr></table></div></figure>\n\n<p>　这种方式更方便直观。Variant的实现需要借助前文中实现的一些元函数MaxInteger、MaxAlign、Contains和At等等。可以在下面的tab中展开观看，下面来看看Variant实现的关键代码。<br>IntegerMax代码：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 获取整数列表中最大的整数 */</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"built_in\">std</span>::<span class=\"keyword\">size_t</span> arg, <span class=\"built_in\">std</span>::<span class=\"keyword\">size_t</span>... rest&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">IntegerMax</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"built_in\">std</span>::<span class=\"keyword\">size_t</span> arg&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">IntegerMax</span>&lt;arg&gt; :</span> <span class=\"built_in\">std</span>::integral_constant&lt;<span class=\"built_in\">std</span>::<span class=\"keyword\">size_t</span>, arg&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"built_in\">std</span>::<span class=\"keyword\">size_t</span> arg1, <span class=\"built_in\">std</span>::<span class=\"keyword\">size_t</span> arg2, <span class=\"built_in\">std</span>::<span class=\"keyword\">size_t</span>... rest&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">IntegerMax</span>&lt;arg1, arg2, rest...&gt; :</span> <span class=\"built_in\">std</span>::integral_constant&lt;<span class=\"built_in\">std</span>::<span class=\"keyword\">size_t</span>, arg1 &gt;= arg2 ? IntegerMax&lt;arg1, rest...&gt;::value</span><br><span class=\"line\">    : IntegerMax&lt;arg2, rest...&gt;::value&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p>MaxAlign代码：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 获取最大的align */</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span>... Args&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">MaxAlign</span> :</span> <span class=\"built_in\">std</span>::integral_constant&lt;<span class=\"keyword\">int</span>, IntegerMax&lt;<span class=\"built_in\">std</span>::alignment_of&lt;Args&gt;::value...&gt;::value&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p>Contains代码：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 是否包含某个类型 */</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span>... List&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Contains</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> Head, <span class=\"keyword\">typename</span>... Rest&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Contains</span>&lt;T, Head, Rest...&gt;</span></span><br><span class=\"line\"><span class=\"class\">    :</span> <span class=\"built_in\">std</span>::conditional&lt;<span class=\"built_in\">std</span>::is_same&lt;T, Head&gt;::value, <span class=\"built_in\">std</span>::true_type, Contains&lt;T, Rest... &gt;&gt; ::type</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Contains</span>&lt;T&gt; :</span> <span class=\"built_in\">std</span>::false_type</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p>IndexOf代码：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span>... List&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">IndexOf</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> Head, <span class=\"keyword\">typename</span>... Rest&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">IndexOf</span>&lt;T, Head, Rest...&gt;</span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">enum</span> &#123; value = IndexOf&lt;T, Rest...&gt;::value + <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span>... Rest&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">IndexOf</span>&lt;T, T, Rest...&gt;</span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">enum</span> &#123; value = <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">IndexOf</span>&lt;T&gt;</span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">enum</span>&#123;value = <span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p>At代码：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">int</span> index, <span class=\"keyword\">typename</span>... Types&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">At</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">int</span> index, <span class=\"keyword\">typename</span> First, <span class=\"keyword\">typename</span>... Types&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">At</span>&lt;index, First, Types...&gt;</span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">using</span> type = <span class=\"keyword\">typename</span> At&lt;index - <span class=\"number\">1</span>, Types...&gt;::type;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span>... Types&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">At</span>&lt;0, T, Types...&gt;</span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">using</span> type = T;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p>Variant关键代码：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span>... Types&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Variant</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">enum</span>&#123;</span><br><span class=\"line\">        data_size = IntegerMax&lt;<span class=\"keyword\">sizeof</span>(Types)...&gt;::value, <span class=\"comment\">//参数个数</span></span><br><span class=\"line\">        align_size = MaxAlign&lt;Types...&gt;::value\t<span class=\"comment\">//参数最大字节数</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">using</span> <span class=\"keyword\">data_t</span> = <span class=\"keyword\">typename</span> <span class=\"built_in\">std</span>::aligned_storage&lt;data_size, align_size&gt;::type;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">template</span>&lt;<span class=\"keyword\">int</span> index&gt;</span><br><span class=\"line\">    <span class=\"keyword\">using</span> IndexType = <span class=\"keyword\">typename</span> At&lt;index, Types...&gt;::type;</span><br><span class=\"line\"></span><br><span class=\"line\">    Variant(<span class=\"keyword\">void</span>) :m_typeIndex(<span class=\"keyword\">typeid</span>(<span class=\"keyword\">void</span>))&#123;&#125;</span><br><span class=\"line\">    ~Variant()&#123; Destroy(m_typeIndex, &amp;m_data); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Variant(Variant&lt;Types...&gt;&amp;&amp; old) : m_typeIndex(old.m_typeIndex)&#123;</span><br><span class=\"line\">        Move(old.m_typeIndex, &amp;old.m_data, &amp;m_data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Variant(<span class=\"keyword\">const</span> Variant&lt;Types...&gt;&amp; old) : m_typeIndex(old.m_typeIndex)&#123;</span><br><span class=\"line\">        Copy(old.m_typeIndex, &amp;old.m_data, &amp;m_data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>,</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">class</span> = <span class=\"title\">typename</span> <span class=\"title\">std</span>:</span>:enable_if&lt;Contains&lt;<span class=\"keyword\">typename</span> <span class=\"built_in\">std</span>::remove_reference&lt;T&gt;::type, Types...&gt;::value&gt;::type&gt; Variant(T&amp;&amp; value) : m_typeIndex(<span class=\"keyword\">typeid</span>(<span class=\"keyword\">void</span>))&#123;</span><br><span class=\"line\">            Destroy(m_typeIndex, &amp;m_data);</span><br><span class=\"line\">            <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> <span class=\"built_in\">std</span>::remove_reference&lt;T&gt;::type U;</span><br><span class=\"line\">            <span class=\"keyword\">new</span>(&amp;m_data) U(<span class=\"built_in\">std</span>::forward&lt;T&gt;(value));</span><br><span class=\"line\">            m_typeIndex = type_index(<span class=\"keyword\">typeid</span>(U));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Is</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (m_typeIndex == type_index(<span class=\"keyword\">typeid</span>(T)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">    <span class=\"keyword\">typename</span> <span class=\"built_in\">std</span>::decay&lt;T&gt;::<span class=\"function\">type&amp; <span class=\"title\">Get</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">using</span> U = <span class=\"keyword\">typename</span> <span class=\"built_in\">std</span>::decay&lt;T&gt;::type;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!Is&lt;U&gt;())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"keyword\">typeid</span>(U).name() &lt;&lt; <span class=\"string\">\" is not defined. \"</span> &lt;&lt; <span class=\"string\">\"current type is \"</span> &lt;&lt;</span><br><span class=\"line\">                m_typeIndex.name() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"built_in\">std</span>::bad_cast();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> *(U*)(&amp;m_data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> F&gt;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Visit</span><span class=\"params\">(F&amp;&amp; f)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">using</span> T = <span class=\"keyword\">typename</span> Function_Traits&lt;F&gt;::<span class=\"keyword\">template</span> arg&lt;<span class=\"number\">0</span>&gt;::type;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Is&lt;T&gt;())</span><br><span class=\"line\">            f(Get&lt;T&gt;());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> F, <span class=\"keyword\">typename</span>... Rest&gt;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Visit</span><span class=\"params\">(F&amp;&amp; f, Rest&amp;&amp;... rest)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">using</span> T = <span class=\"keyword\">typename</span> Function_Traits&lt;F&gt;::<span class=\"keyword\">template</span> arg&lt;<span class=\"number\">0</span>&gt;::type;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Is&lt;T&gt;())</span><br><span class=\"line\">            Visit(<span class=\"built_in\">std</span>::forward&lt;F&gt;(f));</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            Visit(<span class=\"built_in\">std</span>::forward&lt;Rest&gt;(rest)...);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Destroy</span><span class=\"params\">(<span class=\"keyword\">const</span> type_index&amp; index, <span class=\"keyword\">void</span> * buf)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">initializer_list</span>&lt;<span class=\"keyword\">int</span>&gt;&#123;(Destroy0&lt;Types&gt;(index, buf), <span class=\"number\">0</span>)...&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Destroy0</span><span class=\"params\">(<span class=\"keyword\">const</span> type_index&amp; id, <span class=\"keyword\">void</span>* data)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (id == type_index(<span class=\"keyword\">typeid</span>(T)))</span><br><span class=\"line\">            <span class=\"keyword\">reinterpret_cast</span>&lt;T*&gt;(data)-&gt;~T();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Move</span><span class=\"params\">(<span class=\"keyword\">const</span> type_index&amp; <span class=\"keyword\">old_t</span>, <span class=\"keyword\">void</span>* old_v, <span class=\"keyword\">void</span>* new_v)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">initializer_list</span>&lt;<span class=\"keyword\">int</span>&gt;&#123;(Move0&lt;Types&gt;(<span class=\"keyword\">old_t</span>, old_v, new_v), <span class=\"number\">0</span>)...&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Move0</span><span class=\"params\">(<span class=\"keyword\">const</span> type_index&amp; <span class=\"keyword\">old_t</span>, <span class=\"keyword\">void</span>* old_v, <span class=\"keyword\">void</span>* new_v)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">old_t</span> == type_index(<span class=\"keyword\">typeid</span>(T)))</span><br><span class=\"line\">            <span class=\"keyword\">new</span> (new_v)T(<span class=\"built_in\">std</span>::move(*<span class=\"keyword\">reinterpret_cast</span>&lt;T*&gt;(old_v)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Copy</span><span class=\"params\">(<span class=\"keyword\">const</span> type_index&amp; <span class=\"keyword\">old_t</span>, <span class=\"keyword\">void</span>* old_v, <span class=\"keyword\">void</span>* new_v)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">initializer_list</span>&lt;<span class=\"keyword\">int</span>&gt;&#123;(Copy0&lt;Types&gt;(<span class=\"keyword\">old_t</span>, old_v, new_v), <span class=\"number\">0</span>)...&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Copy0</span><span class=\"params\">(<span class=\"keyword\">const</span> type_index&amp; <span class=\"keyword\">old_t</span>, <span class=\"keyword\">void</span>* old_v, <span class=\"keyword\">void</span>* new_v)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">old_t</span> == type_index(<span class=\"keyword\">typeid</span>(T)))</span><br><span class=\"line\">            <span class=\"keyword\">new</span> (new_v)T(*<span class=\"keyword\">reinterpret_cast</span>&lt;<span class=\"keyword\">const</span> T*&gt;(old_v));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">data_t</span> m_data;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::type_index m_typeIndex;<span class=\"comment\">//类型ID</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p>　实现Variant首先需要定义一个足够大的缓冲区用来存放不同的类型的值，这个缓类型冲区实际上就是用来擦除类型，不同的类型都通过placement new在这个缓冲区上创建对象，因为类型长度不同，所以需要考虑内存对齐，C++11刚好提供了内存对齐的缓冲区aligned_storage：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt; <span class=\"built_in\">std</span>::<span class=\"keyword\">size_t</span> Len, <span class=\"built_in\">std</span>::<span class=\"keyword\">size_t</span> Align = <span class=\"comment\">/*default-alignment*/</span> &gt;</span><br><span class=\"line\">struct aligned_storage;</span><br></pre></td></tr></table></div></figure>\n\n<p>它的第一个参数是缓冲区的长度，第二个参数是缓冲区内存对齐的大小，由于Varaint可以接受多种类型，所以我们需要获取最大的类型长度，保证缓冲区足够大，然后还要获取最大的内存对齐大小，这里我们通过前面实现的MaxInteger和MaxAlign就可以了，Varaint中内存对齐的缓冲区定义如下：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        data_size = IntegerMax&lt;<span class=\"keyword\">sizeof</span>(Types)...&gt;::value,</span><br><span class=\"line\">        align_size = MaxAlign&lt;Types...&gt;::value</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">data_t</span> = <span class=\"keyword\">typename</span> <span class=\"built_in\">std</span>::aligned_storage&lt;data_size, align_size&gt;::type; <span class=\"comment\">//内存对齐的缓冲区类型</span></span><br></pre></td></tr></table></div></figure>\n\n<p>其次，我们还要实现对缓冲区的构造、拷贝、析构和移动，因为Variant重新赋值的时候需要将缓冲区中原来的类型析构掉，拷贝构造和移动构造时则需要拷贝和移动。这里以析构为例，我们需要根据当前的type_index来遍历Variant的所有类型，找到对应的类型然后调用该类型的析构函数。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　 <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Destroy</span><span class=\"params\">(<span class=\"keyword\">const</span> type_index&amp; index, <span class=\"keyword\">void</span> * buf)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">initializer_list</span>&lt;<span class=\"keyword\">int</span>&gt;&#123;(Destroy0&lt;Types&gt;(index, buf), <span class=\"number\">0</span>)...&#125;;</span><br><span class=\"line\"> <span class=\"comment\">//这里通过一个初始化列表来初始化一个变长数组，int数组的目的就是为了在数组构造的过程展开参数包</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Destroy0</span><span class=\"params\">(<span class=\"keyword\">const</span> type_index&amp; id, <span class=\"keyword\">void</span>* data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (id == type_index(<span class=\"keyword\">typeid</span>(T)))</span><br><span class=\"line\">        <span class=\"keyword\">reinterpret_cast</span>&lt;T*&gt;(data)-&gt;~T();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>这里，我们通过初始化列表和逗号表达式来展开可变模板参数，在展开的过程中查找对应的类型，如果找到了则析构。在Variant构造时还需要注意一个细节是，Variant不能接受没有预先定义的类型，所以在构造Variant时，需要限定类型必须在预定义的类型范围当中，这里通过type_traits的enable_if来限定模板参数的类型。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>,</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">class</span> = <span class=\"title\">typename</span> <span class=\"title\">std</span>:</span>:enable_if&lt;Contains&lt;<span class=\"keyword\">typename</span> <span class=\"built_in\">std</span>::remove_reference&lt;T&gt;::type, Types...&gt;::value&gt;::type&gt; Variant(T&amp;&amp; value) : m_typeIndex(<span class=\"keyword\">typeid</span>(<span class=\"keyword\">void</span>))&#123;</span><br><span class=\"line\">            Destroy(m_typeIndex, &amp;m_data);</span><br><span class=\"line\">            <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> <span class=\"built_in\">std</span>::remove_reference&lt;T&gt;::type U;</span><br><span class=\"line\">            <span class=\"keyword\">new</span>(&amp;m_data) U(<span class=\"built_in\">std</span>::forward&lt;T&gt;(value));</span><br><span class=\"line\">            m_typeIndex = type_index(<span class=\"keyword\">typeid</span>(U));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>这里enbale_if的条件就是前面实现的元函数Contains的值，当没有在预定义的类型中找到对应的类型时，即Contains返回false时，编译期会报一个编译错误。</p>\n<p>最后还需要实现内置的Vistit功能，Visit的实现需要先通过定义一系列的访问函数，然后再遍历这些函数，遍历过程中，判断函数的第一个参数类型的type_index是否与当前的type_index相同，如果相同则获取当前类型的值。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> F&gt;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Visit</span><span class=\"params\">(F&amp;&amp; f)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">using</span> T = <span class=\"keyword\">typename</span> Function_Traits&lt;F&gt;::<span class=\"keyword\">template</span> arg&lt;<span class=\"number\">0</span>&gt;::type;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Is&lt;T&gt;())</span><br><span class=\"line\">            f(Get&lt;T&gt;());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> F, <span class=\"keyword\">typename</span>... Rest&gt;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Visit</span><span class=\"params\">(F&amp;&amp; f, Rest&amp;&amp;... rest)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">using</span> T = <span class=\"keyword\">typename</span> Function_Traits&lt;F&gt;::<span class=\"keyword\">template</span> arg&lt;<span class=\"number\">0</span>&gt;::type;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Is&lt;T&gt;())</span><br><span class=\"line\">            Visit(<span class=\"built_in\">std</span>::forward&lt;F&gt;(f));</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            Visit(<span class=\"built_in\">std</span>::forward&lt;Rest&gt;(rest)...);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>　Visit功能的实现利用了可变模板参数和function_traits，通过可变模板参数来遍历一系列的访问函数，遍历过程中，通过function_traits来获取第一个参数的类型，和Variant当前的type_index相同时则取值。为什么要获取访问函数第一个参数的类型呢？因为Variant的值是唯一的，只有一个值，所以获取的访问函数的第一个参数的类型就是Variant中存储的对象的实际类型。</p>\n<p>未完待续。。。</p>\n","slug":"模版元编程应用","updated":"2019-09-06T05:10:05.361Z","comments":true,"link":"posts/模版元编程应用","permalink":"https://shuntan.github.io/posts/模版元编程应用/","excerpt":"1.概述 关于C++11模板元的基本用法和常用技巧，在常规编程中可能很少遇到，那么C++11模版元编程用来解决什么实际问题呢，在实际工程中又该如何应用呢？本文将侧重介绍C++11模板的一些具体应用，向读者展示模版元编程的具体应用。 我们将展示如何通过C++11模版元来实现function_traits、Vairant类型和泛型bind绑定器。function_traits侧重于如何萃取可调用对象的一些元信息，Variant则是一种能接受多种类型数据的“万能”类型，bind则是一个泛化的绑定器，下面来看看这些具体的例子。","categories":[{"name":"C++","slug":"C","permalink":"https://shuntan.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://shuntan.github.io/tags/C/"}]},{"title":"C++中优雅的异步操作","date":"2019-06-14T06:21:26.000Z","path":"posts/C++中优雅的异步操作/","text":"c++11中增加了线程，使得我们可以非常方便的创建线程，它的基本用法是这样的： 123void f(int n);std::thread t(f, n + 1);t.join(); 但是线程毕竟是属于比较低层次的东西，有时候使用有些不便，比如我希望获取线程函数的返回结果的时候，我就不能直接通过thread.join()得到结果，这时就必须定义一个变量，在线程函数中去给这个变量赋值，然后join,最后得到结果，这个过程是比较繁琐的。c++11还提供了异步接口std::async，通过这个异步接口可以很方便的获取线程函数的执行结果。std::async会自动创建一个线程去调用线程函数，它返回一个std::future，这个future中存储了线程函数返回的结果，当我们需要线程函数的结果时，直接从future中获取，非常方便。但是我想说的是，其实std::async给我们提供的便利可不仅仅是这一点，它首先解耦了线程的创建和执行，使得我们可以在需要的时候获取异步操作的结果；其次它还提供了线程的创建策略（比如可以通过延迟加载的方式去创建线程），使得我们可以以多种方式去创建线程。在介绍async具体用法以及为什么要用std::async代替线程的创建之前，我想先说一说std::future、std::promise和std::packaged_task。 std::futur std::future是一个非常有用也很有意思的东西，简单说std::future提供了一种访问异步操作结果的机制。从字面意思来理解，它表示未来，我觉得这个名字非常贴切，因为一个异步操作我们是不可能马上就获取操作结果的，只能在未来某个时候获取，但是我们可以以同步等待的方式来获取结果，可以通过查询future的状态（future_status）来获取异步操作的结果。future_status有三种状态： deferred：异步操作还没开始 ready：异步操作已经完成 timeout：异步操作超时 123456789101112//查询future的状态std::future_status status; do &#123; status = future.wait_for(std::chrono::seconds(1)); if (status == std::future_status::deferred) &#123; std::cout &lt;&lt; \"deferred\\n\"; //代表延迟执行 &#125; else if (status == std::future_status::timeout) &#123; std::cout &lt;&lt; \"timeout\\n\"; //代表执行中 &#125; else if (status == std::future_status::ready) &#123; std::cout &lt;&lt; \"ready!\\n\"; //代表已经执行完成 &#125; &#125; while (status != std::future_status::ready); 获取future结果有三种方式：get、wait、wait_for，其中get等待异步操作结束并返回结果，wait只是等待异步操作完成，没有返回值，wait_for是超时等待返回结果。 std::promise std::promise为获取线程函数中的某个值提供便利，在线程函数中给外面传进来的promise赋值，当线程函数执行完成之后就可以通过promis获取该值了，值得注意的是取值是间接的通过promise内部提供的future来获取的。它的基本用法： 1234std::promise&lt;int&gt; pr;std::thread t([](std::promise&lt;int&gt;&amp; p)&#123; p.set_value_at_thread_exit(9); &#125;,std::ref(pr));std::future&lt;int&gt; f = pr.get_future();auto r = f.get(); std::packaged_task std::packaged_task它包装了一个可调用的目标（如function, lambda expression, bind expression, or another function object）,以便异步调用，它和promise在某种程度上有点像，promise保存了一个共享状态的值，而packaged_task保存的是一个函数。它的基本用法： 1234std::packaged_task&lt;int()&gt; task([]()&#123; return 7; &#125;);std::thread t1(std::ref(task)); std::future&lt;int&gt; f1 = task.get_future(); auto r1 = f1.get(); std::promise、std::packaged_task和std::future的关系 至此, 我们介绍了std::async相关的几个对象std::future、std::promise和std::packaged_task，其中std::promise和std::packaged_task的结果最终都是通过其内部的future返回出来的，不知道读者有没有搞糊涂，为什么有这么多东西出来，他们之间的关系到底是怎样的？且听我慢慢道来，std::future提供了一个访问异步操作结果的机制，它和线程是一个级别的属于低层次的对象，在它之上高一层的是std::packaged_task和std::promise，他们内部都有future以便访问异步操作结果，std::packaged_task包装的是一个异步操作，而std::promise包装的是一个值，都是为了方便异步操作的，因为有时我需要获取线程中的某个值，这时就用std::promise，而有时我需要获一个异步操作的返回值，这时就用std::packaged_task。那std::promise和std::packaged_task之间又是什么关系呢？说他们没关系也关系，说他们有关系也有关系，都取决于你了，因为我可以将一个异步操作的结果保存到std::promise中。如果读者还没搞清楚他们的关系的话，我就用更通俗的话来解释一下。比如，一个小伙子给一个姑娘表白真心的时候也许会说：”我许诺会给你一个美好的未来“或者”我会努力奋斗为你创造一个美好的未来“。姑娘往往会说：”我等着“。现在我来将这三句话用c++11来翻译一下： 小伙子说：我许诺会给你一个美好的未来等于c++11中”std::promise a std::future”;小伙子说：我会努力奋斗为你创造一个美好的未来等于c++11中”std::packaged_task a future”;姑娘说：我等着等于c++11中”future.get()/wait()”; 小伙子两句话的个中差异，自己琢磨一下，这点差异也是std::promise和std::packaged_task的差异。现实中的山盟海誓靠不靠得住我不知道，但是c++11中的许诺和未来是一定可靠的，发起来了许诺就一定有未来。细想起来c++11标准的制定者选定的关键字真是贴切而有意思！好了，插科打诨到此了，现在言归正传，回过头来说说std::async。 为什么要用std::async代替线程的创建 std::async又是干啥的，已经有了td::future、std::promise和std::packaged_task，够多的了，真的还要一个std::async来凑热闹吗，std::async表示很委屈：我不是来凑热闹的，我是来帮忙的。是的，std::async是为了让用户的少费点脑子的，它让这三个对象默契的工作。大概的工作过程是这样的：std::async先将异步操作用std::packaged_task包装起来，然后将异步操作的结果放到std::promise中，这个过程就是创造未来的过程。外面再通过future.get/wait来获取这个未来的结果，怎么样，std::async真的是来帮忙的吧，你不用再想到底该怎么用std::future、std::promise和std::packaged_task了，std::async已经帮你搞定一切了！ 现在来看看std::async的原型async(std::launch::async | std::launch::deferred, f, args…)，第一个参数是线程的创建策略，有两种策略，默认的策略是立即创建线程： std::launch::async：在调用async就开始创建线程。 std::launch::deferred：延迟加载方式创建线程。调用async时不创建线程，直到调用了future的get或者wait时才创建线程。可能在这里会阻塞住主线程。 第二个参数是线程函数，第三个参数是线程函数的参数。 std::async基本用法： 12345678910111213141516171819202122232425262728293031323334353637std::future&lt;int&gt; f1 = std::async(std::launch::async, []()&#123; return 8; &#125;); cout&lt;&lt;f1.get()&lt;&lt;endl; //output: 8std::future&lt;int&gt; f2 = std::async(std::launch::async, []()&#123; cout&lt;&lt;8&lt;&lt;endl; &#125;); f2.wait(); //output: 8std::future&lt;int&gt; future = std::async(std::launch::async, []()&#123; std::this_thread::sleep_for(std::chrono::seconds(3)); return 8; &#125;); std::cout &lt;&lt; \"waiting...\\n\"; std::future_status status; do &#123; status = future.wait_for(std::chrono::seconds(1)); if (status == std::future_status::deferred) &#123; std::cout &lt;&lt; \"deferred\\n\"; &#125; else if (status == std::future_status::timeout) &#123; std::cout &lt;&lt; \"timeout\\n\"; &#125; else if (status == std::future_status::ready) &#123; std::cout &lt;&lt; \"ready!\\n\"; &#125; &#125; while (status != std::future_status::ready); std::cout &lt;&lt; \"result is \" &lt;&lt; future.get() &lt;&lt; '\\n';可能的结果：waiting...timeouttimeoutready!result is 8 总结： std::async是更高层次上的异步操作，使我们不用关注线程创建内部细节，就能方便的获取异步执行状态和结果，还可以指定线程创建策略，应该用std::async替代线程的创建，让它成为我们做异步操作的首选。","raw":"---\ntitle: C++中优雅的异步操作\ncopyright: true\ntags: C++\ncategories: C++\nabbrlink: c02967a6\ndate: 2019-06-14 14:21:26\ntype:\nkeyword:\ntop:\ncomments:\npassword:\ndescription:\nthumbnail: /posts/C++中优雅的异步操作/0341e046a16c2b9a2762a35c3cde7dbf.jpg\n---\n\n　　c++11中增加了线程，使得我们可以非常方便的创建线程，它的基本用法是这样的：\n\n```c++\nvoid f(int n);\nstd::thread t(f, n + 1);\nt.join();\n```\n\n　　但是线程毕竟是属于比较低层次的东西，有时候使用有些不便，比如我希望获取线程函数的返回结果的时候，我就不能直接通过thread.join()得到结果，这时就必须定义一个变量，在线程函数中去给这个变量赋值，然后join,最后得到结果，这个过程是比较繁琐的。c++11还提供了异步接口std::async，通过这个异步接口可以很方便的获取线程函数的执行结果。std::async会自动创建一个线程去调用线程函数，它返回一个std::future，这个future中存储了线程函数返回的结果，当我们需要线程函数的结果时，直接从future中获取，非常方便。但是我想说的是，<strong>其实std::async给我们提供的便利可不仅仅是这一点，它首先解耦了线程的创建和执行，使得我们可以在需要的时候获取异步操作的结果；其次它还提供了线程的创建策略（比如可以通过延迟加载的方式去创建线程）</strong>，使得我们可以以多种方式去创建线程。在介绍async具体用法以及为什么要用std::async代替线程的创建之前，我想先说一说std::future、std::promise和std::packaged_task。\n\n<!-- more -->\n\n## std::futur\n\n　　std::future是一个非常有用也很有意思的东西，简单说std::future提供了一种访问异步操作结果的机制。从字面意思来理解，它表示未来，我觉得这个名字非常贴切，因为一个异步操作我们是不可能马上就获取操作结果的，只能在未来某个时候获取，但是我们可以以同步等待的方式来获取结果，可以通过查询future的状态（future_status）来获取异步操作的结果。future_status有三种状态：\n\n- deferred：异步操作还没开始\n- ready：异步操作已经完成\n- timeout：异步操作超时\n\n```c++\n//查询future的状态\nstd::future_status status;\n    do {\n        status = future.wait_for(std::chrono::seconds(1));\n        if (status == std::future_status::deferred) {\n            std::cout << \"deferred\\n\"; //代表延迟执行\n        } else if (status == std::future_status::timeout) {\n            std::cout << \"timeout\\n\";  //代表执行中\n        } else if (status == std::future_status::ready) {\n            std::cout << \"ready!\\n\";   //代表已经执行完成\n        }\n    } while (status != std::future_status::ready); \n```\n\n　　获取future结果有三种方式：get、wait、wait_for，其中get等待异步操作结束并返回结果，wait只是等待异步操作完成，没有返回值，wait_for是超时等待返回结果。\n\n## std::promise\n\n　　std::promise为获取线程函数中的某个值提供便利，在线程函数中给外面传进来的promise赋值，当线程函数执行完成之后就可以通过promis获取该值了，值得注意的是取值是间接的通过promise内部提供的future来获取的。它的基本用法：\n\n```c++\n    std::promise<int> pr;\n    std::thread t([](std::promise<int>& p){ p.set_value_at_thread_exit(9); },std::ref(pr));\n    std::future<int> f = pr.get_future();\n    auto r = f.get();\n```\n\n## std::packaged_task\n\n　　std::packaged_task它包装了一个可调用的目标（如function, lambda expression, bind expression, or another function object）,以便异步调用，它和promise在某种程度上有点像，promise保存了一个共享状态的值，而packaged_task保存的是一个函数。它的基本用法：\n\n```c++\n    std::packaged_task<int()> task([](){ return 7; });\n    std::thread t1(std::ref(task)); \n    std::future<int> f1 = task.get_future(); \n    auto r1 = f1.get();\n```\n\n## std::promise、std::packaged_task和std::future的关系\n\n　　至此, 我们介绍了std::async相关的几个对象std::future、std::promise和std::packaged_task，其中std::promise和std::packaged_task的结果最终都是通过其内部的future返回出来的，不知道读者有没有搞糊涂，为什么有这么多东西出来，他们之间的关系到底是怎样的？且听我慢慢道来，std::future提供了一个访问异步操作结果的机制，它和线程是一个级别的属于低层次的对象，在它之上高一层的是std::packaged_task和std::promise，他们内部都有future以便访问异步操作结果，<strong>std::packaged_task包装的是一个异步操作，而std::promise包装的是一个值，都是为了方便异步操作的，因为有时我需要获取线程中的某个值，这时就用std::promise，而有时我需要获一个异步操作的返回值，这时就用std::packaged_task。</strong>那std::promise和std::packaged_task之间又是什么关系呢？说他们没关系也关系，说他们有关系也有关系，都取决于你了，因为我可以将一个异步操作的结果保存到std::promise中。如果读者还没搞清楚他们的关系的话，我就用更通俗的话来解释一下。比如，一个小伙子给一个姑娘表白真心的时候也许会说：”我许诺会给你一个美好的未来“或者”我会努力奋斗为你创造一个美好的未来“。姑娘往往会说：”我等着“。现在我来将这三句话用c++11来翻译一下：\n\n小伙子说：我许诺会给你一个美好的未来等于c++11中\"std::promise a std::future\"; \n小伙子说：我会努力奋斗为你创造一个美好的未来等于c++11中\"std::packaged_task a future\"; \n姑娘说：我等着等于c++11中\"future.get()/wait()\";\n\n　　小伙子两句话的个中差异，自己琢磨一下，这点差异也是std::promise和std::packaged_task的差异。现实中的山盟海誓靠不靠得住我不知道，但是c++11中的许诺和未来是一定可靠的，发起来了许诺就一定有未来。细想起来c++11标准的制定者选定的关键字真是贴切而有意思！好了，插科打诨到此了，现在言归正传，回过头来说说std::async。\n\n## 为什么要用std::async代替线程的创建\n\n　　std::async又是干啥的，已经有了td::future、std::promise和std::packaged_task，够多的了，真的还要一个std::async来凑热闹吗，std::async表示很委屈：我不是来凑热闹的，我是来帮忙的。是的，std::async是为了让用户的少费点脑子的，它让这三个对象默契的工作。大概的工作过程是这样的：std::async先将异步操作用std::packaged_task包装起来，然后将异步操作的结果放到std::promise中，这个过程就是创造未来的过程。外面再通过future.get/wait来获取这个未来的结果，怎么样，std::async真的是来帮忙的吧，你不用再想到底该怎么用std::future、std::promise和std::packaged_task了，std::async已经帮你搞定一切了！\n\n　　现在来看看std::async的原型async(std::launch::async | std::launch::deferred, f, args...)，第一个参数是线程的创建策略，有两种策略，默认的策略是立即创建线程：\n\n- std::launch::async：在调用async就开始创建线程。\n- std::launch::deferred：延迟加载方式创建线程。调用async时不创建线程，直到调用了future的get或者wait时才创建线程。可能在这里会阻塞住主线程。\n\n第二个参数是线程函数，第三个参数是线程函数的参数。\n\n**std::async基本用法：**\n\n```c++\nstd::future<int> f1 = std::async(std::launch::async, [](){ \n        return 8;  \n    }); \n\ncout<<f1.get()<<endl; //output: 8\n\nstd::future<int> f2 = std::async(std::launch::async, [](){ \n        cout<<8<<endl;\n    }); \n\nf2.wait(); //output: 8\n\nstd::future<int> future = std::async(std::launch::async, [](){ \n        std::this_thread::sleep_for(std::chrono::seconds(3));\n        return 8;  \n    }); \n \n    std::cout << \"waiting...\\n\";\n    std::future_status status;\n    do {\n        status = future.wait_for(std::chrono::seconds(1));\n        if (status == std::future_status::deferred) {\n            std::cout << \"deferred\\n\";\n        } else if (status == std::future_status::timeout) {\n            std::cout << \"timeout\\n\";\n        } else if (status == std::future_status::ready) {\n            std::cout << \"ready!\\n\";\n        }\n    } while (status != std::future_status::ready); \n \n    std::cout << \"result is \" << future.get() << '\\n';\n可能的结果：\nwaiting...\ntimeout\ntimeout\nready!\nresult is 8\n```\n\n## 总结：\n\n　　std::async是更高层次上的异步操作，使我们不用关注线程创建内部细节，就能方便的获取异步执行状态和结果，还可以指定线程创建策略，应该用std::async替代线程的创建，让它成为我们做异步操作的首选。","content":"<p>　　c++11中增加了线程，使得我们可以非常方便的创建线程，它的基本用法是这样的：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"function\">thread <span class=\"title\">t</span><span class=\"params\">(f, n + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">t.join();</span><br></pre></td></tr></table></div></figure>\n\n<p>　　但是线程毕竟是属于比较低层次的东西，有时候使用有些不便，比如我希望获取线程函数的返回结果的时候，我就不能直接通过thread.join()得到结果，这时就必须定义一个变量，在线程函数中去给这个变量赋值，然后join,最后得到结果，这个过程是比较繁琐的。c++11还提供了异步接口std::async，通过这个异步接口可以很方便的获取线程函数的执行结果。std::async会自动创建一个线程去调用线程函数，它返回一个std::future，这个future中存储了线程函数返回的结果，当我们需要线程函数的结果时，直接从future中获取，非常方便。但是我想说的是，<strong>其实std::async给我们提供的便利可不仅仅是这一点，它首先解耦了线程的创建和执行，使得我们可以在需要的时候获取异步操作的结果；其次它还提供了线程的创建策略（比如可以通过延迟加载的方式去创建线程）</strong>，使得我们可以以多种方式去创建线程。在介绍async具体用法以及为什么要用std::async代替线程的创建之前，我想先说一说std::future、std::promise和std::packaged_task。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"std-futur\">std::futur<a href=\"posts/C++中优雅的异步操作#std-futur\"></a></h2><p>　　std::future是一个非常有用也很有意思的东西，简单说std::future提供了一种访问异步操作结果的机制。从字面意思来理解，它表示未来，我觉得这个名字非常贴切，因为一个异步操作我们是不可能马上就获取操作结果的，只能在未来某个时候获取，但是我们可以以同步等待的方式来获取结果，可以通过查询future的状态（future_status）来获取异步操作的结果。future_status有三种状态：</p>\n<ul>\n<li>deferred：异步操作还没开始</li>\n<li>ready：异步操作已经完成</li>\n<li>timeout：异步操作超时</li>\n</ul>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询future的状态</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::future_status status;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        status = future.wait_for(<span class=\"built_in\">std</span>::chrono::seconds(<span class=\"number\">1</span>));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (status == <span class=\"built_in\">std</span>::future_status::deferred) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"deferred\\n\"</span>; <span class=\"comment\">//代表延迟执行</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (status == <span class=\"built_in\">std</span>::future_status::timeout) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"timeout\\n\"</span>;  <span class=\"comment\">//代表执行中</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (status == <span class=\"built_in\">std</span>::future_status::ready) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"ready!\\n\"</span>;   <span class=\"comment\">//代表已经执行完成</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (status != <span class=\"built_in\">std</span>::future_status::ready);</span><br></pre></td></tr></table></div></figure>\n\n<p>　　获取future结果有三种方式：get、wait、wait_for，其中get等待异步操作结束并返回结果，wait只是等待异步操作完成，没有返回值，wait_for是超时等待返回结果。</p>\n<h2 id=\"std-promise\">std::promise<a href=\"posts/C++中优雅的异步操作#std-promise\"></a></h2><p>　　std::promise为获取线程函数中的某个值提供便利，在线程函数中给外面传进来的promise赋值，当线程函数执行完成之后就可以通过promis获取该值了，值得注意的是取值是间接的通过promise内部提供的future来获取的。它的基本用法：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::promise&lt;<span class=\"keyword\">int</span>&gt; pr;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"function\">thread <span class=\"title\">t</span><span class=\"params\">([](<span class=\"built_in\">std</span>::promise&lt;<span class=\"keyword\">int</span>&gt;&amp; p)&#123; p.set_value_at_thread_exit(<span class=\"number\">9</span>); &#125;,<span class=\"built_in\">std</span>::ref(pr))</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::future&lt;<span class=\"keyword\">int</span>&gt; f = pr.get_future();</span><br><span class=\"line\"><span class=\"keyword\">auto</span> r = f.get();</span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"std-packaged-task\">std::packaged_task<a href=\"posts/C++中优雅的异步操作#std-packaged-task\"></a></h2><p>　　std::packaged_task它包装了一个可调用的目标（如function, lambda expression, bind expression, or another function object）,以便异步调用，它和promise在某种程度上有点像，promise保存了一个共享状态的值，而packaged_task保存的是一个函数。它的基本用法：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::packaged_task&lt;<span class=\"keyword\">int</span>()&gt; task([]()&#123; <span class=\"keyword\">return</span> <span class=\"number\">7</span>; &#125;);</span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"function\">thread <span class=\"title\">t1</span><span class=\"params\">(<span class=\"built_in\">std</span>::ref(task))</span></span>; </span><br><span class=\"line\"><span class=\"built_in\">std</span>::future&lt;<span class=\"keyword\">int</span>&gt; f1 = task.get_future(); </span><br><span class=\"line\"><span class=\"keyword\">auto</span> r1 = f1.get();</span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"std-promise、std-packaged-task和std-future的关系\">std::promise、std::packaged_task和std::future的关系<a href=\"posts/C++中优雅的异步操作#std-promise、std-packaged-task和std-future的关系\"></a></h2><p>　　至此, 我们介绍了std::async相关的几个对象std::future、std::promise和std::packaged_task，其中std::promise和std::packaged_task的结果最终都是通过其内部的future返回出来的，不知道读者有没有搞糊涂，为什么有这么多东西出来，他们之间的关系到底是怎样的？且听我慢慢道来，std::future提供了一个访问异步操作结果的机制，它和线程是一个级别的属于低层次的对象，在它之上高一层的是std::packaged_task和std::promise，他们内部都有future以便访问异步操作结果，<strong>std::packaged_task包装的是一个异步操作，而std::promise包装的是一个值，都是为了方便异步操作的，因为有时我需要获取线程中的某个值，这时就用std::promise，而有时我需要获一个异步操作的返回值，这时就用std::packaged_task。</strong>那std::promise和std::packaged_task之间又是什么关系呢？说他们没关系也关系，说他们有关系也有关系，都取决于你了，因为我可以将一个异步操作的结果保存到std::promise中。如果读者还没搞清楚他们的关系的话，我就用更通俗的话来解释一下。比如，一个小伙子给一个姑娘表白真心的时候也许会说：”我许诺会给你一个美好的未来“或者”我会努力奋斗为你创造一个美好的未来“。姑娘往往会说：”我等着“。现在我来将这三句话用c++11来翻译一下：</p>\n<p>小伙子说：我许诺会给你一个美好的未来等于c++11中”std::promise a std::future”;<br>小伙子说：我会努力奋斗为你创造一个美好的未来等于c++11中”std::packaged_task a future”;<br>姑娘说：我等着等于c++11中”future.get()/wait()”;</p>\n<p>　　小伙子两句话的个中差异，自己琢磨一下，这点差异也是std::promise和std::packaged_task的差异。现实中的山盟海誓靠不靠得住我不知道，但是c++11中的许诺和未来是一定可靠的，发起来了许诺就一定有未来。细想起来c++11标准的制定者选定的关键字真是贴切而有意思！好了，插科打诨到此了，现在言归正传，回过头来说说std::async。</p>\n<h2 id=\"为什么要用std-async代替线程的创建\">为什么要用std::async代替线程的创建<a href=\"posts/C++中优雅的异步操作#为什么要用std-async代替线程的创建\"></a></h2><p>　　std::async又是干啥的，已经有了td::future、std::promise和std::packaged_task，够多的了，真的还要一个std::async来凑热闹吗，std::async表示很委屈：我不是来凑热闹的，我是来帮忙的。是的，std::async是为了让用户的少费点脑子的，它让这三个对象默契的工作。大概的工作过程是这样的：std::async先将异步操作用std::packaged_task包装起来，然后将异步操作的结果放到std::promise中，这个过程就是创造未来的过程。外面再通过future.get/wait来获取这个未来的结果，怎么样，std::async真的是来帮忙的吧，你不用再想到底该怎么用std::future、std::promise和std::packaged_task了，std::async已经帮你搞定一切了！</p>\n<p>　　现在来看看std::async的原型async(std::launch::async | std::launch::deferred, f, args…)，第一个参数是线程的创建策略，有两种策略，默认的策略是立即创建线程：</p>\n<ul>\n<li>std::launch::async：在调用async就开始创建线程。</li>\n<li>std::launch::deferred：延迟加载方式创建线程。调用async时不创建线程，直到调用了future的get或者wait时才创建线程。可能在这里会阻塞住主线程。</li>\n</ul>\n<p>第二个参数是线程函数，第三个参数是线程函数的参数。</p>\n<p><strong>std::async基本用法：</strong></p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::future&lt;<span class=\"keyword\">int</span>&gt; f1 = <span class=\"built_in\">std</span>::async(<span class=\"built_in\">std</span>::launch::async, []()&#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">8</span>;  </span><br><span class=\"line\">    &#125;); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;f1.get()&lt;&lt;<span class=\"built_in\">endl</span>; <span class=\"comment\">//output: 8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">std</span>::future&lt;<span class=\"keyword\">int</span>&gt; f2 = <span class=\"built_in\">std</span>::async(<span class=\"built_in\">std</span>::launch::async, []()&#123; </span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"number\">8</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;); </span><br><span class=\"line\"></span><br><span class=\"line\">f2.wait(); <span class=\"comment\">//output: 8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">std</span>::future&lt;<span class=\"keyword\">int</span>&gt; future = <span class=\"built_in\">std</span>::async(<span class=\"built_in\">std</span>::launch::async, []()&#123; </span><br><span class=\"line\">        <span class=\"built_in\">std</span>::this_thread::sleep_for(<span class=\"built_in\">std</span>::chrono::seconds(<span class=\"number\">3</span>));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">8</span>;  </span><br><span class=\"line\">    &#125;); </span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"waiting...\\n\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::future_status status;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        status = future.wait_for(<span class=\"built_in\">std</span>::chrono::seconds(<span class=\"number\">1</span>));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (status == <span class=\"built_in\">std</span>::future_status::deferred) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"deferred\\n\"</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (status == <span class=\"built_in\">std</span>::future_status::timeout) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"timeout\\n\"</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (status == <span class=\"built_in\">std</span>::future_status::ready) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"ready!\\n\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (status != <span class=\"built_in\">std</span>::future_status::ready); </span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"result is \"</span> &lt;&lt; future.get() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">可能的结果：</span><br><span class=\"line\">waiting...</span><br><span class=\"line\">timeout</span><br><span class=\"line\">timeout</span><br><span class=\"line\">ready!</span><br><span class=\"line\">result is <span class=\"number\">8</span></span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"总结：\">总结：<a href=\"posts/C++中优雅的异步操作#总结：\"></a></h2><p>　　std::async是更高层次上的异步操作，使我们不用关注线程创建内部细节，就能方便的获取异步执行状态和结果，还可以指定线程创建策略，应该用std::async替代线程的创建，让它成为我们做异步操作的首选。</p>\n","slug":"C++中优雅的异步操作","updated":"2019-09-05T12:02:05.274Z","comments":true,"link":"posts/C++中优雅的异步操作","permalink":"https://shuntan.github.io/posts/C++中优雅的异步操作/","excerpt":"c++11中增加了线程，使得我们可以非常方便的创建线程，它的基本用法是这样的： 123void f(int n);std::thread t(f, n + 1);t.join(); 但是线程毕竟是属于比较低层次的东西，有时候使用有些不便，比如我希望获取线程函数的返回结果的时候，我就不能直接通过thread.join()得到结果，这时就必须定义一个变量，在线程函数中去给这个变量赋值，然后join,最后得到结果，这个过程是比较繁琐的。c++11还提供了异步接口std::async，通过这个异步接口可以很方便的获取线程函数的执行结果。std::async会自动创建一个线程去调用线程函数，它返回一个std::future，这个future中存储了线程函数返回的结果，当我们需要线程函数的结果时，直接从future中获取，非常方便。但是我想说的是，其实std::async给我们提供的便利可不仅仅是这一点，它首先解耦了线程的创建和执行，使得我们可以在需要的时候获取异步操作的结果；其次它还提供了线程的创建策略（比如可以通过延迟加载的方式去创建线程），使得我们可以以多种方式去创建线程。在介绍async具体用法以及为什么要用std::async代替线程的创建之前，我想先说一说std::future、std::promise和std::packaged_task。","categories":[{"name":"C++","slug":"C","permalink":"https://shuntan.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://shuntan.github.io/tags/C/"}]},{"title":"Mutex介绍","date":"2019-06-14T03:00:47.000Z","path":"posts/Mutex介绍/","text":"Mutex 又称互斥量，C++ 11中与 Mutex 相关的类（包括锁类型）和函数都声明在 头文件中，所以如果你需要使用 std::mutex，就必须包含 头文件。 头文件介绍Mutex 系列类(四种) std::mutex，最基本的 Mutex 类。 std::recursive_mutex，递归 Mutex 类。 std::time_mutex，定时 Mutex 类。 std::recursive_timed_mutex，定时递归 Mutex 类。 Lock 类（两种） std::lock_guard，与 Mutex RAII 相关，方便线程对互斥量上锁。 std::unique_lock，与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。 其他类型 std::once_flag std::adopt_lock_t std::defer_lock_t std::try_to_lock_t 函数 std::try_lock，尝试同时对多个互斥量上锁。 std::lock，可以同时对多个互斥量上锁。 std::call_once，如果多个线程需要同时调用某个函数，call_once 可以保证多个线程对该函数只调用一次。 std::mutex 介绍下面以 std::mutex 为例介绍 C++11 中的互斥量用法。 std::mutex 是C++11 中最基本的互斥量，std::mutex 对象提供了独占所有权的特性——即不支持递归地对 std::mutex 对象上锁，而 std::recursive_lock 则可以递归地对互斥量对象上锁。 std::mutex 的成员函数 构造函数，std::mutex不允许拷贝构造，也不允许 move 拷贝，最初产生的 mutex 对象是处于 unlocked 状态的。 lock()，调用线程将锁住该互斥量。线程调用该函数会发生下面 3 种情况：(1). 如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁。(2). 如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。 unlock()， 解锁，释放对互斥量的所有权。 try_lock()，尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面 3 种情况，(1). 如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量。(2). 如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。 下面给出一个与 std::mutex 的小例子（参考） 1234567891011121314151617181920212223242526#include &lt;iostream&gt; // std::cout#include &lt;thread&gt; // std::thread#include &lt;mutex&gt; // std::mutexvolatile int counter(0); // non-atomic counterstd::mutex mtx; // locks access to countervoid attempt_10k_increases() &#123; for (int i=0; i&lt;10000; ++i) &#123; if (mtx.try_lock()) &#123; // only increase if currently not locked: ++counter; mtx.unlock(); &#125; &#125;&#125;int main (int argc, const char* argv[]) &#123; std::thread threads[10]; for (int i=0; i&lt;10; ++i) threads[i] = std::thread(attempt_10k_increases); for (auto&amp; th : threads) th.join(); std::cout &lt;&lt; counter &lt;&lt; \" successful increases of the counter.\\n\"; return 0;&#125; 输出结果： 123$g++ -lpthread -std=c++11 -o main *.cpp$main9012 successful increases of the counter. 可以看出有很多次mtx.try_lock()返回了false，并没有执行++counter操作。 如果把mtx.try_lock()改成mtx.lock()，则必定会阻塞其他线程。 输出结果2: 123$g++ -lpthread -std=c++11 -o main *.cpp$main100000 successful increases of the counter. std::recursive_mutex 介绍std::recursive_mutex 与 std::mutex 一样，也是一种可以被上锁的对象，但是和 std::mutex 不同的是，std::recursive_mutex 允许同一个线程对互斥量多次上锁（即递归上锁），来获得对互斥量对象的多层所有权，std::recursive_mutex 释放互斥量时需要调用与该锁层次深度相同次数的 unlock()，可理解为 lock() 次数和 unlock() 次数相同，除此之外，std::recursive_mutex 的特性和 std::mutex 大致相同。 12345678910111213141516171819202122232425#include &lt;iostream&gt; // std::cout#include &lt;thread&gt; // std::thread#include &lt;mutex&gt; // std::mutexvolatile int counter(0); // non-atomic counterstd::recursive_mutex rmtx; // locks access to countervoid attempt_1k_increases() &#123; for (int i=0; i&lt;10000; ++i) &#123; rmtx.lock(); ++counter; &#125; for (int i=0; i&lt;10000; ++i) &#123; counter-=2; rmtx.unlock(); &#125;&#125;int main (int argc, const char* argv[]) &#123; auto th = std::thread(attempt_1k_increases); th.join(); std::cout &lt;&lt; counter &lt;&lt; \" successful increases of the counter.\\n\"; return 0;&#125; 输出结果： 123$g++ -lpthread -o main *.cpp$main-10000 successful increases of the counter. std::time_mutex 介绍std::time_mutex 比 std::mutex 多了两个成员函数，try_lock_for()，try_lock_until()。 try_lock_for 函数接受一个时间范围，表示在这一段时间范围之内线程如果没有获得锁则被阻塞住（与 std::mutex 的 try_lock() 不同，try_lock 如果被调用时没有获得锁则直接返回 false），如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。 try_lock_until 函数则接受一个时间点作为参数，在指定时间点未到来之前线程如果没有获得锁则被阻塞住，如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。 下面的小例子说明了 std::time_mutex 的用法（参考）。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt; // std::cout#include &lt;chrono&gt; // std::chrono::milliseconds#include &lt;thread&gt; // std::thread#include &lt;mutex&gt; // std::timed_mutexstd::timed_mutex mtx;void fireworks() &#123; // waiting to get a lock: each thread prints \"-\" every 200ms: while (!mtx.try_lock_for(std::chrono::milliseconds(200))) &#123; std::cout &lt;&lt; \"-\"; &#125; // got a lock! - wait for 1s, then this thread prints \"*\" std::this_thread::sleep_for(std::chrono::milliseconds(1000)); std::cout &lt;&lt; \"*\\n\"; mtx.unlock();&#125;int main ()&#123; std::thread threads[10]; // spawn 10 threads: for (int i=0; i&lt;10; ++i) threads[i] = std::thread(fireworks); for (auto&amp; th : threads) th.join(); return 0;&#125; 输出结果： 线程输出*表示该线程已经正常退出，并且释放该锁。否则将每200ms尝试获取mutex🔒，直到成功为止。 std::recursive_timed_mutex 介绍和 std:recursive_mutex 与 std::mutex 的关系一样，std::recursive_timed_mutex 的特性也可以从 std::timed_mutex 推导出来，感兴趣的同鞋可以自行查阅。 ;-) std::lock_guard 介绍与 Mutex RAII 相关，方便线程对互斥量上锁。例子（参考）: 1.std::lock_guard 在构造函数中进行加锁，析构函数中进行解锁。 2.锁在多线程编程中，使用较多，因此c++11提供了lock_guard模板类；在实际编程中，我们也可以根据自己的场景编写resource_guard RAII类，避免忘掉释放资源。 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt; // std::cout#include &lt;thread&gt; // std::thread#include &lt;mutex&gt; // std::mutex, std::lock_guard#include &lt;stdexcept&gt; // std::logic_errorstd::mutex mtx;void print_even (int x) &#123; if (x%2==0) std::cout &lt;&lt; x &lt;&lt; \" is even\\n\"; else throw (std::logic_error(\"not even\"));&#125;void print_thread_id (int id) &#123; try &#123; // using a local lock_guard to lock mtx guarantees unlocking on destruction / exception: std::lock_guard&lt;std::mutex&gt; lck (mtx); print_even(id); &#125; catch (std::logic_error&amp;) &#123; std::cout &lt;&lt; \"[exception caught]\\n\"; &#125;&#125;int main ()&#123; std::thread threads[10]; // spawn 10 threads: for (int i=0; i&lt;10; ++i) threads[i] = std::thread(print_thread_id,i+1); for (auto&amp; th : threads) th.join(); return 0;&#125; 输出结果： 123456789101112$g++ -lpthread -o main *.cpp$main[exception caught]4 is even[exception caught]2 is even[exception caught]6 is even8 is even[exception caught][exception caught]10 is even std::unique_lock 介绍与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。例子（参考）： 1.类 unique_lock 是通用互斥包装器，允许延迟锁定、锁定的有时限尝试、递归锁定、所有权转移和与条件变量一同使用。 2.unique_lock比lock_guard使用更加灵活，功能更加强大。使用unique_lock需要付出更多的时间、性能成本。 12345678910111213141516171819202122232425#include &lt;iostream&gt; // std::cout#include &lt;thread&gt; // std::thread#include &lt;mutex&gt; // std::mutex, std::unique_lockstd::mutex mtx; // mutex for critical sectionvoid print_block (int n, char c) &#123; // critical section (exclusive access to std::cout signaled by lifetime of lck): std::unique_lock&lt;std::mutex&gt; lck (mtx); for (int i=0; i&lt;n; ++i) &#123; std::cout &lt;&lt; c; &#125; std::cout &lt;&lt; '\\n';&#125;int main ()&#123; std::thread th1 (print_block,50,'*'); std::thread th2 (print_block,50,'$'); th1.join(); th2.join(); return 0;&#125; 输出结果： 1234$g++ -lpthread -o main *.cpp$main**************************************************$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ 好了，本文暂时讲到这里，还剩下 std::try_lock，std::lock，std::call_once 三个函数没有讲到，留在下一篇博客中讲吧 ;-)","raw":"---\ntitle: Mutex介绍\ncopyright: true\ntags: C++\ncategories: C++\nabbrlink: 58aac72e\ndate: 2019-06-14 11:00:47\ntype:\nkeyword:\ntop:\ncomments:\npassword:\ndescription:\nthumbnail: /posts/Mutex介绍/20190905201210.jpg\n---\n\nMutex 又称互斥量，C++ 11中与 Mutex 相关的类（包括锁类型）和函数都声明在 <mutex> 头文件中，所以如果你需要使用 std::mutex，就必须包含 <mutex> 头文件。\n\n### <mutex> 头文件介绍\n\n#### Mutex 系列类(四种)\n\n- std::mutex，最基本的 Mutex 类。\n\n- std::recursive_mutex，递归 Mutex 类。\n\n- std::time_mutex，定时 Mutex 类。\n\n- std::recursive_timed_mutex，定时递归 Mutex 类。\n\n<!-- more -->\n\n#### Lock 类（两种）\n\n- std::lock_guard，与 Mutex RAII 相关，方便线程对互斥量上锁。\n- std::unique_lock，与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。\n\n#### 其他类型\n\n- std::once_flag\n- std::adopt_lock_t\n- std::defer_lock_t\n- std::try_to_lock_t\n\n#### 函数\n\n- std::try_lock，尝试同时对多个互斥量上锁。\n- std::lock，可以同时对多个互斥量上锁。\n- std::call_once，如果多个线程需要同时调用某个函数，call_once 可以保证多个线程对该函数只调用一次。\n\n### std::mutex 介绍\n\n下面以 std::mutex 为例介绍 C++11 中的互斥量用法。\n\nstd::mutex 是C++11 中最基本的互斥量，std::mutex 对象提供了独占所有权的特性——即不支持递归地对 std::mutex 对象上锁，而 std::recursive_lock 则可以递归地对互斥量对象上锁。\n\n#### std::mutex 的成员函数\n\n- 构造函数，std::mutex不允许拷贝构造，也不允许 move 拷贝，最初产生的 mutex 对象是处于 unlocked 状态的。\n- lock()，调用线程将锁住该互斥量。线程调用该函数会发生下面 3 种情况：(1). 如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁。(2). 如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。\n- unlock()， 解锁，释放对互斥量的所有权。\n- try_lock()，尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面 3 种情况，(1). 如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量。(2). 如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。\n\n下面给出一个与 std::mutex 的小例子（[参考](http://www.cplusplus.com/reference/mutex/mutex/try_lock/)）\n\n```c++\n#include <iostream>       // std::cout\n#include <thread>         // std::thread\n#include <mutex>          // std::mutex\n\nvolatile int counter(0); // non-atomic counter\nstd::mutex mtx;           // locks access to counter\n\nvoid attempt_10k_increases() {\n    for (int i=0; i<10000; ++i) {\n        if (mtx.try_lock()) {   // only increase if currently not locked:\n            ++counter;\n            mtx.unlock();\n        }\n    }\n}\n\nint main (int argc, const char* argv[]) {\n    std::thread threads[10];\n    for (int i=0; i<10; ++i)\n        threads[i] = std::thread(attempt_10k_increases);\n\n    for (auto& th : threads) th.join();\n    std::cout << counter << \" successful increases of the counter.\\n\";\n\n    return 0;\n}\n```\n\n输出结果：\n\n```c++\n$g++ -lpthread -std=c++11 -o main *.cpp\n$main\n9012 successful increases of the counter.\n```\n\n> 可以看出有很多次mtx.try_lock()返回了false，并没有执行++counter操作。\n>\n> 如果把mtx.try_lock()改成mtx.lock()，则必定会阻塞其他线程。\n\n输出结果2:\n\n```c++\n$g++ -lpthread -std=c++11 -o main *.cpp\n$main\n100000 successful increases of the counter.\n```\n\n### std::recursive_mutex 介绍\n\nstd::recursive_mutex 与 std::mutex 一样，也是一种可以被上锁的对象，但是和 std::mutex 不同的是，std::recursive_mutex 允许同一个线程对互斥量多次上锁（即递归上锁），来获得对互斥量对象的多层所有权，std::recursive_mutex 释放互斥量时需要调用与该锁层次深度相同次数的 unlock()，可理解为 lock() 次数和 unlock() 次数相同，除此之外，std::recursive_mutex 的特性和 std::mutex 大致相同。\n\n```c++\n#include <iostream>       // std::cout\n#include <thread>         // std::thread\n#include <mutex>          // std::mutex\n\nvolatile int counter(0); // non-atomic counter\nstd::recursive_mutex  rmtx;           // locks access to counter\n\nvoid attempt_1k_increases() {\n    for (int i=0; i<10000; ++i) {\n        rmtx.lock();   \n        ++counter; \n    }\n    for (int i=0; i<10000; ++i) { \n        counter-=2; \n        rmtx.unlock();\n    }\n}\n\nint main (int argc, const char* argv[]) {\n    auto th = std::thread(attempt_1k_increases);\n    th.join();\n    std::cout << counter << \" successful increases of the counter.\\n\";\n\n    return 0;\n}\n```\n\n输出结果：\n\n```c++\n$g++ -lpthread -o main *.cpp\n$main\n-10000 successful increases of the counter.\n```\n\n### std::time_mutex 介绍\n\nstd::time_mutex 比 std::mutex 多了两个成员函数，try_lock_for()，try_lock_until()。\n\ntry_lock_for 函数接受一个时间范围，表示在这一段时间范围之内线程如果没有获得锁则被阻塞住（与 std::mutex 的 try_lock() 不同，try_lock 如果被调用时没有获得锁则直接返回 false），如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。\n\ntry_lock_until 函数则接受一个时间点作为参数，在指定时间点未到来之前线程如果没有获得锁则被阻塞住，如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。\n\n下面的小例子说明了 std::time_mutex 的用法（[参考](http://www.cplusplus.com/reference/mutex/timed_mutex/try_lock_for/)）。\n\n```c++\n#include <iostream>       // std::cout\n#include <chrono>         // std::chrono::milliseconds\n#include <thread>         // std::thread\n#include <mutex>          // std::timed_mutex\n\nstd::timed_mutex mtx;\n\nvoid fireworks() {\n  // waiting to get a lock: each thread prints \"-\" every 200ms:\n  while (!mtx.try_lock_for(std::chrono::milliseconds(200))) {\n    std::cout << \"-\";\n  }\n  // got a lock! - wait for 1s, then this thread prints \"*\"\n  std::this_thread::sleep_for(std::chrono::milliseconds(1000));\n  std::cout << \"*\\n\";\n  mtx.unlock();\n}\n\nint main ()\n{\n  std::thread threads[10];\n  // spawn 10 threads:\n  for (int i=0; i<10; ++i)\n    threads[i] = std::thread(fireworks);\n\n  for (auto& th : threads) th.join();\n\n  return 0;\n}\n```\n\n输出结果：\n\n> 线程输出*表示该线程已经正常退出，并且释放该锁。否则将每200ms尝试获取mutex🔒，直到成功为止。\n\n### std::recursive_timed_mutex 介绍\n\n和 std:recursive_mutex 与 std::mutex 的关系一样，std::recursive_timed_mutex 的特性也可以从 std::timed_mutex 推导出来，感兴趣的同鞋可以自行查阅。 ;-)\n\n### std::lock_guard 介绍\n\n与 Mutex RAII 相关，方便线程对互斥量上锁。例子（[参考](http://www.cplusplus.com/reference/mutex/lock_guard/)）:\n\n* 1.std::lock_guard 在构造函数中进行加锁，析构函数中进行解锁。\n* 2.锁在多线程编程中，使用较多，因此c++11提供了lock_guard模板类；在实际编程中，我们也可以根据自己的场景编写`resource_guard` RAII类，避免忘掉释放资源。\n\n```c++\n#include <iostream>       // std::cout\n#include <thread>         // std::thread\n#include <mutex>          // std::mutex, std::lock_guard\n#include <stdexcept>      // std::logic_error\n\nstd::mutex mtx;\n\nvoid print_even (int x) {\n    if (x%2==0) std::cout << x << \" is even\\n\";\n    else throw (std::logic_error(\"not even\"));\n}\n\nvoid print_thread_id (int id) {\n    try {\n        // using a local lock_guard to lock mtx guarantees unlocking on destruction / exception:\n        std::lock_guard<std::mutex> lck (mtx);\n        print_even(id);\n    }\n    catch (std::logic_error&) {\n        std::cout << \"[exception caught]\\n\";\n    }\n}\n\nint main ()\n{\n    std::thread threads[10];\n    // spawn 10 threads:\n    for (int i=0; i<10; ++i)\n        threads[i] = std::thread(print_thread_id,i+1);\n\n    for (auto& th : threads) th.join();\n\n    return 0;\n}\n```\n\n输出结果：\n\n```c++\n$g++ -lpthread -o main *.cpp\n$main\n[exception caught]\n4 is even\n[exception caught]\n2 is even\n[exception caught]\n6 is even\n8 is even\n[exception caught]\n[exception caught]\n10 is even\n```\n\n### std::unique_lock 介绍\n\n与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。例子（[参考](http://www.cplusplus.com/reference/mutex/unique_lock/)）：\n\n* 1.类 unique_lock 是通用互斥包装器，允许`延迟锁定、锁定的有时限尝试、递归锁定、所有权转移和与条件变量一同使用`。\n* 2.unique_lock比lock_guard使用更加灵活，功能更加强大。\n  使用unique_lock需要付出更多的时间、性能成本。\n\n```c++\n#include <iostream>       // std::cout\n#include <thread>         // std::thread\n#include <mutex>          // std::mutex, std::unique_lock\n\nstd::mutex mtx;           // mutex for critical section\n\nvoid print_block (int n, char c) {\n    // critical section (exclusive access to std::cout signaled by lifetime of lck):\n    std::unique_lock<std::mutex> lck (mtx);\n    for (int i=0; i<n; ++i) {\n        std::cout << c;\n    }\n    std::cout << '\\n';\n}\n\nint main ()\n{\n    std::thread th1 (print_block,50,'*');\n    std::thread th2 (print_block,50,'$');\n\n    th1.join();\n    th2.join();\n\n    return 0;\n}\n```\n\n输出结果：\n\n```c++\n$g++ -lpthread -o main *.cpp\n$main\n**************************************************\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n```\n\n\n\n好了，本文暂时讲到这里，还剩下 std::try_lock，std::lock，std::call_once 三个函数没有讲到，留在下一篇博客中讲吧 ;-)","content":"<p>Mutex 又称互斥量，C++ 11中与 Mutex 相关的类（包括锁类型）和函数都声明在 <mutex> 头文件中，所以如果你需要使用 std::mutex，就必须包含 <mutex> 头文件。</mutex></mutex></p>\n<h3 id=\"头文件介绍\"><mutex> 头文件介绍</mutex><a href=\"posts/Mutex介绍#头文件介绍\"></a></h3><h4 id=\"Mutex-系列类-四种\">Mutex 系列类(四种)<a href=\"posts/Mutex介绍#Mutex-系列类-四种\"></a></h4><ul>\n<li><p>std::mutex，最基本的 Mutex 类。</p>\n</li>\n<li><p>std::recursive_mutex，递归 Mutex 类。</p>\n</li>\n<li><p>std::time_mutex，定时 Mutex 类。</p>\n</li>\n<li><p>std::recursive_timed_mutex，定时递归 Mutex 类。</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<h4 id=\"Lock-类（两种）\">Lock 类（两种）<a href=\"posts/Mutex介绍#Lock-类（两种）\"></a></h4><ul>\n<li>std::lock_guard，与 Mutex RAII 相关，方便线程对互斥量上锁。</li>\n<li>std::unique_lock，与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。</li>\n</ul>\n<h4 id=\"其他类型\">其他类型<a href=\"posts/Mutex介绍#其他类型\"></a></h4><ul>\n<li>std::once_flag</li>\n<li>std::adopt_lock_t</li>\n<li>std::defer_lock_t</li>\n<li>std::try_to_lock_t</li>\n</ul>\n<h4 id=\"函数\">函数<a href=\"posts/Mutex介绍#函数\"></a></h4><ul>\n<li>std::try_lock，尝试同时对多个互斥量上锁。</li>\n<li>std::lock，可以同时对多个互斥量上锁。</li>\n<li>std::call_once，如果多个线程需要同时调用某个函数，call_once 可以保证多个线程对该函数只调用一次。</li>\n</ul>\n<h3 id=\"std-mutex-介绍\">std::mutex 介绍<a href=\"posts/Mutex介绍#std-mutex-介绍\"></a></h3><p>下面以 std::mutex 为例介绍 C++11 中的互斥量用法。</p>\n<p>std::mutex 是C++11 中最基本的互斥量，std::mutex 对象提供了独占所有权的特性——即不支持递归地对 std::mutex 对象上锁，而 std::recursive_lock 则可以递归地对互斥量对象上锁。</p>\n<h4 id=\"std-mutex-的成员函数\">std::mutex 的成员函数<a href=\"posts/Mutex介绍#std-mutex-的成员函数\"></a></h4><ul>\n<li>构造函数，std::mutex不允许拷贝构造，也不允许 move 拷贝，最初产生的 mutex 对象是处于 unlocked 状态的。</li>\n<li>lock()，调用线程将锁住该互斥量。线程调用该函数会发生下面 3 种情况：(1). 如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁。(2). 如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。</li>\n<li>unlock()， 解锁，释放对互斥量的所有权。</li>\n<li>try_lock()，尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面 3 种情况，(1). 如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量。(2). 如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。</li>\n</ul>\n<p>下面给出一个与 std::mutex 的小例子（<a href=\"http://www.cplusplus.com/reference/mutex/mutex/try_lock/\" target=\"_blank\" rel=\"noopener\">参考</a>）</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;       // std::cout</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt;         // std::thread</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;mutex&gt;          // std::mutex</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> <span class=\"title\">counter</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>; <span class=\"comment\">// non-atomic counter</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::mutex mtx;           <span class=\"comment\">// locks access to counter</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">attempt_10k_increases</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10000</span>; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mtx.try_lock()) &#123;   <span class=\"comment\">// only increase if currently not locked:</span></span><br><span class=\"line\">            ++counter;</span><br><span class=\"line\">            mtx.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::thread threads[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10</span>; ++i)</span><br><span class=\"line\">        threads[i] = <span class=\"built_in\">std</span>::thread(attempt_10k_increases);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; th : threads) th.join();</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; counter &lt;&lt; <span class=\"string\">\" successful increases of the counter.\\n\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$g++ -lpthread -<span class=\"built_in\">std</span>=c++<span class=\"number\">11</span> -o main *.cpp</span><br><span class=\"line\">$main</span><br><span class=\"line\"><span class=\"number\">9012</span> successful increases of the counter.</span><br></pre></td></tr></table></div></figure>\n\n<blockquote>\n<p>可以看出有很多次mtx.try_lock()返回了false，并没有执行++counter操作。</p>\n<p>如果把mtx.try_lock()改成mtx.lock()，则必定会阻塞其他线程。</p>\n</blockquote>\n<p>输出结果2:</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$g++ -lpthread -<span class=\"built_in\">std</span>=c++<span class=\"number\">11</span> -o main *.cpp</span><br><span class=\"line\">$main</span><br><span class=\"line\"><span class=\"number\">100000</span> successful increases of the counter.</span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"std-recursive-mutex-介绍\">std::recursive_mutex 介绍<a href=\"posts/Mutex介绍#std-recursive-mutex-介绍\"></a></h3><p>std::recursive_mutex 与 std::mutex 一样，也是一种可以被上锁的对象，但是和 std::mutex 不同的是，std::recursive_mutex 允许同一个线程对互斥量多次上锁（即递归上锁），来获得对互斥量对象的多层所有权，std::recursive_mutex 释放互斥量时需要调用与该锁层次深度相同次数的 unlock()，可理解为 lock() 次数和 unlock() 次数相同，除此之外，std::recursive_mutex 的特性和 std::mutex 大致相同。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;       // std::cout</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt;         // std::thread</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;mutex&gt;          // std::mutex</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> <span class=\"title\">counter</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>; <span class=\"comment\">// non-atomic counter</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::recursive_mutex  rmtx;           <span class=\"comment\">// locks access to counter</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">attempt_1k_increases</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10000</span>; ++i) &#123;</span><br><span class=\"line\">        rmtx.lock();   </span><br><span class=\"line\">        ++counter; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10000</span>; ++i) &#123; </span><br><span class=\"line\">        counter-=<span class=\"number\">2</span>; </span><br><span class=\"line\">        rmtx.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> th = <span class=\"built_in\">std</span>::thread(attempt_1k_increases);</span><br><span class=\"line\">    th.join();</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; counter &lt;&lt; <span class=\"string\">\" successful increases of the counter.\\n\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$g++ -lpthread -o main *.cpp</span><br><span class=\"line\">$main</span><br><span class=\"line\"><span class=\"number\">-10000</span> successful increases of the counter.</span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"std-time-mutex-介绍\">std::time_mutex 介绍<a href=\"posts/Mutex介绍#std-time-mutex-介绍\"></a></h3><p>std::time_mutex 比 std::mutex 多了两个成员函数，try_lock_for()，try_lock_until()。</p>\n<p>try_lock_for 函数接受一个时间范围，表示在这一段时间范围之内线程如果没有获得锁则被阻塞住（与 std::mutex 的 try_lock() 不同，try_lock 如果被调用时没有获得锁则直接返回 false），如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。</p>\n<p>try_lock_until 函数则接受一个时间点作为参数，在指定时间点未到来之前线程如果没有获得锁则被阻塞住，如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。</p>\n<p>下面的小例子说明了 std::time_mutex 的用法（<a href=\"http://www.cplusplus.com/reference/mutex/timed_mutex/try_lock_for/\" target=\"_blank\" rel=\"noopener\">参考</a>）。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;       // std::cout</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;chrono&gt;         // std::chrono::milliseconds</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt;         // std::thread</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;mutex&gt;          // std::timed_mutex</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">std</span>::timed_mutex mtx;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fireworks</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// waiting to get a lock: each thread prints \"-\" every 200ms:</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!mtx.try_lock_for(<span class=\"built_in\">std</span>::chrono::milliseconds(<span class=\"number\">200</span>))) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"-\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// got a lock! - wait for 1s, then this thread prints \"*\"</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::this_thread::sleep_for(<span class=\"built_in\">std</span>::chrono::milliseconds(<span class=\"number\">1000</span>));</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"*\\n\"</span>;</span><br><span class=\"line\">  mtx.unlock();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::thread threads[<span class=\"number\">10</span>];</span><br><span class=\"line\">  <span class=\"comment\">// spawn 10 threads:</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10</span>; ++i)</span><br><span class=\"line\">    threads[i] = <span class=\"built_in\">std</span>::thread(fireworks);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; th : threads) th.join();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>输出结果：</p>\n<blockquote>\n<p>线程输出*表示该线程已经正常退出，并且释放该锁。否则将每200ms尝试获取mutex🔒，直到成功为止。</p>\n</blockquote>\n<h3 id=\"std-recursive-timed-mutex-介绍\">std::recursive_timed_mutex 介绍<a href=\"posts/Mutex介绍#std-recursive-timed-mutex-介绍\"></a></h3><p>和 std:recursive_mutex 与 std::mutex 的关系一样，std::recursive_timed_mutex 的特性也可以从 std::timed_mutex 推导出来，感兴趣的同鞋可以自行查阅。 ;-)</p>\n<h3 id=\"std-lock-guard-介绍\">std::lock_guard 介绍<a href=\"posts/Mutex介绍#std-lock-guard-介绍\"></a></h3><p>与 Mutex RAII 相关，方便线程对互斥量上锁。例子（<a href=\"http://www.cplusplus.com/reference/mutex/lock_guard/\" target=\"_blank\" rel=\"noopener\">参考</a>）:</p>\n<ul>\n<li>1.std::lock_guard 在构造函数中进行加锁，析构函数中进行解锁。</li>\n<li>2.锁在多线程编程中，使用较多，因此c++11提供了lock_guard模板类；在实际编程中，我们也可以根据自己的场景编写<code>resource_guard</code> RAII类，避免忘掉释放资源。</li>\n</ul>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;       // std::cout</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt;         // std::thread</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;mutex&gt;          // std::mutex, std::lock_guard</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdexcept&gt;      // std::logic_error</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">std</span>::mutex mtx;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print_even</span> <span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x%<span class=\"number\">2</span>==<span class=\"number\">0</span>) <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; x &lt;&lt; <span class=\"string\">\" is even\\n\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">throw</span> (<span class=\"built_in\">std</span>::logic_error(<span class=\"string\">\"not even\"</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print_thread_id</span> <span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// using a local lock_guard to lock mtx guarantees unlocking on destruction / exception:</span></span><br><span class=\"line\">        <span class=\"built_in\">std</span>::lock_guard&lt;<span class=\"built_in\">std</span>::mutex&gt; lck (mtx);</span><br><span class=\"line\">        print_even(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (<span class=\"built_in\">std</span>::logic_error&amp;) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"[exception caught]\\n\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::thread threads[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"comment\">// spawn 10 threads:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10</span>; ++i)</span><br><span class=\"line\">        threads[i] = <span class=\"built_in\">std</span>::thread(print_thread_id,i+<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; th : threads) th.join();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$g++ -lpthread -o main *.cpp</span><br><span class=\"line\">$main</span><br><span class=\"line\">[exception caught]</span><br><span class=\"line\"><span class=\"number\">4</span> is even</span><br><span class=\"line\">[exception caught]</span><br><span class=\"line\"><span class=\"number\">2</span> is even</span><br><span class=\"line\">[exception caught]</span><br><span class=\"line\"><span class=\"number\">6</span> is even</span><br><span class=\"line\"><span class=\"number\">8</span> is even</span><br><span class=\"line\">[exception caught]</span><br><span class=\"line\">[exception caught]</span><br><span class=\"line\"><span class=\"number\">10</span> is even</span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"std-unique-lock-介绍\">std::unique_lock 介绍<a href=\"posts/Mutex介绍#std-unique-lock-介绍\"></a></h3><p>与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。例子（<a href=\"http://www.cplusplus.com/reference/mutex/unique_lock/\" target=\"_blank\" rel=\"noopener\">参考</a>）：</p>\n<ul>\n<li>1.类 unique_lock 是通用互斥包装器，允许<code>延迟锁定、锁定的有时限尝试、递归锁定、所有权转移和与条件变量一同使用</code>。</li>\n<li>2.unique_lock比lock_guard使用更加灵活，功能更加强大。<br>使用unique_lock需要付出更多的时间、性能成本。</li>\n</ul>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;       // std::cout</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt;         // std::thread</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;mutex&gt;          // std::mutex, std::unique_lock</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">std</span>::mutex mtx;           <span class=\"comment\">// mutex for critical section</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print_block</span> <span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">char</span> c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// critical section (exclusive access to std::cout signaled by lifetime of lck):</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::unique_lock&lt;<span class=\"built_in\">std</span>::mutex&gt; lck (mtx);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n; ++i) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"function\">thread <span class=\"title\">th1</span> <span class=\"params\">(print_block,<span class=\"number\">50</span>,<span class=\"string\">'*'</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"function\">thread <span class=\"title\">th2</span> <span class=\"params\">(print_block,<span class=\"number\">50</span>,<span class=\"string\">'$'</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    th1.join();</span><br><span class=\"line\">    th2.join();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$g++ -lpthread -o main *.cpp</span><br><span class=\"line\">$main</span><br><span class=\"line\">**************************************************</span><br><span class=\"line\">$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$</span><br></pre></td></tr></table></div></figure>\n\n<p>好了，本文暂时讲到这里，还剩下 std::try_lock，std::lock，std::call_once 三个函数没有讲到，留在下一篇博客中讲吧 ;-)</p>\n","slug":"Mutex介绍","updated":"2019-09-05T12:18:27.005Z","comments":true,"link":"posts/Mutex介绍","permalink":"https://shuntan.github.io/posts/Mutex介绍/","excerpt":"Mutex 又称互斥量，C++ 11中与 Mutex 相关的类（包括锁类型）和函数都声明在 头文件中，所以如果你需要使用 std::mutex，就必须包含 头文件。 头文件介绍Mutex 系列类(四种) std::mutex，最基本的 Mutex 类。 std::recursive_mutex，递归 Mutex 类。 std::time_mutex，定时 Mutex 类。 std::recursive_timed_mutex，定时递归 Mutex 类。","categories":[{"name":"C++","slug":"C","permalink":"https://shuntan.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://shuntan.github.io/tags/C/"}]},{"title":"C++之Lambda研究","date":"2019-06-03T12:20:52.000Z","path":"posts/Lambda/","text":"1. 前言本文代码测试环境为“GCC-9.1.0”，有关编译器的安装请参考《安装GCC-8.3.0及其依赖》，适用于“GCC-9.1.0”。 本文试图揭露Lambda背后一面，以方便更好的理解和掌握Lambda。Lambda代码段实际为一个编译器生成的类的“operator ()”函数，编译器会为每一个Lambda函数生成一个匿名的类（在C++中，类和结构体实际一样，无本质区别，除了默认的访问控制）。 对Lambda的最简单理解，是将它看作一个匿名类（或结构体），实际上也确实如此，编译器把Lambda编译成了匿名类。 2. 示例1先看一段几乎最简单的Lambda代码： 123456// g++ -g -o a1 a1.cpp -std=c++11#include &lt;stdio.h&gt;int main() &#123; auto f = [] &#123; printf(\"f\\n\"); &#125;; // 注意“&#125;”后的“;”必不可少，否则编译报错 return 0;&#125; 如果Lambda表达式（或函数）没有以“;”结尾，则编译时将报如下错误： 1234a3.cpp: In function 'int main()':a3.cpp:4:3: error: expected ',' or ';' before 'return' 4 | return 0; | ^~~~~~ Lambda之所以神奇，这得益于C++编译器的工作，上述“f”实际长这样： 12type = struct &lt;lambda()&gt; &#123;&#125; 一个匿名的类（或结构体），实际上还有一个成员函数“operator () const”。注意这里成员函数是”const”类型，这是默认的。如果需非”const”成员函数，需要加”mutable”修饰，如下所示： 1auto f = [n]() mutable &#123; printf(\"%d\\n\", n); &#125;; 上面例子对应的匿名类没有任何类数据成员，现在来个有类数据成员的代码： 12345678// g++ -g -o a1 a1.cpp -std=c++11#include &lt;stdio.h&gt;int main() &#123; int n = 3; auto f = [n] &#123; printf(\"%d\\n\", n); &#125;; f(); // 这里实际调用的是匿名类的成员函数“operator ()” return 0;&#125; 这时，“f”实际长这样，它是一个含有类数据成员的匿名类，而不再是空无一特的类： 123type = struct &lt;lambda()&gt; &#123; int __n;&#125; 3. 示例2继续来个变种： 12345678910// g++ -g -o a1 a1.cpp -std=c++11#include &lt;stdio.h&gt;int main() &#123; int n = 3; auto f = [&amp;n]() mutable &#123; printf(\"%d\\n\", n); &#125;; f(); return 0;&#125; 这时，“f”实际长这样，一个包含了引用类型的匿名类： 123type = struct &lt;lambda()&gt; &#123; int &amp;__n;&#125; 4. 示例3继续变种，“&amp;”的作用让Lambda函数可使用Lambda所在作用域内所有可见的局部变量（包括Lambda所在类的this），并且是以引用传递方式： 123456789// g++ -g -o a1 a1.cpp -std=c++11#include &lt;stdio.h&gt;int main() &#123; int n = 3; auto f = [&amp;]() mutable &#123; printf(\"%d\\n\", n); &#125;; f(); return 0;&#125; “f”实际长这样： 123type = struct &lt;lambda()&gt; &#123; int &amp;__n;&#125; 变稍复杂一点： 123456789// g++ -g -o a1 a1.cpp -std=c++11#include &lt;stdio.h&gt;int main() &#123; int n = 3; int m = 5; auto f = [&amp;]() mutable &#123; printf(\"%d\\n\", n); &#125;; f(); return 0;&#125; 可以看到，“f”并没有发生变化： 123type = struct &lt;lambda()&gt; &#123; int &amp;__n;&#125; 5. 示例4继续增加复杂度： 123456789// g++ -g -o a1 a1.cpp -std=c++11#include &lt;stdio.h&gt;int main() &#123; int n = 3; int m = 5; auto f = [&amp;]() mutable &#123; printf(\"%d,%d\\n\", n, m); &#125;; f(); return 0;&#125; 可以看到“f”变了： 1234type = struct &lt;lambda()&gt; &#123; int &amp;__n; int &amp;__m;&#125; 从上面不难看出，编译器只会把Lambda函数用到的变量打包进对应的匿名类。继续一个稍复杂点的： 1234567891011121314// g++ -g -o a1 a1.cpp -std=c++11#include &lt;stdio.h&gt;struct X &#123; void foo() &#123; printf(\"foo\\n\"); &#125; void xoo() &#123; auto f = [&amp;] &#123; foo(); &#125;; f(); &#125;&#125;;int main() &#123; X().xoo(); return 0;&#125; 这时，“f”实际长这样： 123type = struct X::&lt;lambda()&gt; &#123; X * const __this; // X类型的指针（非对象）&#125; 如果将“auto f = [&amp;] { foo(); };”中的“&amp;”去掉，则会遇到编译错误，提示“this”没有被Lambda函数捕获： 12345a2.cpp: In lambda function:a2.cpp:5:23: error: 'this' was not captured for this lambda function 5 | auto f = [] &#123; foo(); &#125;; | ^a2.cpp:5:23: error: cannot call member function 'void X::foo()' without object 改成下列方式捕获也是可以的： 1234567891011121314// g++ -g -o a1 a1.cpp -std=c++11#include &lt;stdio.h&gt;struct X &#123; void foo() &#123; printf(\"foo\\n\"); &#125; void xoo() &#123; auto f = [this] &#123; foo(); &#125;; f(); &#125;&#125;;int main() &#123; X().xoo(); return 0;&#125; 如果是C++17，还可以这样： 1234567891011121314// g++ -g -o a1 a1.cpp -std=c++17#include &lt;stdio.h&gt;struct X &#123; void foo() &#123; printf(\"foo\\n\"); &#125; void xoo() &#123; auto f = [*this]() mutable &#123; foo(); &#125;; f(); &#125;&#125;;int main() &#123; X().xoo(); return 0;&#125; 注意得有“mutable”修饰，不然报如下编译错误： 1234567a2.cpp: In lambda function:a2.cpp:5:30: error: passing 'const X' as 'this' argument discards qualifiers [-fpermissive] 5 | auto f = [*this]() &#123; foo(); &#125;; | ^a2.cpp:3:8: note: in call to 'void X::foo()' 3 | void foo() &#123; printf(\"foo\\n\"); &#125; | ^~~ 也可以这样： 123456789101112131415// g++ -g -o a1 a1.cpp -std=c++17#include &lt;stdio.h&gt;struct X &#123; void foo() &#123; printf(\"foo\\n\"); &#125; void xoo() &#123; auto f = [&amp;,*this]() mutable &#123; foo(); &#125;; f(); &#125;&#125;;int main() &#123; X().xoo(); return 0;&#125; 使用“*this”时的“f”样子如下： 123type = struct X::&lt;lambda()&gt; &#123; X __this; // X类型的对象（非指针）&#125; 6. 示例5继续研究，使用C++ RTTI（Run-Time Type Identification，运行时类型识别）设施“typeid”查看Lambda函数： 123456789101112131415// g++ -g -o a1 a1.cpp -std=c++11#include &lt;stdio.h&gt;#include &lt;typeinfo&gt;struct X &#123; void xoo() &#123; auto f = [] &#123; printf(\"f\\n\"); &#125;; printf(\"%s\\n\", typeid(f).name()); // 注：typeid返回值类型为“std::type_info” &#125;&#125;;int main() &#123; X().xoo(); return 0;&#125; 运行输出： ZN1X3xooEvEUlvE_ 7. 匿名类规则编译器为Lambda生成的匿名类规则（不同标准有区别）： 构造函数 拷贝构造函数 ClosureType()&nbsp;=&nbsp;delete; C++14前 ClosureType()&nbsp;=&nbsp;default; C++20起， 仅当未指定任何俘获时 ClosureType(const&nbsp;ClosureType&amp;&nbsp;)&nbsp;=&nbsp;default; C++14起 ClosureType(ClosureType&amp;&amp;&nbsp;)&nbsp;=&nbsp;default; C++14起 拷贝复制函数 ClosureType&amp;&nbsp;operator=(const&nbsp;ClosureType&amp;)&nbsp;=&nbsp;delete; C++20前 ClosureType&amp;&nbsp;operator=(const&nbsp;ClosureType&amp;)&nbsp;=&nbsp;default; ClosureType&amp;&nbsp;operator=(ClosureType&amp;&amp;)&nbsp;=&nbsp;default; C++20起， 仅当未指定任何俘获时 ClosureType&amp;&nbsp;operator=(const&nbsp;ClosureType&amp;)&nbsp;=&nbsp;delete; C++20起，其他情况 析构函数 ~ClosureType()&nbsp;=&nbsp;default; 析构函数是隐式声明的 对于标记为“delete”的函数是不能调用的，如下列代码中的“f2 = f1;”将触发编译错误： 1234567891011int main() &#123; auto f1 = []&#123;&#125;; auto f2 = f1; f2 = f1; return 0;&#125; 上列代码在C++11、C++14和C++17均会报错。不过如规则所示，C++20（含C++2a）上则可以正常编译： 1234567a3.cpp: In function 'int main()':a3.cpp:4:8: error: use of deleted function 'main()::&lt;lambda()&gt;&amp; main()::&lt;lambda()&gt;::operator=(const main()::&lt;lambda()&gt;&amp;)' 4 | f2 = f1; | ^~a3.cpp:2:14: note: a lambda closure type has a deleted copy assignment operator 2 | auto f1 = []&#123;&#125;; | ^ 希望通过本文，对理解Lambda有所帮助。 8. 参考资料 1) https://zh.cppreference.com/w/cpp/language/lambda 2) https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=vs-2019 3) https://en.cpprefeence.com/w/cpp/language/lambda 4) https://stackoverflow.com/questions/7627098/what-is-a-lambda-expression-in-c11 5) https://www.cprogramming.com/c++11/c++11-lambda-closures.html 作者：一见来源：CSDN原文：https://blog.csdn.net/Aquester/article/details/90691479","raw":"---\ntitle: C++之Lambda研究\ntags: C++\ncategories: C++\nabbrlink: 95b963ee\ndate: 2019-06-03 20:20:52\ncopyright:\ntype:\nkeyword:\ntop:\ncomments:\npassword:\ndescription:\nthumbnail:\n---\n\n# 1. 前言\n\n本文代码测试环境为“GCC-9.1.0”，有关编译器的安装请参考《[安装GCC-8.3.0及其依赖](https://blog.csdn.net/Aquester/article/details/89735466)》，适用于“GCC-9.1.0”。\n\n本文试图揭露Lambda背后一面，以方便更好的理解和掌握Lambda。Lambda代码段实际为一个编译器生成的类的“operator ()”函数，编译器会为每一个Lambda函数生成一个匿名的类（在C++中，类和结构体实际一样，无本质区别，除了默认的访问控制）。\n\n对Lambda的最简单理解，是将它看作一个匿名类（或结构体），实际上也确实如此，编译器把Lambda编译成了匿名类。\n\n<!-- more -->\n\n# 2. 示例1\n先看一段几乎最简单的Lambda代码：\n\n```\n// g++ -g -o a1 a1.cpp -std=c++11\n#include <stdio.h>\nint main() {\n  auto f = [] { printf(\"f\\n\"); }; // 注意“}”后的“;”必不可少，否则编译报错\n  return 0;\n}\n```\n\n如果Lambda表达式（或函数）没有以“;”结尾，则编译时将报如下错误：\n\n```\na3.cpp: In function 'int main()':\na3.cpp:4:3: error: expected ',' or ';' before 'return'\n    4 |   return 0;\n      |   ^~~~~~\n```\n\n\nLambda之所以神奇，这得益于C++编译器的工作，上述“f”实际长这样：\n\n```\ntype = struct <lambda()> {\n}\n```\n\n\n一个匿名的类（或结构体），实际上还有一个成员函数“operator () const”。注意这里成员函数是”const”类型，这是默认的。如果需非”const”成员函数，需要加”mutable”修饰，如下所示：\n\n```\nauto f = [n]() mutable { printf(\"%d\\n\", n); };\n```\n\n\n上面例子对应的匿名类没有任何类数据成员，现在来个有类数据成员的代码：\n\n```\n// g++ -g -o a1 a1.cpp -std=c++11\n#include <stdio.h>\nint main() {\n  int n = 3;\n  auto f = [n] { printf(\"%d\\n\", n); };\n  f(); // 这里实际调用的是匿名类的成员函数“operator ()”\n  return 0;\n}\n```\n\n\n这时，“f”实际长这样，它是一个含有类数据成员的匿名类，而不再是空无一特的类：\n\n```\ntype = struct <lambda()> {\n    int __n;\n}\n```\n\n# 3. 示例2\n继续来个变种：\n\n```\n// g++ -g -o a1 a1.cpp -std=c++11\n\n#include <stdio.h>\n\nint main() {\n  int n = 3;\n  auto f = [&n]() mutable { printf(\"%d\\n\", n); };\n  f();\n  return 0;\n}\n```\n\n\n这时，“f”实际长这样，一个包含了引用类型的匿名类：\n\n```\ntype = struct <lambda()> {\n    int &__n;\n}\n```\n\n# 4. 示例3\n继续变种，“&”的作用让Lambda函数可使用Lambda所在作用域内所有可见的局部变量（包括Lambda所在类的this），并且是以引用传递方式：\n\n```\n// g++ -g -o a1 a1.cpp -std=c++11\n#include <stdio.h>\nint main() {\n  int n = 3;\n  auto f = [&]() mutable { printf(\"%d\\n\", n); };\n  f();\n  return 0;\n\n}\n```\n\n\n“f”实际长这样：\n\n```\ntype = struct <lambda()> {\n    int &__n;\n}\n```\n\n\n变稍复杂一点：\n\n```\n// g++ -g -o a1 a1.cpp -std=c++11\n#include <stdio.h>\nint main() {\n  int n = 3;\n  int m = 5;\n  auto f = [&]() mutable { printf(\"%d\\n\", n); };\n  f();\n  return 0;\n}\n```\n\n\n可以看到，“f”并没有发生变化：\n\n```\ntype = struct <lambda()> {\n    int &__n;\n}\n```\n\n# 5. 示例4\n继续增加复杂度：\n\n```\n// g++ -g -o a1 a1.cpp -std=c++11\n#include <stdio.h>\nint main() {\n  int n = 3;\n  int m = 5;\n  auto f = [&]() mutable { printf(\"%d,%d\\n\", n, m); };\n  f();\n  return 0;\n}\n```\n\n\n可以看到“f”变了：\n\n```\ntype = struct <lambda()> {\n    int &__n;\n    int &__m;\n}\n```\n\n\n从上面不难看出，编译器只会把Lambda函数用到的变量打包进对应的匿名类。继续一个稍复杂点的：\n\n```\n// g++ -g -o a1 a1.cpp -std=c++11\n#include <stdio.h>\nstruct X {\n  void foo() { printf(\"foo\\n\"); }\n  void xoo() {\n    auto f = [&] { foo(); };\n    f();\n  }\n};\n\nint main() {\n  X().xoo();\n  return 0;\n}\n```\n\n\n这时，“f”实际长这样：\n\n```\ntype = struct X::<lambda()> {\n    X * const __this; // X类型的指针（非对象）\n}\n```\n\n\n如果将“auto f = [&] { foo(); };”中的“&”去掉，则会遇到编译错误，提示“this”没有被Lambda函数捕获：\n\n```\na2.cpp: In lambda function:\na2.cpp:5:23: error: 'this' was not captured for this lambda function\n    5 |     auto f = [] { foo(); };\n      |                       ^\na2.cpp:5:23: error: cannot call member function 'void X::foo()' without object\n```\n\n改成下列方式捕获也是可以的：\n\n```\n// g++ -g -o a1 a1.cpp -std=c++11\n#include <stdio.h>\nstruct X {\n  void foo() { printf(\"foo\\n\"); }\n  void xoo() {\n    auto f = [this] { foo(); };\n    f();\n  }\n};\n\nint main() {\n  X().xoo();\n  return 0;\n}\n\n```\n\n如果是C++17，还可以这样：\n\n```\n// g++ -g -o a1 a1.cpp -std=c++17\n#include <stdio.h>\nstruct X {\n  void foo() { printf(\"foo\\n\"); }\n  void xoo() {\n    auto f = [*this]() mutable { foo(); };\n    f();\n  }\n};\n\nint main() {\n  X().xoo();\n  return 0;\n}\n```\n\n\n注意得有“mutable”修饰，不然报如下编译错误：\n\n```\na2.cpp: In lambda function:\na2.cpp:5:30: error: passing 'const X' as 'this' argument discards qualifiers [-fpermissive]\n    5 |     auto f = [*this]() { foo(); };\n      |                              ^\na2.cpp:3:8: note:   in call to 'void X::foo()'\n    3 |   void foo() { printf(\"foo\\n\"); }\n      |        ^~~\n```\n\n也可以这样：\n\n```\n// g++ -g -o a1 a1.cpp -std=c++17\n\n#include <stdio.h>\nstruct X {\n  void foo() { printf(\"foo\\n\"); }\n  void xoo() {\n    auto f = [&,*this]() mutable { foo(); };\n    f();\n  }\n};\n\nint main() {\n  X().xoo();\n  return 0;\n}\n```\n\n\n使用“*this”时的“f”样子如下：\n\n```\ntype = struct X::<lambda()> {\n    X __this; // X类型的对象（非指针）\n}\n```\n\n# 6. 示例5\n继续研究，使用C++ RTTI（Run-Time Type Identification，运行时类型识别）设施“typeid”查看Lambda函数：\n\n```\n// g++ -g -o a1 a1.cpp -std=c++11\n#include <stdio.h>\n#include <typeinfo>\nstruct X {\n  void xoo() {\n    auto f = [] { printf(\"f\\n\"); };\n    printf(\"%s\\n\", typeid(f).name());\n    // 注：typeid返回值类型为“std::type_info”\n  }\n};\n\nint main() {\n  X().xoo();\n  return 0;\n}\n```\n\n运行输出：\n\n`ZN1X3xooEvEUlvE_`\n\n# 7. 匿名类规则\n编译器为Lambda生成的匿名类规则（不同标准有区别）：\n<table align=\"center\" border=\"1\" cellspacing=\"0\"><tbody><tr><td rowspan=\"4\">\t\t\t<p style=\"margin-left:0pt;\">构造函数</p>\t\t\t<p style=\"margin-left:0pt;\">拷贝构造函数</p>\t\t\t</td>\t\t\t<td style=\"vertical-align:top;width:250.8pt;\">\t\t\t<p style=\"margin-left:0pt;\">ClosureType()&nbsp;=&nbsp;<strong>delete</strong>;</p>\t\t\t</td>\t\t\t<td style=\"vertical-align:top;width:105.95pt;\">\t\t\t<p style=\"margin-left:0pt;\">C++14前</p>\t\t\t</td>\t\t</tr><tr><td style=\"vertical-align:top;width:250.8pt;\">\t\t\t<p style=\"margin-left:0pt;\">ClosureType()&nbsp;=&nbsp;default;</p>\t\t\t</td>\t\t\t<td style=\"vertical-align:top;width:105.95pt;\">\t\t\t<p style=\"margin-left:0pt;\">C++20起，</p>\t\t\t<p style=\"margin-left:0pt;\">仅当未指定任何俘获时</p>\t\t\t</td>\t\t</tr><tr><td style=\"vertical-align:top;width:250.8pt;\">\t\t\t<p style=\"margin-left:0pt;\">ClosureType(const&nbsp;ClosureType&amp;&nbsp;)&nbsp;=&nbsp;default;</p>\t\t\t</td>\t\t\t<td style=\"vertical-align:top;width:105.95pt;\">\t\t\t<p style=\"margin-left:0pt;\">C++14起</p>\t\t\t</td>\t\t</tr><tr><td style=\"vertical-align:top;width:250.8pt;\">\t\t\t<p style=\"margin-left:0pt;\">ClosureType(ClosureType&amp;&amp;&nbsp;)&nbsp;=&nbsp;default;</p>\t\t\t</td>\t\t\t<td style=\"vertical-align:top;width:105.95pt;\">\t\t\t<p style=\"margin-left:0pt;\">C++14起</p>\t\t\t</td>\t\t</tr><tr><td rowspan=\"3\" style=\"width:69.35pt;\">\t\t\t<p style=\"margin-left:0pt;\">拷贝复制函数</p>\t\t\t</td>\t\t\t<td style=\"vertical-align:top;width:250.8pt;\">\t\t\t<p style=\"margin-left:0pt;\">ClosureType&amp;&nbsp;operator=(const&nbsp;ClosureType&amp;)&nbsp;=&nbsp;<strong>delete</strong>;</p>\t\t\t</td>\t\t\t<td style=\"vertical-align:top;width:105.95pt;\">\t\t\t<p style=\"margin-left:0pt;\"><span style=\"color:#0000ff;\"><strong>C++20前</strong></span></p>\t\t\t</td>\t\t</tr><tr><td style=\"vertical-align:top;width:250.8pt;\">\t\t\t<p style=\"margin-left:0pt;\">ClosureType&amp;&nbsp;operator=(const&nbsp;ClosureType&amp;)&nbsp;=&nbsp;default;</p>\t\t\t<p style=\"margin-left:0pt;\">ClosureType&amp;&nbsp;operator=(ClosureType&amp;&amp;)&nbsp;=&nbsp;default;</p>\t\t\t</td>\t\t\t<td style=\"vertical-align:top;width:105.95pt;\">\t\t\t<p style=\"margin-left:0pt;\">C++20起，</p>\t\t\t<p style=\"margin-left:0pt;\">仅当未指定任何俘获时</p>\t\t\t</td>\t\t</tr><tr><td style=\"vertical-align:top;width:250.8pt;\">\t\t\t<p style=\"margin-left:0pt;\">ClosureType&amp;&nbsp;operator=(const&nbsp;ClosureType&amp;)&nbsp;=&nbsp;<strong>delete</strong>;</p>\t\t\t</td>\t\t\t<td style=\"vertical-align:top;width:105.95pt;\">\t\t\t<p style=\"margin-left:0pt;\">C++20起，其他情况</p>\t\t\t</td>\t\t</tr><tr><td style=\"vertical-align:top;width:69.35pt;\">\t\t\t<p style=\"margin-left:0pt;\">析构函数</p>\t\t\t</td>\t\t\t<td style=\"vertical-align:top;width:250.8pt;\">\t\t\t<p style=\"margin-left:0pt;\">~ClosureType()&nbsp;=&nbsp;default;</p>\t\t\t</td>\t\t\t<td style=\"vertical-align:top;width:105.95pt;\">\t\t\t<p style=\"margin-left:0pt;\">析构函数是隐式声明的</p>\t\t\t</td>\t\t</tr></tbody></table>\n对于标记为“delete”的函数是不能调用的，如下列代码中的“f2 = f1;”将触发编译错误：\n\n```\nint main() {\n\n  auto f1 = []{};\n\n  auto f2 = f1;\n\n  f2 = f1;\n\n  return 0;\n\n}\n```\n\n上列代码在C++11、C++14和C++17均会报错。不过如规则所示，C++20（含C++2a）上则可以正常编译：\n\n```\na3.cpp: In function 'int main()':\na3.cpp:4:8: error: use of deleted function 'main()::<lambda()>& main()::<lambda()>::operator=(const main()::<lambda()>&)'\n    4 |   f2 = f1;\n      |        ^~\na3.cpp:2:14: note: a lambda closure type has a deleted copy assignment operator\n    2 |   auto f1 = []{};\n      |              ^\n```\n\n\n希望通过本文，对理解Lambda有所帮助。\n\n# 8. 参考资料\n* 1) [https://zh.cppreference.com/w/cpp/language/lambda](https://zh.cppreference.com/w/cpp/language/lambda)\n\n* 2) [https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=vs-2019](https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=vs-2019)\n\n* 3) [https://en.cpprefeence.com/w/cpp/language/lambda](https://en.cpprefeence.com/w/cpp/language/lambda)\n\n* 4) [https://stackoverflow.com/questions/7627098/what-is-a-lambda-expression-in-c11](https://stackoverflow.com/questions/7627098/what-is-a-lambda-expression-in-c11)\n\n* 5) [https://www.cprogramming.com/c++11/c++11-lambda-closures.html](https://www.cprogramming.com/c++11/c++11-lambda-closures.html)\n\n---------------------\n{% note info %}\n\n作者：一见 \n来源：CSDN \n原文：https://blog.csdn.net/Aquester/article/details/90691479 \n\n{% endnote %}\n","content":"<h1 id=\"1-前言\">1. 前言<a href=\"posts/Lambda#1-前言\"></a></h1><p>本文代码测试环境为“GCC-9.1.0”，有关编译器的安装请参考《<a href=\"https://blog.csdn.net/Aquester/article/details/89735466\" target=\"_blank\" rel=\"noopener\">安装GCC-8.3.0及其依赖</a>》，适用于“GCC-9.1.0”。</p>\n<p>本文试图揭露Lambda背后一面，以方便更好的理解和掌握Lambda。Lambda代码段实际为一个编译器生成的类的“operator ()”函数，编译器会为每一个Lambda函数生成一个匿名的类（在C++中，类和结构体实际一样，无本质区别，除了默认的访问控制）。</p>\n<p>对Lambda的最简单理解，是将它看作一个匿名类（或结构体），实际上也确实如此，编译器把Lambda编译成了匿名类。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"2-示例1\">2. 示例1<a href=\"posts/Lambda#2-示例1\"></a></h1><p>先看一段几乎最简单的Lambda代码：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// g++ -g -o a1 a1.cpp -std=c++11</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> f = [] &#123; <span class=\"built_in\">printf</span>(<span class=\"string\">\"f\\n\"</span>); &#125;; <span class=\"comment\">// 注意“&#125;”后的“;”必不可少，否则编译报错</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>如果Lambda表达式（或函数）没有以“;”结尾，则编译时将报如下错误：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a3.cpp: In <span class=\"function\"><span class=\"keyword\">function</span> '<span class=\"title\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span>':</span></span><br><span class=\"line\">a3.cpp:<span class=\"number\">4</span>:<span class=\"number\">3</span>: <span class=\"built_in\">error</span>: expected <span class=\"string\">','</span> <span class=\"built_in\">or</span> <span class=\"string\">';'</span> before <span class=\"string\">'return'</span></span><br><span class=\"line\">    <span class=\"number\">4</span> |   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      |   ^~~~~~</span><br></pre></td></tr></table></div></figure>\n\n<p>Lambda之所以神奇，这得益于C++编译器的工作，上述“f”实际长这样：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> = <span class=\"class\"><span class=\"keyword\">struct</span> &lt;<span class=\"title\">lambda</span>()&gt; &#123;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>一个匿名的类（或结构体），实际上还有一个成员函数“operator () const”。注意这里成员函数是”const”类型，这是默认的。如果需非”const”成员函数，需要加”mutable”修饰，如下所示：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto f = [<span class=\"string\">n</span>](<span class=\"link\"></span>) mutable &#123; printf(\"%d\\n\", n); &#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p>上面例子对应的匿名类没有任何类数据成员，现在来个有类数据成员的代码：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// g++ -g -o a1 a1.cpp -std=c++11</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> n = <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> f = [n] &#123; <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, n); &#125;;</span><br><span class=\"line\">  f(); <span class=\"comment\">// 这里实际调用的是匿名类的成员函数“operator ()”</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>这时，“f”实际长这样，它是一个含有类数据成员的匿名类，而不再是空无一特的类：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> = <span class=\"class\"><span class=\"keyword\">struct</span> &lt;<span class=\"title\">lambda</span>()&gt; &#123;</span></span><br><span class=\"line\">    int __n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h1 id=\"3-示例2\">3. 示例2<a href=\"posts/Lambda#3-示例2\"></a></h1><p>继续来个变种：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// g++ -g -o a1 a1.cpp -std=c++11</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">#include &lt;stdio.h&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">  int n = 3;</span><br><span class=\"line\">  auto f = [<span class=\"string\">&amp;n</span>](<span class=\"link\"></span>) mutable &#123; printf(\"%d\\n\", n); &#125;;</span><br><span class=\"line\">  f();</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>这时，“f”实际长这样，一个包含了引用类型的匿名类：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> = <span class=\"class\"><span class=\"keyword\">struct</span> &lt;<span class=\"title\">lambda</span>()&gt; &#123;</span></span><br><span class=\"line\">    int &amp;__n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h1 id=\"4-示例3\">4. 示例3<a href=\"posts/Lambda#4-示例3\"></a></h1><p>继续变种，“&amp;”的作用让Lambda函数可使用Lambda所在作用域内所有可见的局部变量（包括Lambda所在类的this），并且是以引用传递方式：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// g++ -g -o a1 a1.cpp -std=c++11</span><br><span class=\"line\"><span class=\"section\">#include &lt;stdio.h&gt;</span></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">  int n = 3;</span><br><span class=\"line\">  auto f = [<span class=\"string\">&amp;</span>](<span class=\"link\"></span>) mutable &#123; printf(\"%d\\n\", n); &#125;;</span><br><span class=\"line\">  f();</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>“f”实际长这样：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> = <span class=\"class\"><span class=\"keyword\">struct</span> &lt;<span class=\"title\">lambda</span>()&gt; &#123;</span></span><br><span class=\"line\">    int &amp;__n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>变稍复杂一点：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// g++ -g -o a1 a1.cpp -std=c++11</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> n = <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> m = <span class=\"number\">5</span>;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> f = [&amp;]() <span class=\"keyword\">mutable</span> &#123; <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, n); &#125;;</span><br><span class=\"line\">  f();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>可以看到，“f”并没有发生变化：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> = <span class=\"class\"><span class=\"keyword\">struct</span> &lt;<span class=\"title\">lambda</span>()&gt; &#123;</span></span><br><span class=\"line\">    int &amp;__n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h1 id=\"5-示例4\">5. 示例4<a href=\"posts/Lambda#5-示例4\"></a></h1><p>继续增加复杂度：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// g++ -g -o a1 a1.cpp -std=c++11</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> n = <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> m = <span class=\"number\">5</span>;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> f = [&amp;]() <span class=\"keyword\">mutable</span> &#123; <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d,%d\\n\"</span>, n, m); &#125;;</span><br><span class=\"line\">  f();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>可以看到“f”变了：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> = <span class=\"class\"><span class=\"keyword\">struct</span> &lt;<span class=\"title\">lambda</span>()&gt; &#123;</span></span><br><span class=\"line\">    int &amp;__n;</span><br><span class=\"line\">    int &amp;__m;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>从上面不难看出，编译器只会把Lambda函数用到的变量打包进对应的匿名类。继续一个稍复杂点的：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// g++ -g -o a1 a1.cpp -std=c++11</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">X</span> &#123;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123; <span class=\"built_in\">printf</span>(<span class=\"string\">\"foo\\n\"</span>); &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">xoo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> f = [&amp;] &#123; foo(); &#125;;</span><br><span class=\"line\">    f();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  X().xoo();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>这时，“f”实际长这样：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> = struct <span class=\"type\">X</span>::&lt;lambda()&gt; &#123;</span><br><span class=\"line\">    <span class=\"type\">X</span> * const __this; // <span class=\"type\">X</span>类型的指针（非对象）</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>如果将“auto f = [&amp;] { foo(); };”中的“&amp;”去掉，则会遇到编译错误，提示“this”没有被Lambda函数捕获：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a2.cpp: <span class=\"keyword\">In</span> lambda <span class=\"keyword\">function</span>:</span><br><span class=\"line\">a2.cpp:<span class=\"number\">5</span>:<span class=\"number\">23</span>: error: <span class=\"symbol\">'this</span>' was <span class=\"keyword\">not</span> captured <span class=\"keyword\">for</span> this lambda <span class=\"keyword\">function</span></span><br><span class=\"line\">    <span class=\"number\">5</span> |     auto f = [] &#123; foo(); &#125;;</span><br><span class=\"line\">      |                       ^</span><br><span class=\"line\">a2.cpp:<span class=\"number\">5</span>:<span class=\"number\">23</span>: error: cannot call member <span class=\"keyword\">function</span> <span class=\"title\">'void</span> X::foo()' <span class=\"keyword\">with</span><span class=\"keyword\">out</span> object</span><br></pre></td></tr></table></div></figure>\n\n<p>改成下列方式捕获也是可以的：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// g++ -g -o a1 a1.cpp -std=c++11</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">X</span> &#123;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123; <span class=\"built_in\">printf</span>(<span class=\"string\">\"foo\\n\"</span>); &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">xoo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> f = [<span class=\"keyword\">this</span>] &#123; foo(); &#125;;</span><br><span class=\"line\">    f();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  X().xoo();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>如果是C++17，还可以这样：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// g++ -g -o a1 a1.cpp -std=c++17</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">X</span> &#123;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123; <span class=\"built_in\">printf</span>(<span class=\"string\">\"foo\\n\"</span>); &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">xoo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> f = [*<span class=\"keyword\">this</span>]() <span class=\"keyword\">mutable</span> &#123; foo(); &#125;;</span><br><span class=\"line\">    f();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  X().xoo();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>注意得有“mutable”修饰，不然报如下编译错误：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a2.<span class=\"string\">cpp:</span> In lambda <span class=\"string\">function:</span></span><br><span class=\"line\">a2.<span class=\"string\">cpp:</span><span class=\"number\">5</span>:<span class=\"number\">30</span>: <span class=\"string\">error:</span> passing <span class=\"string\">'const X'</span> <span class=\"keyword\">as</span> <span class=\"string\">'this'</span> argument discards qualifiers [-fpermissive]</span><br><span class=\"line\">    <span class=\"number\">5</span> |     auto f = [*<span class=\"keyword\">this</span>]() &#123; foo(); &#125;;</span><br><span class=\"line\">      |                              ^</span><br><span class=\"line\">a2.<span class=\"string\">cpp:</span><span class=\"number\">3</span>:<span class=\"number\">8</span>: <span class=\"string\">note:</span>   <span class=\"keyword\">in</span> call to <span class=\"string\">'void X::foo()'</span></span><br><span class=\"line\">    <span class=\"number\">3</span> |   <span class=\"keyword\">void</span> foo() &#123; printf(<span class=\"string\">\"foo\\n\"</span>); &#125;</span><br><span class=\"line\">      |        ^~~</span><br></pre></td></tr></table></div></figure>\n\n<p>也可以这样：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// g++ -g -o a1 a1.cpp -std=c++17</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">X</span> &#123;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123; <span class=\"built_in\">printf</span>(<span class=\"string\">\"foo\\n\"</span>); &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">xoo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> f = [&amp;,*<span class=\"keyword\">this</span>]() <span class=\"keyword\">mutable</span> &#123; foo(); &#125;;</span><br><span class=\"line\">    f();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  X().xoo();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>使用“*this”时的“f”样子如下：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> = struct <span class=\"type\">X</span>::&lt;lambda()&gt; &#123;</span><br><span class=\"line\">    <span class=\"type\">X</span> __this; // <span class=\"type\">X</span>类型的对象（非指针）</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h1 id=\"6-示例5\">6. 示例5<a href=\"posts/Lambda#6-示例5\"></a></h1><p>继续研究，使用C++ RTTI（Run-Time Type Identification，运行时类型识别）设施“typeid”查看Lambda函数：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// g++ -g -o a1 a1.cpp -std=c++11</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;typeinfo&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">X</span> &#123;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">xoo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> f = [] &#123; <span class=\"built_in\">printf</span>(<span class=\"string\">\"f\\n\"</span>); &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>, <span class=\"keyword\">typeid</span>(f).name());</span><br><span class=\"line\">    <span class=\"comment\">// 注：typeid返回值类型为“std::type_info”</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  X().xoo();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>运行输出：</p>\n<p><code>ZN1X3xooEvEUlvE_</code></p>\n<h1 id=\"7-匿名类规则\">7. 匿名类规则<a href=\"posts/Lambda#7-匿名类规则\"></a></h1><p>编译器为Lambda生成的匿名类规则（不同标准有区别）：</p>\n<div class=\"article-bounded\"><div class=\"article-table\"><table align=\"center\" border=\"1\" cellspacing=\"0\"><tbody><tr><td rowspan=\"4\">            <p style=\"margin-left:0pt;\">构造函数</p>            <p style=\"margin-left:0pt;\">拷贝构造函数</p>            </td>            <td style=\"vertical-align:top;width:250.8pt;\">            <p style=\"margin-left:0pt;\">ClosureType()&nbsp;=&nbsp;<strong>delete</strong>;</p>            </td>            <td style=\"vertical-align:top;width:105.95pt;\">            <p style=\"margin-left:0pt;\">C++14前</p>            </td>        </tr><tr><td style=\"vertical-align:top;width:250.8pt;\">            <p style=\"margin-left:0pt;\">ClosureType()&nbsp;=&nbsp;default;</p>            </td>            <td style=\"vertical-align:top;width:105.95pt;\">            <p style=\"margin-left:0pt;\">C++20起，</p>            <p style=\"margin-left:0pt;\">仅当未指定任何俘获时</p>            </td>        </tr><tr><td style=\"vertical-align:top;width:250.8pt;\">            <p style=\"margin-left:0pt;\">ClosureType(const&nbsp;ClosureType&amp;&nbsp;)&nbsp;=&nbsp;default;</p>            </td>            <td style=\"vertical-align:top;width:105.95pt;\">            <p style=\"margin-left:0pt;\">C++14起</p>            </td>        </tr><tr><td style=\"vertical-align:top;width:250.8pt;\">            <p style=\"margin-left:0pt;\">ClosureType(ClosureType&amp;&amp;&nbsp;)&nbsp;=&nbsp;default;</p>            </td>            <td style=\"vertical-align:top;width:105.95pt;\">            <p style=\"margin-left:0pt;\">C++14起</p>            </td>        </tr><tr><td rowspan=\"3\" style=\"width:69.35pt;\">            <p style=\"margin-left:0pt;\">拷贝复制函数</p>            </td>            <td style=\"vertical-align:top;width:250.8pt;\">            <p style=\"margin-left:0pt;\">ClosureType&amp;&nbsp;operator=(const&nbsp;ClosureType&amp;)&nbsp;=&nbsp;<strong>delete</strong>;</p>            </td>            <td style=\"vertical-align:top;width:105.95pt;\">            <p style=\"margin-left:0pt;\"><span style=\"color:#0000ff;\"><strong>C++20前</strong></span></p>            </td>        </tr><tr><td style=\"vertical-align:top;width:250.8pt;\">            <p style=\"margin-left:0pt;\">ClosureType&amp;&nbsp;operator=(const&nbsp;ClosureType&amp;)&nbsp;=&nbsp;default;</p>            <p style=\"margin-left:0pt;\">ClosureType&amp;&nbsp;operator=(ClosureType&amp;&amp;)&nbsp;=&nbsp;default;</p>            </td>            <td style=\"vertical-align:top;width:105.95pt;\">            <p style=\"margin-left:0pt;\">C++20起，</p>            <p style=\"margin-left:0pt;\">仅当未指定任何俘获时</p>            </td>        </tr><tr><td style=\"vertical-align:top;width:250.8pt;\">            <p style=\"margin-left:0pt;\">ClosureType&amp;&nbsp;operator=(const&nbsp;ClosureType&amp;)&nbsp;=&nbsp;<strong>delete</strong>;</p>            </td>            <td style=\"vertical-align:top;width:105.95pt;\">            <p style=\"margin-left:0pt;\">C++20起，其他情况</p>            </td>        </tr><tr><td style=\"vertical-align:top;width:69.35pt;\">            <p style=\"margin-left:0pt;\">析构函数</p>            </td>            <td style=\"vertical-align:top;width:250.8pt;\">            <p style=\"margin-left:0pt;\">~ClosureType()&nbsp;=&nbsp;default;</p>            </td>            <td style=\"vertical-align:top;width:105.95pt;\">            <p style=\"margin-left:0pt;\">析构函数是隐式声明的</p>            </td>        </tr></tbody></table></div></div>\n对于标记为“delete”的函数是不能调用的，如下列代码中的“f2 = f1;”将触发编译错误：\n\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">auto</span> f1 = []&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">auto</span> f2 = f1;</span><br><span class=\"line\"></span><br><span class=\"line\">  f2 = f1;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>上列代码在C++11、C++14和C++17均会报错。不过如规则所示，C++20（含C++2a）上则可以正常编译：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a3.cpp: In <span class=\"function\"><span class=\"keyword\">function</span> '<span class=\"title\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span>':</span></span><br><span class=\"line\">a3.cpp:<span class=\"number\">4</span>:<span class=\"number\">8</span>: <span class=\"built_in\">error</span>: use of deleted <span class=\"function\"><span class=\"keyword\">function</span> '<span class=\"title\">main</span><span class=\"params\">()</span>::&lt;<span class=\"title\">lambda</span><span class=\"params\">()</span>&gt;&amp; <span class=\"title\">main</span><span class=\"params\">()</span>::&lt;<span class=\"title\">lambda</span><span class=\"params\">()</span>&gt;::<span class=\"title\">operator</span>=<span class=\"params\">(const main()</span>::&lt;<span class=\"title\">lambda</span><span class=\"params\">()</span>&gt;&amp;)'</span></span><br><span class=\"line\">    <span class=\"number\">4</span> |   f2 = f1;</span><br><span class=\"line\">      |        ^~</span><br><span class=\"line\">a3.cpp:<span class=\"number\">2</span>:<span class=\"number\">14</span>: note: a lambda closure <span class=\"built_in\">type</span> has a deleted copy assignment operator</span><br><span class=\"line\">    <span class=\"number\">2</span> |   auto f1 = []&#123;&#125;;</span><br><span class=\"line\">      |              ^</span><br></pre></td></tr></table></div></figure>\n\n<p>希望通过本文，对理解Lambda有所帮助。</p>\n<h1 id=\"8-参考资料\">8. 参考资料<a href=\"posts/Lambda#8-参考资料\"></a></h1><ul>\n<li><p>1) <a href=\"https://zh.cppreference.com/w/cpp/language/lambda\" target=\"_blank\" rel=\"noopener\">https://zh.cppreference.com/w/cpp/language/lambda</a></p>\n</li>\n<li><p>2) <a href=\"https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=vs-2019\" target=\"_blank\" rel=\"noopener\">https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=vs-2019</a></p>\n</li>\n<li><p>3) <a href=\"https://en.cpprefeence.com/w/cpp/language/lambda\" target=\"_blank\" rel=\"noopener\">https://en.cpprefeence.com/w/cpp/language/lambda</a></p>\n</li>\n<li><p>4) <a href=\"https://stackoverflow.com/questions/7627098/what-is-a-lambda-expression-in-c11\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/7627098/what-is-a-lambda-expression-in-c11</a></p>\n</li>\n<li><p>5) <a href=\"https://www.cprogramming.com/c++11/c++11-lambda-closures.html\" target=\"_blank\" rel=\"noopener\">https://www.cprogramming.com/c++11/c++11-lambda-closures.html</a></p>\n</li>\n</ul>\n<hr>\n<div class=\"note info\">\n            <p>作者：一见<br>来源：CSDN<br>原文：<a href=\"https://blog.csdn.net/Aquester/article/details/90691479\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/Aquester/article/details/90691479</a> </p>\n          </div>\n","slug":"Lambda","updated":"2019-07-14T01:23:07.183Z","comments":true,"link":"posts/Lambda","permalink":"https://shuntan.github.io/posts/Lambda/","excerpt":"1. 前言本文代码测试环境为“GCC-9.1.0”，有关编译器的安装请参考《安装GCC-8.3.0及其依赖》，适用于“GCC-9.1.0”。 本文试图揭露Lambda背后一面，以方便更好的理解和掌握Lambda。Lambda代码段实际为一个编译器生成的类的“operator ()”函数，编译器会为每一个Lambda函数生成一个匿名的类（在C++中，类和结构体实际一样，无本质区别，除了默认的访问控制）。 对Lambda的最简单理解，是将它看作一个匿名类（或结构体），实际上也确实如此，编译器把Lambda编译成了匿名类。","categories":[{"name":"C++","slug":"C","permalink":"https://shuntan.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://shuntan.github.io/tags/C/"}]},{"title":"C++ 模板偏特化－来自STL的思考","date":"2019-05-31T06:29:52.000Z","path":"posts/模板特化/","text":"之前学习STL时接触过一段时间的模板，模板是C++泛型编程编程的基础STL从头到尾都是模板泛型编程，我觉得用的最巧妙的就是在traits萃取技巧时用到的模板偏特化 先简要回顾一下模板吧，模板主要分为函数模板与类模板 函数模板12345678910template&lt;class T&gt;T add(T a, T b) &#123; return a + b;&#125;int main()&#123; int a = 1, b = 2; std::cout &lt;&lt; add(a + b) &lt;&lt; std::endl; return 0;&#125; 如上就是最简单的函数模板，当实例化函数模板时，编译器会自动进行实参类型推导上面类型T就被自动推导为int类型 类模板12345678910111213141516templete&lt;class T&gt;class A&#123;public: explicit A(T val) : t(val) &#123; &#125; T add(T x) &#123; return t + y; &#125; privete: T t;&#125;;int main()&#123; A&lt;int&gt; a(10); std::cout &lt;&lt; a.add(5) &lt;&lt; std::endl; return 0;&#125; 如上就是最简单的类模板，实例化类模板必须要指定类型，编译器无法为类模板自动推导类型 几个需要注意的点 １．类模板的和函数模板都必须定义在.h头文件中 ２．模板的实例化类型确定是在编译期间 ３．只是模板写好了，编译一般不会很多出错，出错一般会在实例化编译之后 ４．模板实例化只会实例化用到的部分，没有用到的部分将不会被实例化 我觉得模板的特例化是模板中比较精髓的东西有函数模板特例化，类模板特例化，其中又分为全特化与偏特化主要的用途都是对于特定的类型，指定特定的处理方式就相当于普通编程中if-else if - else这样的方式编译阶段确定如果是某个特化类型，就用特化的模板如果都不是，就用最一般的模板 函数模板特例化函数模板只能全特化，不能偏特化，如果要偏特化的话只能重载 函数模板全特化1234567891011template&lt; &gt; // 全特化 注意语法double add(double a, double b) &#123; return a + b; &#125;int main()&#123; int x = 10, y = 20; double z = 1.1, w = 2.2; std::cout &lt;&lt; add(x, y) &lt;&lt; std::endl; // 调用普通版本 std::cout &lt;&lt; add(z, w) &lt;&lt; std::endl; // 调用全特化版本 return 0;&#125; 如果有与实参更加匹配的特例化版本，编译器将会选择特例化版本 函数模板重载（不存在偏特化）因为偏特化版本本质上仍然是模板，所以如果需要的话，可以重载一个函数模板 12345678910template&lt;class T1&gt; // 重载版本，接收参数为指针T1 add(T1* a, T1* b) &#123; return *a + *b; &#125; int main()&#123; int a = 10, b = 20; int *x = &amp;a, *y = &amp;b; add(a, b); // 调用普通模板 add(x, y); // 调用重载的模板 return 0;&#125; 如上，如果需要一个接收指针的偏特化版本，那么可以用重载模板实现函数模板不存在偏特化 类模板特例化类模板既有全特化，又有偏特化这里重新写一个更一般的模板类来说明类模板的特例化 类模板全特化比较好理解，跟函数模板一样，全特化是一个实例，当编译器匹配时会优先匹配参数一致的实例 123456789template&lt; &gt; // 注意语法class A&lt;char*&gt; // 一个全特化的模板类A&#123; // 当用char*类型来实例化类模板A时，将会优先调用这个全特化实例public: explicit A(char* val) : t(val) &#123; &#125; char* add(char* a, char* b) &#123; return strcat(a, b); &#125;private: char* t;&#125;; 类模板的偏特化类模板的偏特化会稍微复杂一点点，它有多种形式类模板偏特化本质上都是指定部分类型，让偏特化版本称为普通版本的子集，若实例化时参数类型为指定的类型，则优先调用特例化版本第一种形式 12345template&lt;class T1, class T2&gt; // 普通版本，有两个模板参数class B &#123; ..... &#125;;template&lt;class T2&gt; // 偏特化版本，指定其中一个参数，即指定了部分类型class B&lt;int , T2&gt; &#123; ..... &#125;; // 当实例化时的第一个参数为int 则会优先调用这个版本 第二种形式，也是最重要的版本 12345678template&lt;class T&gt; // 普通版本class B &#123; ..... &#125;;template&lt;class T&gt; //这个偏特化版本只接收指针类型的模板实参 class B&lt;T*&gt; &#123; ..... &#125;; template&lt;class T&gt;class B&lt;T&amp;&gt; &#123; ..... &#125;; // 这个偏特化版本只接受引用类型的模板实参 第三种形式 12345template&lt;class T&gt; //普通版本class B &#123; ..... &#125;;template&lt;class T&gt; // 这种只接受用T实例化的vector的模板实参．也是一种偏特化class B&lt;vector&lt;T&gt;&gt; &#123; ...... &#125;; 几个值得注意的地方 １．特例化本质上是我们顶替了编译器的工作，我们帮编译器做了类型推导 ２．全特化本质上是一个实例，而偏特化本质上还是一个模板，只是原来模板的一个子集 ３．所以全特化的函数模板，本质上是实例，从而不会与函数模板产生二义性 ４．若想让用户能使用特例化版本，特例化版本必须与模板定义在同一个.h头文件中 STL中的迭代器实现与高效实现与模板偏特化息息相关． 类模板偏特化与STL偏特化在STL中最重要的两个应用 １．应用在迭代器设计中，为了使迭代器既可以萃取出值类型，又可以包容原生指针如果要通过一个迭代器就能知道它的值类型，那么一般会使用iterator_traits迭代器萃取技术的两个核心是： １）在每个迭代器类中定义value_type值类型的类型成员，这样直接通过迭代器的value_type类型成员就可以知道值类型 ２）问题就在于，迭代器必须兼容原生指针，而原生指针很难被重新定义，即要在原生指针的类中添加value_type的值类型的类型成员．这时候，靠的就是类模板的偏特化了．新添加一层iterator_traits类，专门萃取迭代器的属性，然后再对iterator_traits类设计原生指针与原生引用的偏特化版本，就解决了这个棘手的问题 ２． type_traits类型萃取，对待特殊类型，特殊处理，提高效率对于没有构造函数，析构函数等的内置类型，如果与复杂类型一样，执行同样的操作，显然是效率不高的先实现一个对所有类型都设置一个最保守值的type_traits模板类，然后再对每个内置类型设置偏特化版本，内置类型设置一个更为激进的值，表明可以采取更为高效的操作来提高效率比如copy函数，如果传递的对象是一个复杂类型，那么可能只能采取最保守的处理方式，一个一个的构造；如果是内置类型，这样显然太低效，使用memcpy()可能会好一些 其实iterator_traits也不止是处理兼容原生指针的问题，它也可以提高效率．迭代器分为很多种，有可以随机访问的（vector），有只能前后一个一个移动的（list）,也有只能单向移动的（slist），所以一般把迭代器分为五种： InputIterator 输入迭代器 OutputIterator 输出迭代器 ForwardIterator 单向迭代器 BidirectionIterator 双向迭代器 RandomAccessIterator 随机访问迭代器 比如一个advance(n)函数，对于单向迭代器只能一个一个移动过去，但是这种实现对于随机访问迭代器显然不是理想的处理方式处理的方式就是先实现这五个类，用作标记用，在每个迭代器里面都定义迭代器类型的类型成员iterator_catagory，再对不同版本的迭代器实现不同的advance(n)处理方式 比如stl中添加右值引用元模板的实现： 1234567891011121314template&lt;typename _Tp, bool = __and_&lt;__not_&lt;is_reference&lt;_Tp&gt;&gt;, __not_&lt;is_void&lt;_Tp&gt;&gt;&gt;::value&gt; struct __add_rvalue_reference_helper &#123;typedef __Tp type; &#125;;template&lt;typename _Tp&gt; struct __add_rvalue_reference_helper&lt;__Tp, true&gt; &#123;typedef __Tp&amp;&amp; type; &#125;; template&lt;typename _Tp&gt;struct add_rvalue_reference: public __add_rvalue_reference_helper&lt;_Tp&gt;&#123; &#125;; 可以发现调用时一般为static_cast&lt;typenameadd_rvalue_reference&lt;T&gt;::type&gt;(__t),首先会匹配泛化版本的元模板类，第二个模版参数bool会匹配_Tp的类型，如果原来不是引用类型的话就直接匹配true的偏特化版本（优先级高），否则false为原泛化版本。 短短几行代码已经展示出了模板偏/全特化的强大匹配功能！","raw":"---\ntitle: C++ 模板偏特化－来自STL的思考\ntags: C++\ncategories: C++\nabbrlink: 2a215b70\ndate: 2019-05-31 14:29:52\ncopyright: true\ntype:\nkeyword:\ntop:\ncomments:\npassword:\ndescription:\nthumbnail:\n---\n\n之前学习STL时接触过一段时间的模板，模板是C++泛型编程编程的基础\nSTL从头到尾都是模板泛型编程，我觉得用的最巧妙的就是在traits萃取技巧时用到的模板偏特化\n\n-----------------------\n\n* 先简要回顾一下模板吧，模板主要分为函数模板与类模板\n\n## 函数模板\n\n```\n\ntemplate<class T>\nT add(T a, T b) { return a + b;}\n\nint main()\n{\n    int a = 1, b = 2;\n    std::cout << add(a + b) << std::endl;\n    return 0;\n}\n\n```\n\n<!-- more -->\n\n如上就是最简单的函数模板，当实例化函数模板时，编译器会自动进行实参类型推导\n上面类型T就被自动推导为int类型\n\n## 类模板\n\n```\ntemplete<class T>\nclass A\n{\npublic:\n    explicit A(T val) : t(val) { }\n    T add(T x) { return t + y; }    \nprivete:\n    T t;\n};\n\nint main()\n{\n    A<int> a(10);\n    std::cout << a.add(5) << std::endl;\n    return 0;\n}\n```\n\n如上就是最简单的类模板，实例化类模板必须要指定类型，编译器无法为类模板自动推导类型\n\n### 几个需要注意的点\n\n* １．类模板的和函数模板都必须定义在.h头文件中\n\n* ２．模板的实例化类型确定是在编译期间\n\n* ３．只是模板写好了，编译一般不会很多出错，出错一般会在实例化编译之后\n\n* ４．模板实例化只会实例化用到的部分，没有用到的部分将不会被实例化\n\n-------------\n\n我觉得模板的特例化是模板中比较精髓的东西\n有函数模板特例化，类模板特例化，其中又分为全特化与偏特化\n主要的用途都是对于特定的类型，指定特定的处理方式\n就相当于普通编程中if-else if - else这样的方式\n编译阶段确定如果是某个特化类型，就用特化的模板\n如果都不是，就用最一般的模板\n\n## 函数模板特例化\n\n函数模板只能全特化，{% label primary@不能偏特化 %}，如果要偏特化的话只能重载\n\n### 函数模板全特化\n\n```\ntemplate< >                                  // 全特化　注意语法\ndouble add(double a, double b)  { return a + b; }\n\nint main()\n{\n    int x = 10, y = 20;\n    double z = 1.1, w = 2.2;\n    std::cout << add(x, y) << std::endl;   // 调用普通版本\n    std::cout << add(z, w) << std::endl;   // 调用全特化版本\n    return 0;\n}\n```\n\n如果有与实参更加匹配的特例化版本，编译器将会选择特例化版本\n\n### 函数模板重载（不存在偏特化）\n\n因为偏特化版本本质上仍然是模板，所以如果需要的话，可以重载一个函数模板\n\n```\ntemplate<class T1>　　// 重载版本，接收参数为指针\nT1 add(T1* a, T1* b) { return *a + *b; }   \nint main()\n{\n    int a = 10, b = 20;\n    int *x = &a, *y = &b;\n    add(a, b);    // 调用普通模板\n    add(x, y);　  // 调用重载的模板\n    return 0;\n}\n```\n如上，如果需要一个接收指针的偏特化版本，那么可以用重载模板实现\n函数模板不存在偏特化\n\n## 类模板特例化\n\n类模板既有全特化，又有偏特化\n这里重新写一个更一般的模板类来说明类模板的特例化\n\n类模板全特化比较好理解，跟函数模板一样，全特化是一个实例，当编译器匹配时会优先匹配参数一致的实例\n\n```\ntemplate< >     　　　// 注意语法\nclass A<char*>       // 一个全特化的模板类A\n{                    // 当用char*类型来实例化类模板A时，将会优先调用这个全特化实例\npublic:\n    explicit A(char* val) : t(val) { }\n    char* add(char* a, char* b) { return strcat(a, b); }\nprivate:\n    char* t;\n};\n```\n\n## 类模板的偏特化\n\n类模板的偏特化会稍微复杂一点点，它有多种形式\n类模板偏特化本质上都是指定部分类型，让偏特化版本称为普通版本的子集，若实例化时参数类型为指定的类型，则优先调用特例化版本\n第一种形式\n\n```\ntemplate<class T1, class T2>      // 普通版本，有两个模板参数\nclass B { ..... };\n\ntemplate<class T2>　　　         // 偏特化版本，指定其中一个参数，即指定了部分类型\nclass B<int , T2> { ..... };　　// 当实例化时的第一个参数为int 则会优先调用这个版本\n```\n\n第二种形式，也是最重要的版本\n\n```\ntemplate<class T>     // 普通版本\nclass B { ..... };\n\ntemplate<class T>　　　//这个偏特化版本只接收指针类型的模板实参 \nclass B<T*> { ..... }; \n\ntemplate<class T>\nclass B<T&> { ..... };     // 这个偏特化版本只接受引用类型的模板实参\n```\n\n第三种形式\n\n```\ntemplate<class T>    //普通版本\nclass B { ..... };\n\ntemplate<class T>　　　// 这种只接受用T实例化的vector的模板实参．也是一种偏特化\nclass B<vector<T>> { ......  };  \n```\n\n<strong>几个值得注意的地方</strong>\n\n* １．特例化本质上是我们顶替了编译器的工作，我们帮编译器做了类型推导\n* ２．全特化本质上是一个实例，而偏特化本质上还是一个模板，只是原来模板的一个子集\n* ３．所以全特化的函数模板，本质上是实例，从而不会与函数模板产生二义性\n* ４．若想让用户能使用特例化版本，特例化版本必须与模板定义在同一个.h头文件中\n\n----------\n\nSTL中的迭代器实现与高效实现与模板偏特化息息相关．\n\n## 类模板偏特化与STL\n\n<strong>偏特化在STL中最重要的两个应用</strong>\n\n１．应用在迭代器设计中，为了使迭代器既可以萃取出值类型，又可以包容原生指针\n如果要通过一个迭代器就能知道它的值类型，那么一般会使用iterator_traits\n迭代器萃取技术的两个核心是：\n\n* １）在每个迭代器类中定义value_type值类型的类型成员，这样直接通过迭代器的value_type类型成员就可以知道值类型\n* ２）问题就在于，迭代器必须兼容原生指针，而原生指针很难被重新定义，即要在原生指针的类中添加value_type的值类型的类型成员．这时候，靠的就是类模板的偏特化了．新添加一层iterator_traits类，专门萃取迭代器的属性，然后再对iterator_traits类设计原生指针与原生引用的偏特化版本，就解决了这个棘手的问题\n\n２．{% label success@ type_traits %}类型萃取，对待特殊类型，特殊处理，提高效率\n对于没有构造函数，析构函数等的内置类型，如果与复杂类型一样，执行同样的操作，显然是效率不高的\n先实现一个对所有类型都设置一个最保守值的type_traits模板类，然后再对每个内置类型设置偏特化版本，内置类型设置一个更为激进的值，表明可以采取更为高效的操作来提高效率\n比如copy函数，如果传递的对象是一个复杂类型，那么可能只能采取最保守的处理方式，一个一个的构造；如果是内置类型，这样显然太低效，使用memcpy()可能会好一些\n\n其实iterator_traits也不止是处理兼容原生指针的问题，它也可以提高效率．\n迭代器分为很多种，有可以随机访问的（vector），有只能前后一个一个移动的（list）,也有只能单向移动的（slist），所以一般把迭代器分为五种：\n\n* InputIterator　　　　　　　输入迭代器\n* OutputIterator 　　　　　 　输出迭代器\n* ForwardIterator　　　　　　单向迭代器\n* BidirectionIterator　　　　　双向迭代器\n* RandomAccessIterator　　　随机访问迭代器\n\n比如一个advance(n)函数，对于单向迭代器只能一个一个移动过去，但是这种实现对于随机访问迭代器显然不是理想的处理方式\n处理的方式就是先实现这五个类，用作标记用，在每个迭代器里面都定义迭代器类型的类型成员iterator_catagory，再对不同版本的迭代器实现不同的advance(n)处理方式\n\n比如stl中添加右值引用元模板的实现：\n\n```\ntemplate<typename _Tp,\n\t\t   bool = __and_<__not_<is_reference<_Tp>>,\n\t\t   \t\t\t\t\t__not_<is_void<_Tp>>>::value>\n\tstruct __add_rvalue_reference_helper\n\t{typedef __Tp   type; };\n\ntemplate<typename _Tp>\n\tstruct __add_rvalue_reference_helper<__Tp, true>\n\t{typedef __Tp&&  type; };\n\t\ntemplate<typename _Tp>\nstruct add_rvalue_reference\n: public __add_rvalue_reference_helper<_Tp>\n{ };\t\t    \t\t\t\t\t\n```\n\n可以发现调用时一般为`static_cast<typenameadd_rvalue_reference<T>::type>(__t)`,首先会匹配泛化版本的元模板类，第二个模版参数bool会匹配_Tp的类型，如果原来不是引用类型的话就直接匹配true的偏特化版本（优先级高），否则false为原泛化版本。\n\n短短几行代码已经展示出了模板偏/全特化的强大匹配功能！\n","content":"<p>之前学习STL时接触过一段时间的模板，模板是C++泛型编程编程的基础<br>STL从头到尾都是模板泛型编程，我觉得用的最巧妙的就是在traits萃取技巧时用到的模板偏特化</p>\n<hr>\n<ul>\n<li>先简要回顾一下模板吧，模板主要分为函数模板与类模板</li>\n</ul>\n<h2 id=\"函数模板\">函数模板<a href=\"posts/模板特化#函数模板\"></a></h2><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">T</span> <span class=\"title\">add</span>(<span class=\"title\">T</span> <span class=\"title\">a</span>, <span class=\"title\">T</span> <span class=\"title\">b</span>) &#123;</span> <span class=\"keyword\">return</span> a + b;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>, b = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; add(a + b) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<a id=\"more\"></a>\n\n<p>如上就是最简单的函数模板，当实例化函数模板时，编译器会自动进行实参类型推导<br>上面类型T就被自动推导为int类型</p>\n<h2 id=\"类模板\">类模板<a href=\"posts/模板特化#类模板\"></a></h2><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">templete&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">explicit <span class=\"title\">A</span><span class=\"params\">(T val)</span> : <span class=\"title\">t</span><span class=\"params\">(val)</span> </span>&#123; &#125;</span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">add</span><span class=\"params\">(T x)</span> </span>&#123; <span class=\"keyword\">return</span> t + y; &#125;    </span><br><span class=\"line\">privete:</span><br><span class=\"line\">    T t;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">A&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">a</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">    std::cout &lt;&lt; a.add(<span class=\"number\">5</span>) &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>如上就是最简单的类模板，实例化类模板必须要指定类型，编译器无法为类模板自动推导类型</p>\n<h3 id=\"几个需要注意的点\">几个需要注意的点<a href=\"posts/模板特化#几个需要注意的点\"></a></h3><ul>\n<li><p>１．类模板的和函数模板都必须定义在.h头文件中</p>\n</li>\n<li><p>２．模板的实例化类型确定是在编译期间</p>\n</li>\n<li><p>３．只是模板写好了，编译一般不会很多出错，出错一般会在实例化编译之后</p>\n</li>\n<li><p>４．模板实例化只会实例化用到的部分，没有用到的部分将不会被实例化</p>\n</li>\n</ul>\n<hr>\n<p>我觉得模板的特例化是模板中比较精髓的东西<br>有函数模板特例化，类模板特例化，其中又分为全特化与偏特化<br>主要的用途都是对于特定的类型，指定特定的处理方式<br>就相当于普通编程中if-else if - else这样的方式<br>编译阶段确定如果是某个特化类型，就用特化的模板<br>如果都不是，就用最一般的模板</p>\n<h2 id=\"函数模板特例化\">函数模板特例化<a href=\"posts/模板特化#函数模板特例化\"></a></h2><p>函数模板只能全特化，<span class=\"label primary\">不能偏特化</span>，如果要偏特化的话只能重载</p>\n<h3 id=\"函数模板全特化\">函数模板全特化<a href=\"posts/模板特化#函数模板全特化\"></a></h3><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt; &gt;                                  <span class=\"comment\">// 全特化　注意语法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">double</span> a, <span class=\"keyword\">double</span> b)</span>  </span>&#123; <span class=\"keyword\">return</span> a + b; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x = <span class=\"number\">10</span>, y = <span class=\"number\">20</span>;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> z = <span class=\"number\">1.1</span>, w = <span class=\"number\">2.2</span>;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; add(x, y) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;   <span class=\"comment\">// 调用普通版本</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; add(z, w) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;   <span class=\"comment\">// 调用全特化版本</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>如果有与实参更加匹配的特例化版本，编译器将会选择特例化版本</p>\n<h3 id=\"函数模板重载（不存在偏特化）\">函数模板重载（不存在偏特化）<a href=\"posts/模板特化#函数模板重载（不存在偏特化）\"></a></h3><p>因为偏特化版本本质上仍然是模板，所以如果需要的话，可以重载一个函数模板</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T1</span>&gt;　　// 重载版本，接收参数为指针</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">T1</span> <span class=\"title\">add</span>(<span class=\"title\">T1</span>* <span class=\"title\">a</span>, <span class=\"title\">T1</span>* <span class=\"title\">b</span>) &#123;</span> <span class=\"keyword\">return</span> *a + *b; &#125;   </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>, b = <span class=\"number\">20</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *x = &amp;a, *y = &amp;b;</span><br><span class=\"line\">    add(a, b);    <span class=\"comment\">// 调用普通模板</span></span><br><span class=\"line\">    add(x, y);　  <span class=\"comment\">// 调用重载的模板</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>如上，如果需要一个接收指针的偏特化版本，那么可以用重载模板实现<br>函数模板不存在偏特化</p>\n<h2 id=\"类模板特例化\">类模板特例化<a href=\"posts/模板特化#类模板特例化\"></a></h2><p>类模板既有全特化，又有偏特化<br>这里重新写一个更一般的模板类来说明类模板的特例化</p>\n<p>类模板全特化比较好理解，跟函数模板一样，全特化是一个实例，当编译器匹配时会优先匹配参数一致的实例</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt; &gt;     　　　<span class=\"comment\">// 注意语法</span></span><br><span class=\"line\">class A&lt;<span class=\"keyword\">char</span>*&gt;       <span class=\"comment\">// 一个全特化的模板类A</span></span><br><span class=\"line\">&#123;                    <span class=\"comment\">// 当用char*类型来实例化类模板A时，将会优先调用这个全特化实例</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">explicit</span> A(<span class=\"keyword\">char</span>* val) : t(val) &#123; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>* add(<span class=\"keyword\">char</span>* a, <span class=\"keyword\">char</span>* b) &#123; <span class=\"built_in\">return</span> strcat(a, b); &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">char</span>* t;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"类模板的偏特化\">类模板的偏特化<a href=\"posts/模板特化#类模板的偏特化\"></a></h2><p>类模板的偏特化会稍微复杂一点点，它有多种形式<br>类模板偏特化本质上都是指定部分类型，让偏特化版本称为普通版本的子集，若实例化时参数类型为指定的类型，则优先调用特例化版本<br>第一种形式</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;<span class=\"keyword\">class</span> T1, <span class=\"keyword\">class</span> T2&gt;      <span class=\"comment\">// 普通版本，有两个模板参数</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> B &#123; ..... &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template&lt;<span class=\"keyword\">class</span> T2&gt;　　　         <span class=\"comment\">// 偏特化版本，指定其中一个参数，即指定了部分类型</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> B&lt;int , T2&gt; &#123; ..... &#125;;　　<span class=\"comment\">// 当实例化时的第一个参数为int 则会优先调用这个版本</span></span><br></pre></td></tr></table></div></figure>\n\n<p>第二种形式，也是最重要的版本</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;     // 普通版本</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> &#123; ..... &#125;;</span></span><br><span class=\"line\"></span><br><span class=\"line\">template&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;　　　//这个偏特化版本只接收指针类型的模板实参 </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>&lt;T*&gt; &#123; ..... &#125;;</span> </span><br><span class=\"line\"></span><br><span class=\"line\">template&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>&lt;T&amp;&gt; &#123; ..... &#125;;</span>     /<span class=\"regexp\">/ 这个偏特化版本只接受引用类型的模板实参</span></span><br></pre></td></tr></table></div></figure>\n\n<p>第三种形式</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;    //普通版本</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> &#123; ..... &#125;;</span></span><br><span class=\"line\"></span><br><span class=\"line\">template&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;　　　// 这种只接受用<span class=\"title\">T</span>实例化的<span class=\"title\">vector</span>的模板实参．也是一种偏特化</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>&lt;vector&lt;T&gt;&gt; &#123; ......  &#125;;</span></span><br></pre></td></tr></table></div></figure>\n\n<p><strong>几个值得注意的地方</strong></p>\n<ul>\n<li>１．特例化本质上是我们顶替了编译器的工作，我们帮编译器做了类型推导</li>\n<li>２．全特化本质上是一个实例，而偏特化本质上还是一个模板，只是原来模板的一个子集</li>\n<li>３．所以全特化的函数模板，本质上是实例，从而不会与函数模板产生二义性</li>\n<li>４．若想让用户能使用特例化版本，特例化版本必须与模板定义在同一个.h头文件中</li>\n</ul>\n<hr>\n<p>STL中的迭代器实现与高效实现与模板偏特化息息相关．</p>\n<h2 id=\"类模板偏特化与STL\">类模板偏特化与STL<a href=\"posts/模板特化#类模板偏特化与STL\"></a></h2><p><strong>偏特化在STL中最重要的两个应用</strong></p>\n<p>１．应用在迭代器设计中，为了使迭代器既可以萃取出值类型，又可以包容原生指针<br>如果要通过一个迭代器就能知道它的值类型，那么一般会使用iterator_traits<br>迭代器萃取技术的两个核心是：</p>\n<ul>\n<li>１）在每个迭代器类中定义value_type值类型的类型成员，这样直接通过迭代器的value_type类型成员就可以知道值类型</li>\n<li>２）问题就在于，迭代器必须兼容原生指针，而原生指针很难被重新定义，即要在原生指针的类中添加value_type的值类型的类型成员．这时候，靠的就是类模板的偏特化了．新添加一层iterator_traits类，专门萃取迭代器的属性，然后再对iterator_traits类设计原生指针与原生引用的偏特化版本，就解决了这个棘手的问题</li>\n</ul>\n<p>２．<span class=\"label success\"> type_traits</span>类型萃取，对待特殊类型，特殊处理，提高效率<br>对于没有构造函数，析构函数等的内置类型，如果与复杂类型一样，执行同样的操作，显然是效率不高的<br>先实现一个对所有类型都设置一个最保守值的type_traits模板类，然后再对每个内置类型设置偏特化版本，内置类型设置一个更为激进的值，表明可以采取更为高效的操作来提高效率<br>比如copy函数，如果传递的对象是一个复杂类型，那么可能只能采取最保守的处理方式，一个一个的构造；如果是内置类型，这样显然太低效，使用memcpy()可能会好一些</p>\n<p>其实iterator_traits也不止是处理兼容原生指针的问题，它也可以提高效率．<br>迭代器分为很多种，有可以随机访问的（vector），有只能前后一个一个移动的（list）,也有只能单向移动的（slist），所以一般把迭代器分为五种：</p>\n<ul>\n<li>InputIterator　　　　　　　输入迭代器</li>\n<li>OutputIterator 　　　　　 　输出迭代器</li>\n<li>ForwardIterator　　　　　　单向迭代器</li>\n<li>BidirectionIterator　　　　　双向迭代器</li>\n<li>RandomAccessIterator　　　随机访问迭代器</li>\n</ul>\n<p>比如一个advance(n)函数，对于单向迭代器只能一个一个移动过去，但是这种实现对于随机访问迭代器显然不是理想的处理方式<br>处理的方式就是先实现这五个类，用作标记用，在每个迭代器里面都定义迭代器类型的类型成员iterator_catagory，再对不同版本的迭代器实现不同的advance(n)处理方式</p>\n<p>比如stl中添加右值引用元模板的实现：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename _Tp,</span><br><span class=\"line\">\t\t   bool = __and_&lt;__not_&lt;is_reference&lt;_Tp&gt;&gt;,</span><br><span class=\"line\">\t\t   \t\t\t\t\t__not_&lt;is_void&lt;_Tp&gt;&gt;&gt;::value&gt;</span><br><span class=\"line\">\tstruct __add_rvalue_reference_helper</span><br><span class=\"line\">\t&#123;typedef __Tp  <span class=\"built_in\"> type; </span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template&lt;typename _Tp&gt;</span><br><span class=\"line\">\tstruct __add_rvalue_reference_helper&lt;__Tp, <span class=\"literal\">true</span>&gt;</span><br><span class=\"line\">\t&#123;typedef __Tp&amp;&amp; <span class=\"built_in\"> type; </span>&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">template&lt;typename _Tp&gt;</span><br><span class=\"line\">struct add_rvalue_reference</span><br><span class=\"line\">: public __add_rvalue_reference_helper&lt;_Tp&gt;</span><br><span class=\"line\">&#123; &#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p>可以发现调用时一般为<code>static_cast&lt;typenameadd_rvalue_reference&lt;T&gt;::type&gt;(__t)</code>,首先会匹配泛化版本的元模板类，第二个模版参数bool会匹配_Tp的类型，如果原来不是引用类型的话就直接匹配true的偏特化版本（优先级高），否则false为原泛化版本。</p>\n<p>短短几行代码已经展示出了模板偏/全特化的强大匹配功能！</p>\n","slug":"模板特化","updated":"2019-07-14T01:22:35.792Z","comments":true,"link":"posts/模板特化","permalink":"https://shuntan.github.io/posts/模板特化/","excerpt":"之前学习STL时接触过一段时间的模板，模板是C++泛型编程编程的基础STL从头到尾都是模板泛型编程，我觉得用的最巧妙的就是在traits萃取技巧时用到的模板偏特化 先简要回顾一下模板吧，模板主要分为函数模板与类模板 函数模板12345678910template&lt;class T&gt;T add(T a, T b) &#123; return a + b;&#125;int main()&#123; int a = 1, b = 2; std::cout &lt;&lt; add(a + b) &lt;&lt; std::endl; return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://shuntan.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://shuntan.github.io/tags/C/"}]},{"title":"C++中的万能引用和完美转发","date":"2019-05-29T02:05:19.000Z","path":"posts/完美转发/","text":"C++中的万能引用和完美转发 阅读这篇博文需要了解C++中的左值（lvalue）和右值（rvalue）的概念，详情参见我的另外一篇博文：C++移动语义及拷贝优化 万能引用和完美转发多涉及到模板的使用，如若不是自己写模板，则可不用关心 左值与右值的区分首先理解什么是右值引用（下面是百度百科给出的解释）： 右值引用（及其支持的Move语意和完美转发）是C++0x将要加入的最重大语言特性之一，这点从该特性的提案在C++ - State of the Evolution列表上高居榜首也可以看得出来。从实践角度讲，它能够完美解决C++中长久以来为人所诟病的临时对象效率问题。从语言本身讲，它健全了C++中的引用类型在左值右值方面的缺陷。从库设计者的角度讲，它给库设计者又带来了一把利器。从库使用者的角度讲，不动一兵一卒便可以获得“免费的”效率提升… 在标准C++语言中，临时量（术语为右值，因其出现在赋值表达式的右边）可以被传给函数，但只能被接受为const &amp;类型。这样函数便无法区分传给const &amp;的是真实的右值还是常规变量。而且，由于类型为const &amp;，函数也无法改变所传对象的值。C++0x将增加一种名为右值引用的新的引用类型，记作typename &amp;&amp;。这种类型可以被接受为非const值，从而允许改变其值。 区分左值与右值： C++ 11中引入的一个非常重要的概念就是右值引用。理解右值引用是学习“移动语义”（move semantics）的基础。而要理解右值引用，就必须先区分左值与右值。 对左值和右值的一个最常见的误解是：等号左边的就是左值，等号右边的就是右值。 什么是左值引用： 区分清楚了左值与右值，我们再来看看左值引用。左值引用根据其修饰符的不同，可以分为非常量左值引用(eg.1 double &amp;r =i;)和常量左值引用(eg.1 const double &amp;r =i;)。 非常量左值引用只能绑定到非常量左值，不能绑定到常量左值、非常量右值和常量右值。如果允许绑定到常量左值和常量右值，则非常量左值引用可以用于修改常量左值和常量右值，这明显违反了其常量的含义(eg.1中就是出现了非常量左值引用绑定到常量右值的情况)。如果允许绑定到非常量右值，则会导致非常危险的情况出现，因为非常量右值是一个临时对象，非常量左值引用可能会使用一个已经被销毁了的临时对象。 常量左值引用可以绑定到所有类型的值，包括非常量左值、常量左值、非常量右值和常量右值。 如果同时包含左值和右值的函数重载，右值会优先匹配右值的重载版本，其次匹配常量左值重载版本。 万能引用（Universal Reference）首先，我们来看一个例子： 1234567891011121314151617#include &lt;iostream&gt;using std::cout;using std::endl;template&lt;typename T&gt;void func(T&amp; param) &#123; cout &lt;&lt; param &lt;&lt; endl;&#125;int main() &#123; int num = 2019; func(num); return 0;&#125; 这样例子的编译输出都没有什么问题，但是如果我们修改成下面的调用方式呢？ 1234int main() &#123; func(2019); return 0;&#125; 则会得到一个大大的编译错误。因为上面的模板函数只能接受左值或者左值引用（左值一般是有名字的变量，可以取到地址的），我们当然可以重载一个接受右值的模板函数，如下也可以达到效果。 1234567891011121314151617template&lt;typename T&gt;void func(T&amp; param) &#123; cout &lt;&lt; \"传入的是左值\" &lt;&lt; endl;&#125;template&lt;typename T&gt;void func(T&amp;&amp; param) &#123; cout &lt;&lt; \"传入的是右值\" &lt;&lt; endl;&#125;int main() &#123; int num = 2019; func(num); func(2019); return 0;&#125; 输出结果： 12传入的是左值传入的是右值 第一次函数调用的是左值得版本，第二次函数调用的是右值版本。但是，有没有办法只写一个模板函数即可以接收左值又可以接收右值呢？ ​ C++ 11中有万能引用（Universal Reference）的概念：使用T&amp;&amp;类型的形参既能绑定右值，又能绑定左值。只有在模版中才生效，普通函数中左值引用（非常量）只接受左值，右值引用只接受右值，const 左值引用可以接受任何值，const 右值引用能接受任何右值，推导后的模版也同理。 但是注意了：只有发生类型推导的时候，T&amp;&amp;才表示万能引用； 否则，表示右值引用。 所以，上面的案例我们可以修改为： 123456789101112template&lt;typename T&gt;void func(T&amp;&amp; param) &#123; cout &lt;&lt; param &lt;&lt; endl;&#125;int main() &#123; int num = 2019; func(num); func(2019); return 0;&#125; 引用折叠（Universal Collapse）万能引用说完了，接着来聊引用折叠（Univers Collapse），因为完美转发（Perfect Forwarding）的概念涉及引用折叠。一个模板函数，根据定义的形参和传入的实参的类型，我们可以有下面四中组合： 左值-左值 T&amp; &amp; # 函数定义的形参类型是左值引用，传入的实参是左值引用 左值-右值 T&amp; &amp;&amp; # 函数定义的形参类型是左值引用，传入的实参是右值引用（必须const修饰） 右值-左值 T&amp;&amp; &amp; # 函数定义的形参类型是右值引用，传入的实参是左值引用 右值-右值 T&amp;&amp; &amp;&amp; # 函数定义的形参类型是右值引用，传入的实参是右值引用 但是C++中不允许对引用再进行引用，对于上述情况的处理有如下的规则： 所有的折叠引用最终都代表一个引用，要么是左值引用，要么是右值引用。规则是：如果任一引用为左值引用，则结果为左值引用。否则（即两个都是右值引用），结果为右值引用。 即就是前面三种情况代表的都是左值引用，而第四种代表的右值引用。 完美转发（Perfect Forwarding）下面接着说完美转发（Perfect Forwarding），首先，看个例子： 🌰[栗子]要了解完美转发，先得清楚模板T的推导过程，在没有偏特化的模版前提下，模板总是根据最匹配的规则来推导参数，左值引用template函数推导出来总是左值引用函数，右值引用template函数能推导出左值引用和右值引用函数，可以根据下面的例子来看出推导过程。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;void func(T&amp;&amp; arg) &#123; //auto is_lval = std::is_lvalue_reference&lt;T&gt;::value; //auto is_rval = std::is_rvalue_reference&lt;T&gt;::value; if(std::is_same&lt;T, int&gt;::value) &#123; std::cout &lt;&lt; \"'T' is type[int]\" &lt;&lt; \" arg:\" &lt;&lt; arg &lt;&lt; std::endl; &#125; else if(std::is_same&lt;T, const int&gt;::value) &#123; std::cout &lt;&lt; \"'T' is type[const int]\" &lt;&lt; \" arg:\" &lt;&lt; arg &lt;&lt; std::endl; &#125; else if(std::is_same&lt;T, int&amp;&gt;::value) &#123; std::cout &lt;&lt; \"'T' is type[int&amp;]\" &lt;&lt; \" arg:\" &lt;&lt; arg &lt;&lt; std::endl; &#125; else if(std::is_same&lt;T, const int&amp;&gt;::value) &#123; std::cout &lt;&lt; \"'T' is type[const int&amp;]\" &lt;&lt; \" arg:\" &lt;&lt; arg &lt;&lt; std::endl; &#125; std::cout &lt;&lt; \"-----------------\" &lt;&lt; std::endl;&#125;int main() &#123; int a = 1; const int&amp; b = 2; func(a); //传入左值引用 T =&gt; int&amp; func(b); //传入常量左值引用 T =&gt; const int&amp; func(3); //传入右值引用 T =&gt; int func(static_cast&lt;int&gt;(a)); //传入转换后的右值引用 T =&gt; int func(static_cast&lt;int&amp;&gt;(a)); //传入转换后的左值引用 T =&gt; int&amp; func(static_cast&lt;const int&amp;&amp;&gt;(a));//传入转换后的常量右值 T =&gt; const int func&lt;int&gt;(a); //错误❌ 显示指定模版形参，推导后只能接受右值引用，而a是左值 func&lt;int&amp;&gt;(a); //示指定模版形参，推导后只可接受左值引用，a是左值 func&lt;const int&gt;(1); //示指定模版形参，推导后只可接受右值，且不能修改，1是右值&#125; 输出结果为： 123456789101112131415161718$g++ -std=c++11 -o main *.cpp$main'T' is type[int&amp;] arg:1-----------------'T' is type[const int&amp;] arg:2-----------------'T' is type[int] arg:3-----------------'T' is type[int] arg:1-----------------'T' is type[int&amp;] arg:1-----------------'T' is type[const int] arg:1-----------------'T' is type[int&amp;] arg:1-----------------'T' is type[const int] arg:1----------------- 错误信息： 123main.cpp:6:6: note: template argument deduction/substitution failed:main.cpp:35:14: note: cannot convert ‘a’ (type ‘int’) to type ‘int&amp;&amp;’ func&lt;int&gt;(a); 根据C++ Primer中文版(第五版) 18章第2节模板实参推断 Note:如果显示推导模版T的类型，可能会导致编译不过，因为会导致推到出来的函数实参和形参引用类型不一致 std::forward()std::forward完美转发解析 完美转发实现了参数在传递过程中保持其值属性的功能，即若是左值，则传递之后仍然是左值，若是右值，则传递之后仍然是右值。 C++11 lets us perform perfect forwarding, which means that we can forward the parameters passed to a function template to another function call inside it without losing their own qualifiers (const-ref, ref, value, rvalue, etc.). std::forward()解析std::forward只有在它的参数绑定到一个右值上的时候，它才转换它的参数到一个右值。 12345678class Foo&#123;public: std::string member; template&lt;typename T&gt; Foo(T&amp;&amp; member): member&#123;std::forward&lt;T&gt;(member)&#125; &#123;&#125;&#125;; 对于Foo函数中member变量，无论之前是什么，都变为左值了，因为他有名字了:smile: 传递一个lvalue或者传递一个const lvaue 传递一个lvalue，模板推导之后 T = std::string&amp; 传递一个const lvaue, 模板推导之后T = const std::string&amp; T&amp; &amp;&amp;将折叠为T&amp;，即std::string&amp; &amp;&amp; 折叠为 std::string&amp; 最终函数为: Foo(string&amp; member): member{std::forward&lt;string&amp;&gt;(member)} {} std::forward&lt;string&amp;&gt;(member)将返回一个左值，最终调用拷贝构造函数 传递一个rvalue 传递一个rvalue，模板推导之后 T = std::string 最终函数为: Foo(string&amp;&amp; member): member{std::forward&lt;string&gt;(member)} {} std::forward(member) 将返回一个右值，最终调用移动构造函数； std::move和std::forward本质都是转换。std::move执行到右值的无条件转换。std::forward只有在它的参数绑定到一个右值上的时候，才转换它的参数到一个右值。 std::move没有move任何东西，std::forward没有转发任何东西。在运行期，它们没有做任何事情。它们没有产生需要执行的代码，一byte都没有。 std::movestd::move的使用1234567891011class Foo&#123;public: std::string member; // Copy member. Foo(const std::string&amp; m): member(m) &#123;&#125; // Move member. Foo(std::string&amp;&amp; m): member(std::move(m)) &#123;&#125;&#125;; 上述Foo(std::string&amp;&amp; member)中的member是rvalue reference，但是member却是一个左值lvalue，因此在初始化列表中需要使用std::move将其转换成rvalue。 std::move()解析标准库中move的定义如下： 12345template&lt;typename T&gt;typename remove_reference&lt;T&gt;::type &amp;&amp; move(T&amp;&amp; t)&#123; return static_cast&lt;typename remove_reference&lt;T&gt;::type &amp;&amp;&gt;(t);&#125; move函数的参数T&amp;&amp;是一个指向模板类型参数的右值引用【规则2】，通过引用折叠，此参数可以和任何类型的实参匹配，因此move既可以传递一个左值，也可以传递一个右值； std::move(string(“hello”))调用解析： 首先，根据模板推断规则，确地T的类型为string; typename remove_reference::type &amp;&amp; 的结果为 string &amp;&amp;; move函数的参数类型为string&amp;&amp;; static_cast&lt;string &amp;&amp;&gt;(t)，t已经是string&amp;&amp;，于是类型转换什么都不做，返回string &amp;&amp;; string s1(“hello”); std::move(s1); 调用解析： 首先，根据模板推断规则，确定T的类型为string&amp;; typename remove_reference::type &amp;&amp; 的结果为 string&amp; move函数的参数类型为string&amp; &amp;&amp;，引用折叠之后为string&amp;; static_cast&lt;string &amp;&amp;&gt;(t)，t是string&amp;，经过static_cast之后转换为string&amp;&amp;, 返回string &amp;&amp;; 从move的定义可以看出，move自身除了做一些参数的推断之外，返回右值引用本质上还是靠static_cast&lt;T&amp;&amp;&gt;完成的。 因此下面两个调用是等价的，std::move就是个语法糖。 12345678910void func(int&amp;&amp; a)&#123; cout &lt;&lt; a &lt;&lt; endl;&#125;int a = 6;func(std::move(a));int b = 10;func(static_cast&lt;int&amp;&amp;&gt;(b)); std::move执行到右值的无条件转换。就其本身而言，它没有move任何东西。 std::move()和std::forward()对比 std::move执行到右值的无条件转换。就其本身而言，它没有move任何东西。 std::forward只有在它的参数绑定到一个右值上的时候，它才转换它的参数到一个右值。 std::move和std::forward只不过就是执行类型转换的两个函数；std::move没有move任何东西，std::forward没有转发任何东西。在运行期，它们没有做任何事情。它们没有产生需要执行的代码，一byte都没有。 std::forward()不仅可以保持左值或者右值不变，同时还可以保持const、Lreference、Rreference、validate等属性不变；","raw":"---\ntitle: C++中的万能引用和完美转发\ncopyright: true\ntags: C++\ncategories: C++\nabbrlink: dc484a2e\ndate: 2019-05-29 10:05:19\ntype:\nkeyword:\ntop:\ncomments:\npassword:\ndescription:\nthumbnail:\n---\n\n## C++中的万能引用和完美转发\n* 阅读这篇博文需要了解C++中的左值（lvalue）和右值（rvalue）的概念，详情参见我的另外一篇博文：C++移动语义及拷贝优化\n* 万能引用和完美转发多涉及到模板的使用，如若不是自己写模板，则可不用关心\n\n\n\n### 左值与右值的区分\n\n首先理解什么是右值引用（下面是百度百科给出的解释）：\n\n   右值引用（及其支持的Move语意和完美转发）是C++0x将要加入的最重大语言特性之一，这点从该特性的提案在C++ - State of the Evolution列表上高居榜首也可以看得出来。从实践角度讲，它能够完美解决C++中长久以来为人所诟病的临时对象效率问题。从语言本身讲，它健全了C++中的引用类型在左值右值方面的缺陷。从库设计者的角度讲，它给库设计者又带来了一把利器。从库使用者的角度讲，不动一兵一卒便可以获得“免费的”效率提升… 　　在标准C++语言中，临时量（术语为右值，因其出现在赋值表达式的右边）可以被传给函数，但只能被接受为const &类型。这样函数便无法区分传给const &的是真实的右值还是常规变量。而且，由于类型为const &，函数也无法改变所传对象的值。C++0x将增加一种名为右值引用的新的引用类型，记作typename &&。这种类型可以被接受为非const值，从而允许改变其值。\n\n<!-- more -->\n\n**区分左值与右值：**\n\n C++ 11中引入的一个非常重要的概念就是右值引用。理解右值引用是学习“移动语义”（move semantics）的基础。而要理解右值引用，就必须先区分左值与右值。\n       对左值和右值的一个最常见的误解是：等号左边的就是左值，等号右边的就是右值。\n\n**什么是左值引用：**\n       区分清楚了左值与右值，我们再来看看左值引用。左值引用根据其修饰符的不同，可以分为非常量左值引用(**eg.1 double &r =i;**)和常量左值引用(**eg.1 const double &r =i;**)。\n       非常量左值引用只能绑定到非常量左值，不能绑定到常量左值、非常量右值和常量右值。如果允许绑定到常量左值和常量右值，则非常量左值引用可以用于修改常量左值和常量右值，这明显违反了其常量的含义(**eg.1中就是出现了非常量左值引用绑定到常量右值的情况**)。如果允许绑定到非常量右值，则会导致非常危险的情况出现，因为非常量右值是一个临时对象，非常量左值引用可能会使用一个已经被销毁了的临时对象。\n       **常量左值引用可以绑定到所有类型的值，包括非常量左值、常量左值、非常量右值和常量右值。**\n\n如果同时包含左值和右值的函数重载，右值会优先匹配右值的重载版本，其次匹配常量左值重载版本。\n\n### 万能引用（Universal Reference）\n\n首先，我们来看一个例子：\n\n```\n#include <iostream>\n\nusing std::cout;\nusing std::endl;\n\n\ntemplate<typename T>\nvoid func(T& param) {\n    cout << param << endl;\n}\n\n\nint main() {\n    int num = 2019;\n    func(num);\n    return 0;\n}\n```\n\n这样例子的编译输出都没有什么问题，但是如果我们修改成下面的调用方式呢？\n\n```\nint main() {\n    func(2019);\n    return 0;\n}\n```\n\n则会得到一个大大的编译错误。因为上面的模板函数只能接受左值或者左值引用（左值一般是有名字的变量，可以取到地址的），我们当然可以重载一个接受右值的模板函数，如下也可以达到效果。\n\n```\ntemplate<typename T>\nvoid func(T& param) {\n    cout << \"传入的是左值\" << endl;\n}\ntemplate<typename T>\nvoid func(T&& param) {\n    cout << \"传入的是右值\" << endl;\n}\n\n\n\nint main() {\n    int num = 2019;\n    func(num);\n    func(2019);\n    return 0;\n}\n```\n\n输出结果：\n\n```\n传入的是左值\n传入的是右值\n```\n\n第一次函数调用的是左值得版本，第二次函数调用的是右值版本。但是，有没有办法只写一个模板函数即可以接收左值又可以接收右值呢？\n\n​     **C++ 11中有万能引用（Universal Reference）的概念：使用T&&类型的形参既能绑定右值，又能绑定左值。只有在模版中才生效，普通函数中左值引用（非常量）只接受左值，右值引用只接受右值，const 左值引用可以接受任何值，const 右值引用能接受任何右值，推导后的模版也同理。**\n\n但是注意了：<strong>只有发生类型推导的时候，T&&才表示万能引用；</strong> 否则，表示右值引用。\n\n所以，上面的案例我们可以修改为：\n\n```\ntemplate<typename T>\nvoid func(T&& param) {\n    cout << param << endl;\n}\n\n\nint main() {\n    int num = 2019;\n    func(num);\n    func(2019);\n    return 0;\n}\n```\n\n## 引用折叠（Universal Collapse）\n\n万能引用说完了，接着来聊引用折叠（Univers Collapse），因为完美转发（Perfect Forwarding）的概念涉及引用折叠。一个模板函数，根据定义的形参和传入的实参的类型，我们可以有下面四中组合：\n\n* 左值-左值 T& &        # 函数定义的形参类型是左值引用，传入的实参是左值引用\n* 左值-右值 T& &&      # 函数定义的形参类型是左值引用，传入的实参是右值引用（必须const修饰）\n* 右值-左值 T&& &      # 函数定义的形参类型是右值引用，传入的实参是左值引用\n* 右值-右值 T&& &&    # 函数定义的形参类型是右值引用，传入的实参是右值引用\n\n但是C++中不允许对引用再进行引用，对于上述情况的处理有如下的规则：\n\n所有的折叠引用最终都代表一个引用，要么是左值引用，要么是右值引用。规则是：如果任一引用为左值引用，则结果为左值引用。否则（即两个都是右值引用），结果为右值引用。\n\n即就是前面三种情况代表的都是左值引用，而第四种代表的右值引用。\n\n## 完美转发（Perfect Forwarding）\n\n下面接着说完美转发（Perfect Forwarding），首先，看个例子：\n\n🌰[栗子]\n要了解完美转发，先得清楚模板T的<strong>推导过程</strong>，{% label success@在没有偏特化的模版前提下，模板总是根据最匹配的规则来推导参数，左值引用template函数推导出来总是左值引用函数，右值引用template函数能推导出左值引用和右值引用函数%}，可以根据下面的例子来看出推导过程。\n\n```c++\n#include <iostream>\n\nusing namespace std;\n\ntemplate <typename T>\nvoid func(T&& arg) {\n    //auto is_lval = std::is_lvalue_reference<T>::value;\n    //auto is_rval  = std::is_rvalue_reference<T>::value;\n\n    if(std::is_same<T, int>::value) {\n        std::cout << \"'T' is type[int]\"  << \" arg:\" << arg << std::endl;\n    }\n    else if(std::is_same<T, const int>::value) {\n        std::cout << \"'T' is type[const int]\" << \" arg:\" << arg << std::endl;\n    }\n    else if(std::is_same<T, int&>::value) {\n        std::cout << \"'T' is type[int&]\" << \" arg:\" << arg << std::endl;\n    }\n    else if(std::is_same<T, const int&>::value) {\n        std::cout << \"'T' is type[const int&]\" << \" arg:\" << arg << std::endl;\n    }\n    \n    std::cout << \"-----------------\" << std::endl;\n}\n\nint main() {\n  int a = 1;\n  const int& b = 2;\n  func(a);  //传入左值引用 T => int&\n  func(b);  //传入常量左值引用 T => const int&\n  func(3);  //传入右值引用 T => int\n  func(static_cast<int>(a));        //传入转换后的右值引用 T => int\n  func(static_cast<int&>(a));       //传入转换后的左值引用 T => int&\n  func(static_cast<const int&&>(a));//传入转换后的常量右值 T => const int\n  func<int>(a);  //错误❌ 显示指定模版形参，推导后只能接受右值引用，而a是左值\n  func<int&>(a); //示指定模版形参，推导后只可接受左值引用，a是左值\n  func<const int>(1); //示指定模版形参，推导后只可接受右值，且不能修改，1是右值\n}\n```\n输出结果为：\n\n```\n$g++ -std=c++11 -o main *.cpp\n$main\n'T' is type[int&] arg:1\n-----------------\n'T' is type[const int&] arg:2\n-----------------\n'T' is type[int] arg:3\n-----------------\n'T' is type[int] arg:1\n-----------------\n'T' is type[int&] arg:1\n-----------------\n'T' is type[const int] arg:1\n-----------------\n'T' is type[int&] arg:1\n-----------------\n'T' is type[const int] arg:1\n-----------------\n```\n错误信息：\n\n```\nmain.cpp:6:6: note:   template argument deduction/substitution failed:\nmain.cpp:35:14: note:   cannot convert ‘a’ (type ‘int’) to type ‘int&&’\n   func<int>(a);\n```\n\n{% label success@根据C++ Primer中文版(第五版) 18章第2节模板实参推断%}\n<strong>Note:如果显示推导模版T的类型，可能会导致编译不过，因为会导致推到出来的函数实参和形参引用类型不一致</strong>\n\n\n\n## std::forward()\n\n### std::forward完美转发解析\n\n> 完美转发实现了参数在传递过程中保持其值属性的功能，即若是左值，则传递之后仍然是左值，若是右值，则传递之后仍然是右值。\n>\n> C++11 lets us perform perfect forwarding, which means that we can forward the parameters passed to a function template to another function call inside it without losing their own qualifiers (const-ref, ref, value, rvalue, etc.).\n\n### std::forward()解析\n\nstd::forward只有在它的参数绑定到一个右值上的时候，它才转换它的参数到一个右值。\n\n```cpp\nclass Foo\n{\npublic:\n    std::string member;\n\n    template<typename T>\n    Foo(T&& member): member{std::forward<T>(member)} {}\n};\n```\n\n**对于Foo函数中member变量，无论之前是什么，都变为左值了，因为他有名字了**:smile:\n\n传递一个lvalue或者传递一个const lvaue\n\n- 传递一个lvalue，模板推导之后 `T = std::string&`\n- 传递一个const lvaue, 模板推导之后`T = const std::string&`\n- `T& &&`将折叠为T&，即`std::string& && 折叠为 std::string&`\n- 最终函数为: `Foo(string& member): member{std::forward<string&>(member)} {}`\n- std::forward<string&>(member)将返回一个左值，最终调用拷贝构造函数\n\n传递一个rvalue\n\n- 传递一个rvalue，模板推导之后 `T = std::string`\n- 最终函数为: `Foo(string&& member): member{std::forward<string>(member)} {}`\n- std::forward<string>(member) 将返回一个右值，最终调用移动构造函数；\n\nstd::move和std::forward本质都是转换。std::move执行到右值的无条件转换。std::forward只有在它的参数绑定到一个右值上的时候，才转换它的参数到一个右值。\n\nstd::move没有move任何东西，std::forward没有转发任何东西。在运行期，它们没有做任何事情。它们没有产生需要执行的代码，一byte都没有。\n\n## std::move\n\n### std::move的使用\n\n```cpp\nclass Foo\n{\npublic:\n    std::string member;\n\n    // Copy member.\n    Foo(const std::string& m): member(m) {}\n\n    // Move member.\n    Foo(std::string&& m): member(std::move(m)) {}\n};\n```\n\n上述`Foo(std::string&& member)`中的member是rvalue reference，但是member却是一个左值lvalue，因此在初始化列表中需要使用std::move将其转换成rvalue。\n\n### std::move()解析\n\n标准库中move的定义如下：\n\n```cpp\ntemplate<typename T>\ntypename remove_reference<T>::type && move(T&& t)\n{\n    return static_cast<typename remove_reference<T>::type &&>(t);\n}\n```\n\n- move函数的参数T&&是一个指向模板类型参数的右值引用【规则2】，通过引用折叠，此参数可以和任何类型的实参匹配，因此move既可以传递一个左值，也可以传递一个右值；\n- std::move(string(\"hello\"))调用解析：\n  - 首先，根据模板推断规则，确地T的类型为string;\n  - typename remove_reference<T>::type && 的结果为 string &&;\n  - move函数的参数类型为string&&;\n  - static_cast<string &&>(t)，t已经是string&&，于是类型转换什么都不做，返回string &&;\n- string s1(\"hello\"); std::move(s1); 调用解析：\n  - 首先，根据模板推断规则，确定T的类型为string&;\n  - typename remove_reference<T>::type && 的结果为 string&\n  - move函数的参数类型为string& &&，引用折叠之后为string&;\n  - static_cast<string &&>(t)，t是string&，经过static_cast之后转换为string&&, 返回string &&;\n\n> 从move的定义可以看出，move自身除了做一些参数的推断之外，返回右值引用本质上还是靠static_cast<T&&>完成的。\n\n因此下面两个调用是等价的，std::move就是个语法糖。\n\n```cpp\nvoid func(int&& a)\n{\n    cout << a << endl;\n}\n\nint a = 6;\nfunc(std::move(a));\n\nint b = 10;\nfunc(static_cast<int&&>(b)); \n```\n\nstd::move执行到右值的无条件转换。就其本身而言，它没有move任何东西。\n\n## std::move()和std::forward()对比\n\n- std::move执行到右值的无条件转换。就其本身而言，它没有move任何东西。\n- std::forward只有在它的参数绑定到一个右值上的时候，它才转换它的参数到一个右值。\n- std::move和std::forward只不过就是执行类型转换的两个函数；std::move没有move任何东西，std::forward没有转发任何东西。在运行期，它们没有做任何事情。它们没有产生需要执行的代码，一byte都没有。\n- std::forward<T>()不仅可以保持左值或者右值不变，同时还可以保持const、Lreference、Rreference、validate等属性不变；","content":"<h2 id=\"C-中的万能引用和完美转发\">C++中的万能引用和完美转发<a href=\"posts/完美转发#C-中的万能引用和完美转发\"></a></h2><ul>\n<li>阅读这篇博文需要了解C++中的左值（lvalue）和右值（rvalue）的概念，详情参见我的另外一篇博文：C++移动语义及拷贝优化</li>\n<li>万能引用和完美转发多涉及到模板的使用，如若不是自己写模板，则可不用关心</li>\n</ul>\n<h3 id=\"左值与右值的区分\">左值与右值的区分<a href=\"posts/完美转发#左值与右值的区分\"></a></h3><p>首先理解什么是右值引用（下面是百度百科给出的解释）：</p>\n<p>   右值引用（及其支持的Move语意和完美转发）是C++0x将要加入的最重大语言特性之一，这点从该特性的提案在C++ - State of the Evolution列表上高居榜首也可以看得出来。从实践角度讲，它能够完美解决C++中长久以来为人所诟病的临时对象效率问题。从语言本身讲，它健全了C++中的引用类型在左值右值方面的缺陷。从库设计者的角度讲，它给库设计者又带来了一把利器。从库使用者的角度讲，不动一兵一卒便可以获得“免费的”效率提升… 　　在标准C++语言中，临时量（术语为右值，因其出现在赋值表达式的右边）可以被传给函数，但只能被接受为const &amp;类型。这样函数便无法区分传给const &amp;的是真实的右值还是常规变量。而且，由于类型为const &amp;，函数也无法改变所传对象的值。C++0x将增加一种名为右值引用的新的引用类型，记作typename &amp;&amp;。这种类型可以被接受为非const值，从而允许改变其值。</p>\n<a id=\"more\"></a>\n\n<p><strong>区分左值与右值：</strong></p>\n<p> C++ 11中引入的一个非常重要的概念就是右值引用。理解右值引用是学习“移动语义”（move semantics）的基础。而要理解右值引用，就必须先区分左值与右值。<br>       对左值和右值的一个最常见的误解是：等号左边的就是左值，等号右边的就是右值。</p>\n<p><strong>什么是左值引用：</strong><br>       区分清楚了左值与右值，我们再来看看左值引用。左值引用根据其修饰符的不同，可以分为非常量左值引用(<strong>eg.1 double &amp;r =i;</strong>)和常量左值引用(<strong>eg.1 const double &amp;r =i;</strong>)。<br>       非常量左值引用只能绑定到非常量左值，不能绑定到常量左值、非常量右值和常量右值。如果允许绑定到常量左值和常量右值，则非常量左值引用可以用于修改常量左值和常量右值，这明显违反了其常量的含义(<strong>eg.1中就是出现了非常量左值引用绑定到常量右值的情况</strong>)。如果允许绑定到非常量右值，则会导致非常危险的情况出现，因为非常量右值是一个临时对象，非常量左值引用可能会使用一个已经被销毁了的临时对象。<br>       <strong>常量左值引用可以绑定到所有类型的值，包括非常量左值、常量左值、非常量右值和常量右值。</strong></p>\n<p>如果同时包含左值和右值的函数重载，右值会优先匹配右值的重载版本，其次匹配常量左值重载版本。</p>\n<h3 id=\"万能引用（Universal-Reference）\">万能引用（Universal Reference）<a href=\"posts/完美转发#万能引用（Universal-Reference）\"></a></h3><p>首先，我们来看一个例子：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(T&amp; param)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; param &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num = <span class=\"number\">2019</span>;</span><br><span class=\"line\">    func(num);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>这样例子的编译输出都没有什么问题，但是如果我们修改成下面的调用方式呢？</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> main() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"number\">2019</span>)</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span><span class=\"comment\">;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>则会得到一个大大的编译错误。因为上面的模板函数只能接受左值或者左值引用（左值一般是有名字的变量，可以取到地址的），我们当然可以重载一个接受右值的模板函数，如下也可以达到效果。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(T&amp; param)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"传入的是左值\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"传入的是右值\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num = <span class=\"number\">2019</span>;</span><br><span class=\"line\">    func(num);</span><br><span class=\"line\">    func(<span class=\"number\">2019</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">传入的是左值</span><br><span class=\"line\">传入的是右值</span><br></pre></td></tr></table></div></figure>\n\n<p>第一次函数调用的是左值得版本，第二次函数调用的是右值版本。但是，有没有办法只写一个模板函数即可以接收左值又可以接收右值呢？</p>\n<p>​     <strong>C++ 11中有万能引用（Universal Reference）的概念：使用T&amp;&amp;类型的形参既能绑定右值，又能绑定左值。只有在模版中才生效，普通函数中左值引用（非常量）只接受左值，右值引用只接受右值，const 左值引用可以接受任何值，const 右值引用能接受任何右值，推导后的模版也同理。</strong></p>\n<p>但是注意了：<strong>只有发生类型推导的时候，T&amp;&amp;才表示万能引用；</strong> 否则，表示右值引用。</p>\n<p>所以，上面的案例我们可以修改为：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">void <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(T&amp;&amp; param)</span> &#123;</span></span><br><span class=\"line\">    cout &lt;&lt; param &lt;&lt; endl<span class=\"comment\">;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">int</span> main() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> num = <span class=\"number\">2019</span><span class=\"comment\">;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(num)</span>;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"number\">2019</span>)</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span><span class=\"comment\">;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"引用折叠（Universal-Collapse）\">引用折叠（Universal Collapse）<a href=\"posts/完美转发#引用折叠（Universal-Collapse）\"></a></h2><p>万能引用说完了，接着来聊引用折叠（Univers Collapse），因为完美转发（Perfect Forwarding）的概念涉及引用折叠。一个模板函数，根据定义的形参和传入的实参的类型，我们可以有下面四中组合：</p>\n<ul>\n<li>左值-左值 T&amp; &amp;        # 函数定义的形参类型是左值引用，传入的实参是左值引用</li>\n<li>左值-右值 T&amp; &amp;&amp;      # 函数定义的形参类型是左值引用，传入的实参是右值引用（必须const修饰）</li>\n<li>右值-左值 T&amp;&amp; &amp;      # 函数定义的形参类型是右值引用，传入的实参是左值引用</li>\n<li>右值-右值 T&amp;&amp; &amp;&amp;    # 函数定义的形参类型是右值引用，传入的实参是右值引用</li>\n</ul>\n<p>但是C++中不允许对引用再进行引用，对于上述情况的处理有如下的规则：</p>\n<p>所有的折叠引用最终都代表一个引用，要么是左值引用，要么是右值引用。规则是：如果任一引用为左值引用，则结果为左值引用。否则（即两个都是右值引用），结果为右值引用。</p>\n<p>即就是前面三种情况代表的都是左值引用，而第四种代表的右值引用。</p>\n<h2 id=\"完美转发（Perfect-Forwarding）\">完美转发（Perfect Forwarding）<a href=\"posts/完美转发#完美转发（Perfect-Forwarding）\"></a></h2><p>下面接着说完美转发（Perfect Forwarding），首先，看个例子：</p>\n<p>🌰[栗子]<br>要了解完美转发，先得清楚模板T的<strong>推导过程</strong>，<span class=\"label success\">在没有偏特化的模版前提下，模板总是根据最匹配的规则来推导参数，左值引用template函数推导出来总是左值引用函数，右值引用template函数能推导出左值引用和右值引用函数</span>，可以根据下面的例子来看出推导过程。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//auto is_lval = std::is_lvalue_reference&lt;T&gt;::value;</span></span><br><span class=\"line\">    <span class=\"comment\">//auto is_rval  = std::is_rvalue_reference&lt;T&gt;::value;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">std</span>::is_same&lt;T, <span class=\"keyword\">int</span>&gt;::value) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"'T' is type[int]\"</span>  &lt;&lt; <span class=\"string\">\" arg:\"</span> &lt;&lt; arg &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">std</span>::is_same&lt;T, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&gt;::value) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"'T' is type[const int]\"</span> &lt;&lt; <span class=\"string\">\" arg:\"</span> &lt;&lt; arg &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">std</span>::is_same&lt;T, <span class=\"keyword\">int</span>&amp;&gt;::value) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"'T' is type[int&amp;]\"</span> &lt;&lt; <span class=\"string\">\" arg:\"</span> &lt;&lt; arg &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">std</span>::is_same&lt;T, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;&gt;::value) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"'T' is type[const int&amp;]\"</span> &lt;&lt; <span class=\"string\">\" arg:\"</span> &lt;&lt; arg &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"-----------------\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; b = <span class=\"number\">2</span>;</span><br><span class=\"line\">  func(a);  <span class=\"comment\">//传入左值引用 T =&gt; int&amp;</span></span><br><span class=\"line\">  func(b);  <span class=\"comment\">//传入常量左值引用 T =&gt; const int&amp;</span></span><br><span class=\"line\">  func(<span class=\"number\">3</span>);  <span class=\"comment\">//传入右值引用 T =&gt; int</span></span><br><span class=\"line\">  func(<span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(a));        <span class=\"comment\">//传入转换后的右值引用 T =&gt; int</span></span><br><span class=\"line\">  func(<span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&amp;&gt;(a));       <span class=\"comment\">//传入转换后的左值引用 T =&gt; int&amp;</span></span><br><span class=\"line\">  func(<span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;&amp;&gt;(a));<span class=\"comment\">//传入转换后的常量右值 T =&gt; const int</span></span><br><span class=\"line\">  func&lt;<span class=\"keyword\">int</span>&gt;(a);  <span class=\"comment\">//错误❌ 显示指定模版形参，推导后只能接受右值引用，而a是左值</span></span><br><span class=\"line\">  func&lt;<span class=\"keyword\">int</span>&amp;&gt;(a); <span class=\"comment\">//示指定模版形参，推导后只可接受左值引用，a是左值</span></span><br><span class=\"line\">  func&lt;<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&gt;(<span class=\"number\">1</span>); <span class=\"comment\">//示指定模版形参，推导后只可接受右值，且不能修改，1是右值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>输出结果为：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$g++ -std=<span class=\"keyword\">c</span>++<span class=\"number\">11</span> -<span class=\"keyword\">o</span> main *.cpp</span><br><span class=\"line\">$main</span><br><span class=\"line\"><span class=\"string\">'T'</span> <span class=\"keyword\">is</span> <span class=\"built_in\">type</span>[<span class=\"keyword\">int</span>&amp;] <span class=\"keyword\">ar</span><span class=\"variable\">g:1</span></span><br><span class=\"line\">-----------------</span><br><span class=\"line\"><span class=\"string\">'T'</span> <span class=\"keyword\">is</span> <span class=\"built_in\">type</span>[const <span class=\"keyword\">int</span>&amp;] <span class=\"keyword\">ar</span><span class=\"variable\">g:2</span></span><br><span class=\"line\">-----------------</span><br><span class=\"line\"><span class=\"string\">'T'</span> <span class=\"keyword\">is</span> <span class=\"built_in\">type</span>[<span class=\"keyword\">int</span>] <span class=\"keyword\">ar</span><span class=\"variable\">g:3</span></span><br><span class=\"line\">-----------------</span><br><span class=\"line\"><span class=\"string\">'T'</span> <span class=\"keyword\">is</span> <span class=\"built_in\">type</span>[<span class=\"keyword\">int</span>] <span class=\"keyword\">ar</span><span class=\"variable\">g:1</span></span><br><span class=\"line\">-----------------</span><br><span class=\"line\"><span class=\"string\">'T'</span> <span class=\"keyword\">is</span> <span class=\"built_in\">type</span>[<span class=\"keyword\">int</span>&amp;] <span class=\"keyword\">ar</span><span class=\"variable\">g:1</span></span><br><span class=\"line\">-----------------</span><br><span class=\"line\"><span class=\"string\">'T'</span> <span class=\"keyword\">is</span> <span class=\"built_in\">type</span>[const <span class=\"keyword\">int</span>] <span class=\"keyword\">ar</span><span class=\"variable\">g:1</span></span><br><span class=\"line\">-----------------</span><br><span class=\"line\"><span class=\"string\">'T'</span> <span class=\"keyword\">is</span> <span class=\"built_in\">type</span>[<span class=\"keyword\">int</span>&amp;] <span class=\"keyword\">ar</span><span class=\"variable\">g:1</span></span><br><span class=\"line\">-----------------</span><br><span class=\"line\"><span class=\"string\">'T'</span> <span class=\"keyword\">is</span> <span class=\"built_in\">type</span>[const <span class=\"keyword\">int</span>] <span class=\"keyword\">ar</span><span class=\"variable\">g:1</span></span><br><span class=\"line\">-----------------</span><br></pre></td></tr></table></div></figure>\n\n<p>错误信息：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main.cpp:6:6: note:   template argument deduction/substitution failed:</span><br><span class=\"line\">main.cpp:35:14: note:   cannot convert ‘a’ (type ‘int’) <span class=\"keyword\">to</span><span class=\"built_in\"> type </span>‘int&amp;&amp;’</span><br><span class=\"line\">   func&lt;int&gt;(a);</span><br></pre></td></tr></table></div></figure>\n\n<span class=\"label success\">根据C++ Primer中文版(第五版) 18章第2节模板实参推断</span>\n<p><strong>Note:如果显示推导模版T的类型，可能会导致编译不过，因为会导致推到出来的函数实参和形参引用类型不一致</strong></p>\n<h2 id=\"std-forward\">std::forward()<a href=\"posts/完美转发#std-forward\"></a></h2><h3 id=\"std-forward完美转发解析\">std::forward完美转发解析<a href=\"posts/完美转发#std-forward完美转发解析\"></a></h3><blockquote>\n<p>完美转发实现了参数在传递过程中保持其值属性的功能，即若是左值，则传递之后仍然是左值，若是右值，则传递之后仍然是右值。</p>\n<p>C++11 lets us perform perfect forwarding, which means that we can forward the parameters passed to a function template to another function call inside it without losing their own qualifiers (const-ref, ref, value, rvalue, etc.).</p>\n</blockquote>\n<h3 id=\"std-forward-解析\">std::forward()解析<a href=\"posts/完美转发#std-forward-解析\"></a></h3><p>std::forward只有在它的参数绑定到一个右值上的时候，它才转换它的参数到一个右值。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> member;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">    Foo(T&amp;&amp; member): member&#123;<span class=\"built_in\">std</span>::forward&lt;T&gt;(member)&#125; &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p><strong>对于Foo函数中member变量，无论之前是什么，都变为左值了，因为他有名字了</strong>:smile:</p>\n<p>传递一个lvalue或者传递一个const lvaue</p>\n<ul>\n<li>传递一个lvalue，模板推导之后 <code>T = std::string&amp;</code></li>\n<li>传递一个const lvaue, 模板推导之后<code>T = const std::string&amp;</code></li>\n<li><code>T&amp; &amp;&amp;</code>将折叠为T&amp;，即<code>std::string&amp; &amp;&amp; 折叠为 std::string&amp;</code></li>\n<li>最终函数为: <code>Foo(string&amp; member): member{std::forward&lt;string&amp;&gt;(member)} {}</code></li>\n<li>std::forward&lt;string&amp;&gt;(member)将返回一个左值，最终调用拷贝构造函数</li>\n</ul>\n<p>传递一个rvalue</p>\n<ul>\n<li>传递一个rvalue，模板推导之后 <code>T = std::string</code></li>\n<li>最终函数为: <code>Foo(string&amp;&amp; member): member{std::forward&lt;string&gt;(member)} {}</code></li>\n<li>std::forward<string>(member) 将返回一个右值，最终调用移动构造函数；</string></li>\n</ul>\n<p>std::move和std::forward本质都是转换。std::move执行到右值的无条件转换。std::forward只有在它的参数绑定到一个右值上的时候，才转换它的参数到一个右值。</p>\n<p>std::move没有move任何东西，std::forward没有转发任何东西。在运行期，它们没有做任何事情。它们没有产生需要执行的代码，一byte都没有。</p>\n<h2 id=\"std-move\">std::move<a href=\"posts/完美转发#std-move\"></a></h2><h3 id=\"std-move的使用\">std::move的使用<a href=\"posts/完美转发#std-move的使用\"></a></h3><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> member;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Copy member.</span></span><br><span class=\"line\">    Foo(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; m): member(m) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Move member.</span></span><br><span class=\"line\">    Foo(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp;&amp; m): member(<span class=\"built_in\">std</span>::move(m)) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p>上述<code>Foo(std::string&amp;&amp; member)</code>中的member是rvalue reference，但是member却是一个左值lvalue，因此在初始化列表中需要使用std::move将其转换成rvalue。</p>\n<h3 id=\"std-move-解析\">std::move()解析<a href=\"posts/完美转发#std-move-解析\"></a></h3><p>标准库中move的定义如下：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">typename</span> remove_reference&lt;T&gt;::<span class=\"function\">type &amp;&amp; <span class=\"title\">move</span><span class=\"params\">(T&amp;&amp; t)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">typename</span> remove_reference&lt;T&gt;::type &amp;&amp;&gt;(t);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<ul>\n<li>move函数的参数T&amp;&amp;是一个指向模板类型参数的右值引用【规则2】，通过引用折叠，此参数可以和任何类型的实参匹配，因此move既可以传递一个左值，也可以传递一个右值；</li>\n<li>std::move(string(“hello”))调用解析：<ul>\n<li>首先，根据模板推断规则，确地T的类型为string;</li>\n<li>typename remove_reference<t>::type &amp;&amp; 的结果为 string &amp;&amp;;</t></li>\n<li>move函数的参数类型为string&amp;&amp;;</li>\n<li>static_cast&lt;string &amp;&amp;&gt;(t)，t已经是string&amp;&amp;，于是类型转换什么都不做，返回string &amp;&amp;;</li>\n</ul>\n</li>\n<li>string s1(“hello”); std::move(s1); 调用解析：<ul>\n<li>首先，根据模板推断规则，确定T的类型为string&amp;;</li>\n<li>typename remove_reference<t>::type &amp;&amp; 的结果为 string&amp;</t></li>\n<li>move函数的参数类型为string&amp; &amp;&amp;，引用折叠之后为string&amp;;</li>\n<li>static_cast&lt;string &amp;&amp;&gt;(t)，t是string&amp;，经过static_cast之后转换为string&amp;&amp;, 返回string &amp;&amp;;</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>从move的定义可以看出，move自身除了做一些参数的推断之外，返回右值引用本质上还是靠static_cast&lt;T&amp;&amp;&gt;完成的。</p>\n</blockquote>\n<p>因此下面两个调用是等价的，std::move就是个语法糖。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span>&amp;&amp; a)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">6</span>;</span><br><span class=\"line\">func(<span class=\"built_in\">std</span>::move(a));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\">func(<span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&amp;&amp;&gt;(b));</span><br></pre></td></tr></table></div></figure>\n\n<p>std::move执行到右值的无条件转换。就其本身而言，它没有move任何东西。</p>\n<h2 id=\"std-move-和std-forward-对比\">std::move()和std::forward()对比<a href=\"posts/完美转发#std-move-和std-forward-对比\"></a></h2><ul>\n<li>std::move执行到右值的无条件转换。就其本身而言，它没有move任何东西。</li>\n<li>std::forward只有在它的参数绑定到一个右值上的时候，它才转换它的参数到一个右值。</li>\n<li>std::move和std::forward只不过就是执行类型转换的两个函数；std::move没有move任何东西，std::forward没有转发任何东西。在运行期，它们没有做任何事情。它们没有产生需要执行的代码，一byte都没有。</li>\n<li>std::forward<t>()不仅可以保持左值或者右值不变，同时还可以保持const、Lreference、Rreference、validate等属性不变；</t></li>\n</ul>\n","slug":"完美转发","updated":"2019-09-28T02:27:03.644Z","comments":true,"link":"posts/完美转发","permalink":"https://shuntan.github.io/posts/完美转发/","excerpt":"C++中的万能引用和完美转发 阅读这篇博文需要了解C++中的左值（lvalue）和右值（rvalue）的概念，详情参见我的另外一篇博文：C++移动语义及拷贝优化 万能引用和完美转发多涉及到模板的使用，如若不是自己写模板，则可不用关心 左值与右值的区分首先理解什么是右值引用（下面是百度百科给出的解释）： 右值引用（及其支持的Move语意和完美转发）是C++0x将要加入的最重大语言特性之一，这点从该特性的提案在C++ - State of the Evolution列表上高居榜首也可以看得出来。从实践角度讲，它能够完美解决C++中长久以来为人所诟病的临时对象效率问题。从语言本身讲，它健全了C++中的引用类型在左值右值方面的缺陷。从库设计者的角度讲，它给库设计者又带来了一把利器。从库使用者的角度讲，不动一兵一卒便可以获得“免费的”效率提升… 在标准C++语言中，临时量（术语为右值，因其出现在赋值表达式的右边）可以被传给函数，但只能被接受为const &amp;类型。这样函数便无法区分传给const &amp;的是真实的右值还是常规变量。而且，由于类型为const &amp;，函数也无法改变所传对象的值。C++0x将增加一种名为右值引用的新的引用类型，记作typename &amp;&amp;。这种类型可以被接受为非const值，从而允许改变其值。","categories":[{"name":"C++","slug":"C","permalink":"https://shuntan.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://shuntan.github.io/tags/C/"}]},{"title":"从4行代码看右值引用","date":"2019-05-23T06:50:40.000Z","path":"posts/右值引用/","text":"概述 右值引用的概念有些读者可能会感到陌生，其实他和C++98/03中的左值引用有些类似，例如，c++98/03中的左值引用是这样的： 12int i = 0;int&amp; j = i; 这里的int&amp;是对左值进行绑定（但是int&amp;却不能绑定右值），相应的，对右值进行绑定的引用就是右值引用，他的语法是这样的A&amp;&amp;，通过双引号来表示绑定类型为A的右值。通过&amp;&amp;我们就可以很方便的绑定右值了，比如我们可以这样绑定一个右值： 1int&amp;&amp; i = 0; 这里我们绑定了一个右值0，关于右值的概念会在后面介绍。右值引用是C++11中新增加的一个很重要的特性，他主是要用来解决C++98/03中遇到的两个问题，第一个问题就是临时对象非必要的昂贵的拷贝操作，第二个问题是在模板函数中如何按照参数的实际类型进行转发。通过引入右值引用，很好的解决了这两个问题，改进了程序性能，后面将会详细介绍右值引用是如何解决这两个问题的。 和右值引用相关的概念比较多，比如：右值、纯右值、将亡值、universal references、引用折叠、移动语义、move语义和完美转发等等。很多都是新概念，对于刚学习C++11右值引用的初学者来说，可能会觉得右值引用过于复杂，概念之间的关系难以理清。 右值引用实际上并没有那么复杂，其实是关于4行代码的故事，通过简单的4行代码我们就能清晰的理解右值引用相关的概念了。本文希望带领读者通过4行代码来理解右值引用相关的概念，理清他们之间的关系，并最终能透彻地掌握C++11的新特性–右值引用。 四行代码的故事第1行代码的故事1int i = getVar(); 上面的这行代码很简单，从getVar()函数获取一个整形值，然而，这行代码会产生几种类型的值呢？答案是会产生两种类型的值，一种是左值i，一种是函数getVar()返回的临时值，这个临时值在表达式结束后就销毁了，而左值i在表达式结束后仍然存在，这个临时值就是右值，具体来说是一个纯右值，右值是不具名的。区分左值和右值的一个简单办法是：看能不能对表达式取地址，如果能，则为左值，否则为右值。 所有的具名变量或对象都是左值，而匿名变量则是右值，比如，简单的赋值语句： 1int i = 0; 在这条语句中，i 是左值，0 是字面量，就是右值。在上面的代码中，i 可以被引用，0 就不可以了。具体来说上面的表达式中等号右边的0是纯右值（prvalue），在C++11中所有的值必属于左值、将亡值、纯右值三者之一。比如，非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和lambda表达式等都是纯右值。而将亡值是C++11新增的、与右值引用相关的表达式，比如，将要被移动的对象、T&amp;&amp;函数返回值、std::move返回值和转换为T&amp;&amp;的类型的转换函数的返回值等。关于将亡值我们会在后面介绍，先看下面的代码： 123int j = 5;auto f = []&#123;return 5;&#125;; 上面的代码中5是一个原始字面量， []{return 5;}是一个lambda表达式，都是属于纯右值，他们的特点是在表达式结束之后就销毁了。 通过地行代码我们对右值有了一个初步的认识，知道了什么是右值，接下来再来看看第二行代码。 第2行代码的故事1T&amp;&amp; k = getVar(); 第二行代码和第一行代码很像，只是相比第一行代码多了“&amp;&amp;”，他就是右值引用，我们知道左值引用是对左值的引用，那么，对应的，对右值的引用就是右值引用，而且右值是匿名变量，我们也只能通过引用的方式来获取右值。虽然第二行代码和第一行代码看起来差别不大，但是实际上语义的差别很大，这里，getVar()产生的临时值不会像第一行代码那样，在表达式结束之后就销毁了，而是会被“续命”，他的生命周期将会通过右值引用得以延续，和变量k的声明周期一样长。 右值引用的第一个特点 通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去。让我们通过一个简单的例子来看看右值的生命周期。如代码清单1-1所示。 代码清单1-1 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;int g_constructCount=0;int g_copyConstructCount=0;int g_destructCount=0;struct A&#123; A()&#123; cout&lt;&lt;\"construct: \"&lt;&lt;++g_constructCount&lt;&lt;endl; &#125; A(const A&amp; a) &#123; cout&lt;&lt;\"copy construct: \"&lt;&lt;++g_copyConstructCount &lt;&lt;endl; &#125; ~A() &#123; cout&lt;&lt;\"destruct: \"&lt;&lt;++g_destructCount&lt;&lt;endl; &#125;&#125;;A GetA()&#123; return A();&#125;int main() &#123; A a = GetA(); return 0;&#125; 为了清楚的观察临时值，在编译时设置编译选项-fno-elide-constructors用来关闭返回值优化效果。 输出结果： 123456construct: 1copy construct: 1destruct: 1copy construct: 2destruct: 2destruct: 3 从上面的例子中可以看到，在没有返回值优化的情况下，拷贝构造函数调用了两次，一次是GetA()函数内部创建的对象返回出来构造一个临时对象产生的，另一次是在main函数中构造a对象产生的。第二次的destruct是因为临时对象在构造a对象之后就销毁了。如果开启返回值优化的话，输出结果将是： construct: 1 destruct: 1 可以看到返回值优化将会把临时对象优化掉，但这不是c++标准，是各编译器的优化规则。我们在回到之前提到的可以通过右值引用来延长临时右值的生命周期，如果上面的代码中我们通过右值引用来绑定函数返回值的话，结果又会是什么样的呢？在编译时设置编译选项-fno-elide-constructors。 123456789int main() &#123; A&amp;&amp; a = GetA(); return 0;&#125;输出结果：construct: 1copy construct: 1destruct: 1destruct: 2 通过右值引用，比之前少了一次拷贝构造和一次析构，原因在于右值引用绑定了右值，让临时右值的生命周期延长了。我们可以利用这个特点做一些性能优化，即避免临时对象的拷贝构造和析构，事实上，在c++98/03中，通过常量左值引用也经常用来做性能优化。上面的代码改成： const A&amp; a = GetA(); 输出的结果和右值引用一样，因为常量左值引用是一个“万能”的引用类型，可以接受左值、右值、常量左值和常量右值。需要注意的是普通的左值引用不能接受右值，比如这样的写法是不对的： A&amp; a = GetA(); 上面的代码会报一个编译错误，因为非常量左值引用只能接受左值。 右值引用的第二个特点 右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值。比如下面的例子： 1int&amp;&amp; var1 = 1; var1类型为右值引用，但var1本身是左值，因为具名变量都是左值。 关于右值引用一个有意思的问题是：T&amp;&amp;是什么，一定是右值吗？让我们来看看下面的例子： 12345template&lt;typename T&gt;void f(T&amp;&amp; t)&#123;&#125;f(10); //t是右值int x = 10;f(x); //t是左值 从上面的代码中可以看到，T&amp;&amp;表示的值类型不确定，可能是左值又可能是右值，这一点看起来有点奇怪，这就是右值引用的一个特点。 右值引用的第三个特点 T&amp;&amp; t在发生自动类型推断的时候，它是未定的引用类型（universal references），如果被一个左值初始化，它就是一个左值；如果它被一个右值初始化，它就是一个右值，它是左值还是右值取决于它的初始化。 我们再回过头看上面的代码，对于函数templatevoid f(T&amp;&amp; t)，当参数为右值10的时候，根据universal references的特点，t被一个右值初始化，那么t就是右值；当参数为左值x时，t被一个左值引用初始化，那么t就是一个左值。需要注意的是，仅仅是当发生自动类型推导（如函数模板的类型自动推导，或auto关键字）的时候，T&amp;&amp;才是universal references。再看看下面的例子： 1234567template&lt;typename T&gt;void f(T&amp;&amp; param); template&lt;typename T&gt;class Test &#123; Test(Test&amp;&amp; rhs); &#125;; 上面的例子中，param是universal reference，rhs是Test&amp;&amp;右值引用，因为模版函数f发生了类型推断，而Test&amp;&amp;并没有发生类型推导，因为Test&amp;&amp;是确定的类型了。 正是因为右值引用可能是左值也可能是右值，依赖于初始化，并不是一下子就确定的特点，我们可以利用这一点做很多文章，比如后面要介绍的移动语义和完美转发。 这里再提一下引用折叠，正是因为引入了右值引用，所以可能存在左值引用与右值引用和右值引用与右值引用的折叠，C++11确定了引用折叠的规则，规则是这样的： 所有的右值引用叠加到右值引用上仍然还是一个右值引用； 所有的其他引用类型之间的叠加都将变成左值引用。 第3行代码的故事1T(T&amp;&amp; a) : m_val(val)&#123; a.m_val=nullptr; &#125; 这行代码实际上来自于一个类的构造函数，构造函数的一个参数是一个右值引用，为什么将右值引用作为构造函数的参数呢？在解答这个问题之前我们先看一个例子。如代码清单1-2所示。 代码清单1-2 1234567891011121314151617181920class A&#123;public: A():m_ptr(new int(0))&#123;cout &lt;&lt; \"construct\" &lt;&lt; endl;&#125; A(const A&amp; a):m_ptr(new int(*a.m_ptr)) //深拷贝的拷贝构造函数 &#123; cout &lt;&lt; \"copy construct\" &lt;&lt; endl; &#125; ~A()&#123; delete m_ptr;&#125;private: int* m_ptr;&#125;;int main() &#123; A a = GetA(); return 0;&#125; 输出：constructcopy constructcopy construct 这个例子很简单，一个带有堆内存的类，必须提供一个深拷贝拷贝构造函数，因为默认的拷贝构造函数是浅拷贝，会发生“指针悬挂”的问题。如果不提供深拷贝的拷贝构造函数，上面的测试代码将会发生错误（编译选项-fno-elide-constructors），内部的m_ptr将会被删除两次，一次是临时右值析构的时候删除一次，第二次外面构造的a对象释放时删除一次，而这两个对象的m_ptr是同一个指针，这就是所谓的指针悬挂问题。提供深拷贝的拷贝构造函数虽然可以保证正确，但是在有些时候会造成额外的性能损耗，因为有时候这种深拷贝是不必要的。比如下面的代码： 上面代码中的GetA函数会返回临时变量，然后通过这个临时变量拷贝构造了一个新的对象a，临时变量在拷贝构造完成之后就销毁了，如果堆内存很大的话，那么，这个拷贝构造的代价会很大，带来了额外的性能损失。每次都会产生临时变量并造成额外的性能损失，有没有办法避免临时变量造成的性能损失呢？答案是肯定的，C++11已经有了解决方法，看看下面的代码。如代码清单1-3所示。 代码清单1-3 123456789101112131415161718192021222324class A&#123;public: A() :m_ptr(new int(0))&#123;&#125; A(const A&amp; a):m_ptr(new int(*a.m_ptr)) //深拷贝的拷贝构造函数 &#123; cout &lt;&lt; \"copy construct\" &lt;&lt; endl; &#125; A(A&amp;&amp; a) :m_ptr(a.m_ptr) &#123; a.m_ptr = nullptr; cout &lt;&lt; \"move construct\" &lt;&lt; endl; &#125; ~A()&#123; delete m_ptr;&#125;private: int* m_ptr;&#125;;int main()&#123; A a = Get(false); &#125; 输出：constructmove constructmove construct 代码清单1-3和1-2相比只多了一个构造函数，输出结果表明，并没有调用拷贝构造函数，只调用了move construct函数，让我们来看看这个move construct函数： 12345A(A&amp;&amp; a) :m_ptr(a.m_ptr)&#123; a.m_ptr = nullptr; cout &lt;&lt; \"move construct\" &lt;&lt; endl;&#125; 这个构造函数并没有做深拷贝，仅仅是将指针的所有者转移到了另外一个对象，同时，将参数对象a的指针置为空，这里仅仅是做了浅拷贝，因此，这个构造函数避免了临时变量的深拷贝问题。 上面这个函数其实就是移动构造函数，他的参数是一个右值引用类型，这里的A&amp;&amp;表示右值，为什么？前面已经提到，这里没有发生类型推断，是确定的右值引用类型。为什么会匹配到这个构造函数？因为这个构造函数只能接受右值参数，而函数返回值是右值，所以就会匹配到这个构造函数。这里的A&amp;&amp;可以看作是临时值的标识，对于临时值我们仅仅需要做浅拷贝即可，无需再做深拷贝，从而解决了前面提到的临时变量拷贝构造产生的性能损失的问题。这就是所谓的移动语义，右值引用的一个重要作用是用来支持移动语义的。 需要注意的一个细节是，我们提供移动构造函数的同时也会提供一个拷贝构造函数，以防止移动不成功的时候还能拷贝构造，使我们的代码更安全。 我们知道移动语义是通过右值引用来匹配临时值的，那么，普通的左值是否也能借助移动语义来优化性能呢，那该怎么做呢？事实上C++11为了解决这个问题，提供了std::move方法来将左值转换为右值，从而方便应用移动语义。move是将对象资源的所有权从一个对象转移到另一个对象，只是转移，没有内存的拷贝，这就是所谓的move语义。如图1-1所示是深拷贝和move的区别。 图1-1 深拷贝和move的区别 再看看下面的例子： 1234567&#123; std::list&lt; std::string&gt; tokens; //省略初始化... std::list&lt; std::string&gt; t = tokens; //这里存在拷贝 &#125;std::list&lt; std::string&gt; tokens;std::list&lt; std::string&gt; t = std::move(tokens); //这里没有拷贝 如果不用std::move，拷贝的代价很大，性能较低。使用move几乎没有任何代价，只是转换了资源的所有权。他实际上将左值变成右值引用，然后应用移动语义，调用移动构造函数，就避免了拷贝，提高了程序性能。如果一个对象内部有较大的对内存或者动态数组时，很有必要写move语义的拷贝构造函数和赋值函数，避免无谓的深拷贝，以提高性能。事实上，C++11中所有的容器都实现了移动语义，方便我们做性能优化。 这里也要注意对move语义的误解，move实际上它并不能移动任何东西，它唯一的功能是将一个左值强制转换为一个右值引用。如果是一些基本类型比如int和char[10]定长数组等类型，使用move的话仍然会发生拷贝（因为没有对应的移动构造函数）。所以，move对于含资源（堆内存或句柄）的对象来说更有意义。 第4行代码故事1template &lt;typename T&gt;void f(T&amp;&amp; val)&#123; foo(std::forward&lt;T&gt;(val)); &#125; C++11之前调用模板函数时，存在一个比较头疼的问题，如何正确的传递参数。比如： 12345678910template &lt;typename T&gt;void forwardValue(T&amp; val)&#123; processValue(val); //右值参数会变成左值 &#125;template &lt;typename T&gt;void forwardValue(const T&amp; val)&#123; processValue(val); //参数都变成常量左值引用了 &#125; 都不能按照参数的本来的类型进行转发。 C++11引入了完美转发：在函数模板中，完全依照模板的参数的类型（即保持参数的左值、右值特征），将参数传递给函数模板中调用的另外一个函数。C++11中的std::forward正是做这个事情的，他会按照参数的实际类型进行转发。看下面的例子： 12345678910111213141516void processValue(int&amp; a)&#123; cout &lt;&lt; \"lvalue\" &lt;&lt; endl; &#125;void processValue(int&amp;&amp; a)&#123; cout &lt;&lt; \"rvalue\" &lt;&lt; endl; &#125;template &lt;typename T&gt;void forwardValue(T&amp;&amp; val)&#123; processValue(std::forward&lt;T&gt;(val)); //照参数本来的类型进行转发。&#125;void Testdelcl()&#123; int i = 0; forwardValue(i); //传入左值 forwardValue(0);//传入右值 &#125;输出：lvaue rvalue 右值引用T&amp;&amp;是一个universal references，可以接受左值或者右值，正是这个特性让他适合作为一个参数的路由，然后再通过std::forward按照参数的实际类型去匹配对应的重载函数，最终实现完美转发。 我们可以结合完美转发和移动语义来实现一个泛型的工厂函数，这个工厂函数可以创建所有类型的对象。具体实现如下： 12345template&lt;typename… Args&gt;T* Instance(Args&amp;&amp;… args)&#123; return new T(std::forward&lt;Args &gt;(args)…);&#125; 这个工厂函数的参数是右值引用类型，内部使用std::forward按照参数的实际类型进行转发，如果参数的实际类型是右值，那么创建的时候会自动匹配移动构造，如果是左值则会匹配拷贝构造。 总结 通过4行代码我们知道了什么是右值和右值引用，以及右值引用的一些特点，利用这些特点我们才方便实现移动语义和完美转发。C++11正是通过引入右值引用来优化性能，具体来说是通过移动语义来避免无谓拷贝的问题，通过move语义来将临时生成的左值中的资源无代价的转移到另外一个对象中去，通过完美转发来解决不能按照参数实际类型来转发的问题（同时，完美转发获得的一个好处是可以实现移动语义）。 本文曾发表于《程序员》2015年1月刊。转载请注明出处。 后记：本文的内容主要来自于我在公司内部培训的一次课程，因为很多人对C++11右值引用搞不清或者理解得不深入，所以我觉得有必要拿出来分享一下，让更多的人看到，就整理了一下发到程序员杂志了，我相信读者看完之后对右值引用会有全面深入的了解。 一点梦想：尽自己一份力，让c++的世界变得更美好！","raw":"---\ntitle: 从4行代码看右值引用\ntags: C++\ncategories: C++\nabbrlink: 9d2f4ec8\ndate: 2019-05-23 14:50:40\ncopyright: true\ntype:\nkeyword:\ntop:\ncomments:\npassword:\ndescription:\nthumbnail:\n---\n\n## 概述\n　　右值引用的概念有些读者可能会感到陌生，其实他和C++98/03中的左值引用有些类似，例如，c++98/03中的左值引用是这样的：\n\n```\nint i = 0;\nint& j = i;\n```\n\n　　这里的int&是对左值进行绑定（但是int&却不能绑定右值），相应的，对右值进行绑定的引用就是右值引用，他的语法是这样的A&&，通过双引号来表示绑定类型为A的右值。通过&&我们就可以很方便的绑定右值了，比如我们可以这样绑定一个右值：\n　　\n<!-- more -->　　\n\n```\nint&& i = 0;\n```\n\n　　这里我们绑定了一个右值0，关于右值的概念会在后面介绍。右值引用是C++11中新增加的一个很重要的特性，他主是要用来解决C++98/03中遇到的两个问题，第一个问题就是临时对象非必要的昂贵的拷贝操作，第二个问题是在模板函数中如何按照参数的实际类型进行转发。通过引入右值引用，很好的解决了这两个问题，改进了程序性能，后面将会详细介绍右值引用是如何解决这两个问题的。\n\n　　和右值引用相关的概念比较多，比如：右值、纯右值、将亡值、universal references、引用折叠、移动语义、move语义和完美转发等等。很多都是新概念，对于刚学习C++11右值引用的初学者来说，可能会觉得右值引用过于复杂，概念之间的关系难以理清。\n\n右值引用实际上并没有那么复杂，其实是关于4行代码的故事，通过简单的4行代码我们就能清晰的理解右值引用相关的概念了。本文希望带领读者通过4行代码来理解右值引用相关的概念，理清他们之间的关系，并最终能透彻地掌握C++11的新特性--右值引用。\n\n## 四行代码的故事\n### 第1行代码的故事\n```\nint i = getVar();\n```\n　　上面的这行代码很简单，从getVar()函数获取一个整形值，然而，这行代码会产生几种类型的值呢？答案是会产生两种类型的值，一种是左值i，一种是函数getVar()返回的临时值，这个临时值在表达式结束后就销毁了，而左值i在表达式结束后仍然存在，这个临时值就是右值，具体来说是一个纯右值，右值是不具名的。区分左值和右值的一个简单办法是：看能不能对表达式取地址，如果能，则为左值，否则为右值。\n\n　　所有的具名变量或对象都是左值，而匿名变量则是右值，比如，简单的赋值语句：\n\n```\nint i = 0;\n```\n\n　　在这条语句中，i 是左值，0 是字面量，就是右值。在上面的代码中，i 可以被引用，0 就不可以了。具体来说上面的表达式中等号右边的0是纯右值（prvalue），在C++11中所有的值必属于左值、将亡值、纯右值三者之一。比如，非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和lambda表达式等都是纯右值。而将亡值是C++11新增的、与右值引用相关的表达式，比如，将要被移动的对象、T&&函数返回值、std::move返回值和转换为T&&的类型的转换函数的返回值等。关于将亡值我们会在后面介绍，先看下面的代码：\n\n```\nint j = 5;\n\nauto f = []{return 5;};\n```\n\n　　上面的代码中5是一个原始字面量， []{return 5;}是一个lambda表达式，都是属于纯右值，他们的特点是在表达式结束之后就销毁了。\n\n　　通过地行代码我们对右值有了一个初步的认识，知道了什么是右值，接下来再来看看第二行代码。\n\n### 第2行代码的故事\n```\nT&& k = getVar();\n```\n　　第二行代码和第一行代码很像，只是相比第一行代码多了“&&”，他就是右值引用，我们知道左值引用是对左值的引用，那么，对应的，对右值的引用就是右值引用，而且右值是匿名变量，我们也只能通过引用的方式来获取右值。虽然第二行代码和第一行代码看起来差别不大，但是实际上语义的差别很大，这里，getVar()产生的临时值不会像第一行代码那样，在表达式结束之后就销毁了，而是会被“续命”，他的生命周期将会通过右值引用得以延续，和变量k的声明周期一样长。\n\n右值引用的第一个特点\n　　通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去。让我们通过一个简单的例子来看看右值的生命周期。如代码清单1-1所示。\n\n代码清单1-1 \n\n```\n#include <iostream>\nusing namespace std;\n\nint g_constructCount=0;\nint g_copyConstructCount=0;\nint g_destructCount=0;\nstruct A\n{\n    A(){\n        cout<<\"construct: \"<<++g_constructCount<<endl;    \n    }\n    \n    A(const A& a)\n    {\n        cout<<\"copy construct: \"<<++g_copyConstructCount <<endl;\n    }\n    ~A()\n    {\n        cout<<\"destruct: \"<<++g_destructCount<<endl;\n    }\n};\n\nA GetA()\n{\n    return A();\n}\n\nint main() {\n    A a = GetA();\n    return 0;\n}\n```\n\n　　为了清楚的观察临时值，在编译时设置编译选项-fno-elide-constructors用来关闭返回值优化效果。\n\n　　输出结果：\n\n```\nconstruct: 1\ncopy construct: 1\ndestruct: 1\ncopy construct: 2\ndestruct: 2\ndestruct: 3\n```\n　　从上面的例子中可以看到，在没有返回值优化的情况下，拷贝构造函数调用了两次，一次是GetA()函数内部创建的对象返回出来构造一个临时对象产生的，另一次是在main函数中构造a对象产生的。第二次的destruct是因为临时对象在构造a对象之后就销毁了。如果开启返回值优化的话，输出结果将是：\n\nconstruct: 1\n\ndestruct: 1\n\n　　可以看到返回值优化将会把临时对象优化掉，但这不是c++标准，是各编译器的优化规则。我们在回到之前提到的可以通过右值引用来延长临时右值的生命周期，如果上面的代码中我们通过右值引用来绑定函数返回值的话，结果又会是什么样的呢？在编译时设置编译选项-fno-elide-constructors。\n\n```\nint main() {\n    A&& a = GetA();\n    return 0;\n}\n输出结果：\nconstruct: 1\ncopy construct: 1\ndestruct: 1\ndestruct: 2\n```\n　　通过右值引用，比之前少了一次拷贝构造和一次析构，原因在于右值引用绑定了右值，让临时右值的生命周期延长了。我们可以利用这个特点做一些性能优化，即避免临时对象的拷贝构造和析构，事实上，在c++98/03中，通过常量左值引用也经常用来做性能优化。上面的代码改成：\n\n　　const A& a = GetA();\n\n　　输出的结果和右值引用一样，因为常量左值引用是一个“万能”的引用类型，可以接受左值、右值、常量左值和常量右值。需要注意的是普通的左值引用不能接受右值，比如这样的写法是不对的：\n\n　　A& a = GetA();\n\n　　上面的代码会报一个编译错误，因为非常量左值引用只能接受左值。\n\n右值引用的第二个特点\n　　右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值。比如下面的例子：\n\n```\nint&& var1 = 1; \n```\n\n　　var1类型为右值引用，但var1本身是左值，因为具名变量都是左值。\n\n　　关于右值引用一个有意思的问题是：T&&是什么，一定是右值吗？让我们来看看下面的例子：\n\n```\ntemplate<typename T>\nvoid f(T&& t){}\nf(10); //t是右值\nint x = 10;\nf(x); //t是左值\n```\n\n　　从上面的代码中可以看到，T&&表示的值类型不确定，可能是左值又可能是右值，这一点看起来有点奇怪，这就是右值引用的一个特点。\n\n右值引用的第三个特点\n　　T&& t在发生自动类型推断的时候，它是未定的引用类型（universal references），如果被一个左值初始化，它就是一个左值；如果它被一个右值初始化，它就是一个右值，它是左值还是右值取决于它的初始化。\n\n我们再回过头看上面的代码，对于函数template<typename T>void f(T&& t)，当参数为右值10的时候，根据universal references的特点，t被一个右值初始化，那么t就是右值；当参数为左值x时，t被一个左值引用初始化，那么t就是一个左值。需要注意的是，仅仅是当发生自动类型推导（如函数模板的类型自动推导，或auto关键字）的时候，T&&才是universal references。再看看下面的例子：\n\n```\ntemplate<typename T>\nvoid f(T&& param); \n\ntemplate<typename T>\nclass Test {\n    Test(Test&& rhs); \n};\n```\n　　上面的例子中，param是universal reference，rhs是Test&&右值引用，因为模版函数f发生了类型推断，而Test&&并没有发生类型推导，因为Test&&是确定的类型了。\n\n　　正是因为右值引用可能是左值也可能是右值，依赖于初始化，并不是一下子就确定的特点，我们可以利用这一点做很多文章，比如后面要介绍的移动语义和完美转发。\n\n　　这里再提一下引用折叠，正是因为引入了右值引用，所以可能存在左值引用与右值引用和右值引用与右值引用的折叠，C++11确定了引用折叠的规则，规则是这样的：\n\n*   所有的右值引用叠加到右值引用上仍然还是一个右值引用；\n*   所有的其他引用类型之间的叠加都将变成左值引用。\n\n### 第3行代码的故事\n```\nT(T&& a) : m_val(val){ a.m_val=nullptr; }\n```\n　　这行代码实际上来自于一个类的构造函数，构造函数的一个参数是一个右值引用，为什么将右值引用作为构造函数的参数呢？在解答这个问题之前我们先看一个例子。如代码清单1-2所示。\n\n代码清单1-2\n\n```\nclass A\n{\npublic:\n    A():m_ptr(new int(0)){cout << \"construct\" << endl;}\n    A(const A& a):m_ptr(new int(*a.m_ptr)) //深拷贝的拷贝构造函数\n    {\n        cout << \"copy construct\" << endl;\n    }\n    ~A(){ delete m_ptr;}\nprivate:\n    int* m_ptr;\n};\nint main() {\n    A a = GetA();\n    return 0;\n}\n    输出：\nconstruct\ncopy construct\ncopy construct\n```\n　　这个例子很简单，一个带有堆内存的类，必须提供一个深拷贝拷贝构造函数，因为默认的拷贝构造函数是浅拷贝，会发生“指针悬挂”的问题。如果不提供深拷贝的拷贝构造函数，上面的测试代码将会发生错误（编译选项-fno-elide-constructors），内部的m_ptr将会被删除两次，一次是临时右值析构的时候删除一次，第二次外面构造的a对象释放时删除一次，而这两个对象的m_ptr是同一个指针，这就是所谓的指针悬挂问题。提供深拷贝的拷贝构造函数虽然可以保证正确，但是在有些时候会造成额外的性能损耗，因为有时候这种深拷贝是不必要的。比如下面的代码：\n\n\n\n　　上面代码中的GetA函数会返回临时变量，然后通过这个临时变量拷贝构造了一个新的对象a，临时变量在拷贝构造完成之后就销毁了，如果堆内存很大的话，那么，这个拷贝构造的代价会很大，带来了额外的性能损失。每次都会产生临时变量并造成额外的性能损失，有没有办法避免临时变量造成的性能损失呢？答案是肯定的，C++11已经有了解决方法，看看下面的代码。如代码清单1-3所示。\n\n代码清单1-3\n\n```\nclass A\n{\npublic:\n    A() :m_ptr(new int(0)){}\n    A(const A& a):m_ptr(new int(*a.m_ptr)) //深拷贝的拷贝构造函数\n    {\n        cout << \"copy construct\" << endl;\n    }\n    A(A&& a) :m_ptr(a.m_ptr)\n    {\n        a.m_ptr = nullptr;\n        cout << \"move construct\" << endl;\n    }\n    ~A(){ delete m_ptr;}\nprivate:\n    int* m_ptr;\n};\nint main(){\n    A a = Get(false); \n} \n输出：\nconstruct\nmove construct\nmove construct\n```\n　　代码清单1-3和1-2相比只多了一个构造函数，输出结果表明，并没有调用拷贝构造函数，只调用了move construct函数，让我们来看看这个move construct函数：\n\n```\nA(A&& a) :m_ptr(a.m_ptr)\n{\n    a.m_ptr = nullptr;\n    cout << \"move construct\" << endl;\n}\n```\n\n　　这个构造函数并没有做深拷贝，仅仅是将指针的所有者转移到了另外一个对象，同时，将参数对象a的指针置为空，这里仅仅是做了浅拷贝，因此，这个构造函数避免了临时变量的深拷贝问题。\n\n　　上面这个函数其实就是移动构造函数，他的参数是一个右值引用类型，这里的A&&表示右值，为什么？前面已经提到，这里没有发生类型推断，是确定的右值引用类型。为什么会匹配到这个构造函数？因为这个构造函数只能接受右值参数，而函数返回值是右值，所以就会匹配到这个构造函数。这里的A&&可以看作是临时值的标识，对于临时值我们仅仅需要做浅拷贝即可，无需再做深拷贝，从而解决了前面提到的临时变量拷贝构造产生的性能损失的问题。这就是所谓的移动语义，右值引用的一个重要作用是用来支持移动语义的。\n\n　　需要注意的一个细节是，我们提供移动构造函数的同时也会提供一个拷贝构造函数，以防止移动不成功的时候还能拷贝构造，使我们的代码更安全。\n\n　　我们知道移动语义是通过右值引用来匹配临时值的，那么，普通的左值是否也能借助移动语义来优化性能呢，那该怎么做呢？事实上C++11为了解决这个问题，提供了std::move方法来将左值转换为右值，从而方便应用移动语义。move是将对象资源的所有权从一个对象转移到另一个对象，只是转移，没有内存的拷贝，这就是所谓的move语义。如图1-1所示是深拷贝和move的区别。\n\n\n\n图1-1 深拷贝和move的区别\n\n　　再看看下面的例子：\n\n```\n{\n    std::list< std::string> tokens;\n    //省略初始化...\n    std::list< std::string> t = tokens; //这里存在拷贝 \n}\nstd::list< std::string> tokens;\nstd::list< std::string> t = std::move(tokens);  //这里没有拷贝 \n```\n　　如果不用std::move，拷贝的代价很大，性能较低。使用move几乎没有任何代价，只是转换了资源的所有权。他实际上将左值变成右值引用，然后应用移动语义，调用移动构造函数，就避免了拷贝，提高了程序性能。如果一个对象内部有较大的对内存或者动态数组时，很有必要写move语义的拷贝构造函数和赋值函数，避免无谓的深拷贝，以提高性能。事实上，C++11中所有的容器都实现了移动语义，方便我们做性能优化。\n\n　　这里也要注意对move语义的误解，move实际上它并不能移动任何东西，它唯一的功能是将一个左值强制转换为一个右值引用。如果是一些基本类型比如int和char[10]定长数组等类型，使用move的话仍然会发生拷贝（因为没有对应的移动构造函数）。所以，move对于含资源（堆内存或句柄）的对象来说更有意义。\n\n### 第4行代码故事\n```\ntemplate <typename T>void f(T&& val){ foo(std::forward<T>(val)); }\n```\n　　C++11之前调用模板函数时，存在一个比较头疼的问题，如何正确的传递参数。比如： \n\n```\ntemplate <typename T>\nvoid forwardValue(T& val)\n{\n    processValue(val); //右值参数会变成左值 \n}\ntemplate <typename T>\nvoid forwardValue(const T& val)\n{\n    processValue(val); //参数都变成常量左值引用了 \n}\n```\n都不能按照参数的本来的类型进行转发。\n\n　　C++11引入了完美转发：在函数模板中，完全依照模板的参数的类型（即保持参数的左值、右值特征），将参数传递给函数模板中调用的另外一个函数。C++11中的std::forward正是做这个事情的，他会按照参数的实际类型进行转发。看下面的例子：\n\n```\nvoid processValue(int& a){ cout << \"lvalue\" << endl; }\nvoid processValue(int&& a){ cout << \"rvalue\" << endl; }\ntemplate <typename T>\nvoid forwardValue(T&& val)\n{\n    processValue(std::forward<T>(val)); //照参数本来的类型进行转发。\n}\nvoid Testdelcl()\n{\n    int i = 0;\n    forwardValue(i); //传入左值 \n    forwardValue(0);//传入右值 \n}\n输出：\nlvaue \nrvalue\n```\n　　右值引用T&&是一个universal references，可以接受左值或者右值，正是这个特性让他适合作为一个参数的路由，然后再通过std::forward按照参数的实际类型去匹配对应的重载函数，最终实现完美转发。\n\n　　我们可以结合完美转发和移动语义来实现一个泛型的工厂函数，这个工厂函数可以创建所有类型的对象。具体实现如下：\n\n```\ntemplate<typename…  Args>\nT* Instance(Args&&… args)\n{\n    return new T(std::forward<Args >(args)…);\n}\n```\n　　这个工厂函数的参数是右值引用类型，内部使用std::forward按照参数的实际类型进行转发，如果参数的实际类型是右值，那么创建的时候会自动匹配移动构造，如果是左值则会匹配拷贝构造。\n\n## 总结\n　　通过4行代码我们知道了什么是右值和右值引用，以及右值引用的一些特点，利用这些特点我们才方便实现移动语义和完美转发。C++11正是通过引入右值引用来优化性能，具体来说是通过移动语义来避免无谓拷贝的问题，通过move语义来将临时生成的左值中的资源无代价的转移到另外一个对象中去，通过完美转发来解决不能按照参数实际类型来转发的问题（同时，完美转发获得的一个好处是可以实现移动语义）。\n\n*本文曾发表于《程序员》2015年1月刊。转载请注明出处。*\n\n*后记：*本文的内容主要来自于我在公司内部培训的一次课程，因为很多人对C++11右值引用搞不清或者理解得不深入，所以我觉得有必要拿出来分享一下，让更多的人看到，就整理了一下发到程序员杂志了，我相信读者看完之后对右值引用会有全面深入的了解。\n\n \n\n一点梦想：尽自己一份力，让c++的世界变得更美好！","content":"<h2 id=\"概述\">概述<a href=\"posts/右值引用#概述\"></a></h2><p>　　右值引用的概念有些读者可能会感到陌生，其实他和C++98/03中的左值引用有些类似，例如，c++98/03中的左值引用是这样的：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int <span class=\"built_in\">i</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">int&amp; <span class=\"built_in\">j</span> = <span class=\"built_in\">i</span>;</span><br></pre></td></tr></table></div></figure>\n\n<p>　　这里的int&amp;是对左值进行绑定（但是int&amp;却不能绑定右值），相应的，对右值进行绑定的引用就是右值引用，他的语法是这样的A&amp;&amp;，通过双引号来表示绑定类型为A的右值。通过&amp;&amp;我们就可以很方便的绑定右值了，比如我们可以这样绑定一个右值：\n　　</p>\n<a id=\"more\"></a>　　\n\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int<span class=\"meta\">&amp;&amp; i = 0;</span></span><br></pre></td></tr></table></div></figure>\n\n<p>　　这里我们绑定了一个右值0，关于右值的概念会在后面介绍。右值引用是C++11中新增加的一个很重要的特性，他主是要用来解决C++98/03中遇到的两个问题，第一个问题就是临时对象非必要的昂贵的拷贝操作，第二个问题是在模板函数中如何按照参数的实际类型进行转发。通过引入右值引用，很好的解决了这两个问题，改进了程序性能，后面将会详细介绍右值引用是如何解决这两个问题的。</p>\n<p>　　和右值引用相关的概念比较多，比如：右值、纯右值、将亡值、universal references、引用折叠、移动语义、move语义和完美转发等等。很多都是新概念，对于刚学习C++11右值引用的初学者来说，可能会觉得右值引用过于复杂，概念之间的关系难以理清。</p>\n<p>右值引用实际上并没有那么复杂，其实是关于4行代码的故事，通过简单的4行代码我们就能清晰的理解右值引用相关的概念了。本文希望带领读者通过4行代码来理解右值引用相关的概念，理清他们之间的关系，并最终能透彻地掌握C++11的新特性–右值引用。</p>\n<h2 id=\"四行代码的故事\">四行代码的故事<a href=\"posts/右值引用#四行代码的故事\"></a></h2><h3 id=\"第1行代码的故事\">第1行代码的故事<a href=\"posts/右值引用#第1行代码的故事\"></a></h3><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">int i</span> = getVar();</span><br></pre></td></tr></table></div></figure>\n\n<p>　　上面的这行代码很简单，从getVar()函数获取一个整形值，然而，这行代码会产生几种类型的值呢？答案是会产生两种类型的值，一种是左值i，一种是函数getVar()返回的临时值，这个临时值在表达式结束后就销毁了，而左值i在表达式结束后仍然存在，这个临时值就是右值，具体来说是一个纯右值，右值是不具名的。区分左值和右值的一个简单办法是：看能不能对表达式取地址，如果能，则为左值，否则为右值。</p>\n<p>　　所有的具名变量或对象都是左值，而匿名变量则是右值，比如，简单的赋值语句：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">int i</span> = 0;</span><br></pre></td></tr></table></div></figure>\n\n<p>　　在这条语句中，i 是左值，0 是字面量，就是右值。在上面的代码中，i 可以被引用，0 就不可以了。具体来说上面的表达式中等号右边的0是纯右值（prvalue），在C++11中所有的值必属于左值、将亡值、纯右值三者之一。比如，非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和lambda表达式等都是纯右值。而将亡值是C++11新增的、与右值引用相关的表达式，比如，将要被移动的对象、T&amp;&amp;函数返回值、std::move返回值和转换为T&amp;&amp;的类型的转换函数的返回值等。关于将亡值我们会在后面介绍，先看下面的代码：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> j = <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span> f = []&#123;<span class=\"keyword\">return</span> <span class=\"number\">5</span>;&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p>　　上面的代码中5是一个原始字面量， []{return 5;}是一个lambda表达式，都是属于纯右值，他们的特点是在表达式结束之后就销毁了。</p>\n<p>　　通过地行代码我们对右值有了一个初步的认识，知道了什么是右值，接下来再来看看第二行代码。</p>\n<h3 id=\"第2行代码的故事\">第2行代码的故事<a href=\"posts/右值引用#第2行代码的故事\"></a></h3><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T<span class=\"meta\">&amp;&amp; k = getVar();</span></span><br></pre></td></tr></table></div></figure>\n\n<p>　　第二行代码和第一行代码很像，只是相比第一行代码多了“&amp;&amp;”，他就是右值引用，我们知道左值引用是对左值的引用，那么，对应的，对右值的引用就是右值引用，而且右值是匿名变量，我们也只能通过引用的方式来获取右值。虽然第二行代码和第一行代码看起来差别不大，但是实际上语义的差别很大，这里，getVar()产生的临时值不会像第一行代码那样，在表达式结束之后就销毁了，而是会被“续命”，他的生命周期将会通过右值引用得以延续，和变量k的声明周期一样长。</p>\n<p>右值引用的第一个特点<br>　　通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去。让我们通过一个简单的例子来看看右值的生命周期。如代码清单1-1所示。</p>\n<p>代码清单1-1 </p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> g_constructCount=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> g_copyConstructCount=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> g_destructCount=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    A()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"construct: \"</span>&lt;&lt;++g_constructCount&lt;&lt;<span class=\"built_in\">endl</span>;    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    A(<span class=\"keyword\">const</span> A&amp; a)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"copy construct: \"</span>&lt;&lt;++g_copyConstructCount &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~A()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"destruct: \"</span>&lt;&lt;++g_destructCount&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">A <span class=\"title\">GetA</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> A();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    A a = GetA();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>　　为了清楚的观察临时值，在编译时设置编译选项-fno-elide-constructors用来关闭返回值优化效果。</p>\n<p>　　输出结果：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">construc<span class=\"variable\">t:</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">copy</span> construc<span class=\"variable\">t:</span> <span class=\"number\">1</span></span><br><span class=\"line\">destruc<span class=\"variable\">t:</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">copy</span> construc<span class=\"variable\">t:</span> <span class=\"number\">2</span></span><br><span class=\"line\">destruc<span class=\"variable\">t:</span> <span class=\"number\">2</span></span><br><span class=\"line\">destruc<span class=\"variable\">t:</span> <span class=\"number\">3</span></span><br></pre></td></tr></table></div></figure>\n\n<p>　　从上面的例子中可以看到，在没有返回值优化的情况下，拷贝构造函数调用了两次，一次是GetA()函数内部创建的对象返回出来构造一个临时对象产生的，另一次是在main函数中构造a对象产生的。第二次的destruct是因为临时对象在构造a对象之后就销毁了。如果开启返回值优化的话，输出结果将是：</p>\n<p>construct: 1</p>\n<p>destruct: 1</p>\n<p>　　可以看到返回值优化将会把临时对象优化掉，但这不是c++标准，是各编译器的优化规则。我们在回到之前提到的可以通过右值引用来延长临时右值的生命周期，如果上面的代码中我们通过右值引用来绑定函数返回值的话，结果又会是什么样的呢？在编译时设置编译选项-fno-elide-constructors。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> main() &#123;</span><br><span class=\"line\">    A&amp;&amp; a = GetA();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">输出结果：</span><br><span class=\"line\"><span class=\"string\">construct:</span> <span class=\"number\">1</span></span><br><span class=\"line\">copy <span class=\"string\">construct:</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"string\">destruct:</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"string\">destruct:</span> <span class=\"number\">2</span></span><br></pre></td></tr></table></div></figure>\n\n<p>　　通过右值引用，比之前少了一次拷贝构造和一次析构，原因在于右值引用绑定了右值，让临时右值的生命周期延长了。我们可以利用这个特点做一些性能优化，即避免临时对象的拷贝构造和析构，事实上，在c++98/03中，通过常量左值引用也经常用来做性能优化。上面的代码改成：</p>\n<p>　　const A&amp; a = GetA();</p>\n<p>　　输出的结果和右值引用一样，因为常量左值引用是一个“万能”的引用类型，可以接受左值、右值、常量左值和常量右值。需要注意的是普通的左值引用不能接受右值，比如这样的写法是不对的：</p>\n<p>　　A&amp; a = GetA();</p>\n<p>　　上面的代码会报一个编译错误，因为非常量左值引用只能接受左值。</p>\n<p>右值引用的第二个特点<br>　　右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值。比如下面的例子：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int<span class=\"meta\">&amp;&amp; var1 = 1;</span></span><br></pre></td></tr></table></div></figure>\n\n<p>　　var1类型为右值引用，但var1本身是左值，因为具名变量都是左值。</p>\n<p>　　关于右值引用一个有意思的问题是：T&amp;&amp;是什么，一定是右值吗？让我们来看看下面的例子：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(T&amp;&amp; t)</span></span>&#123;&#125;</span><br><span class=\"line\">f(<span class=\"number\">10</span>); <span class=\"comment\">//t是右值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\">f(x); <span class=\"comment\">//t是左值</span></span><br></pre></td></tr></table></div></figure>\n\n<p>　　从上面的代码中可以看到，T&amp;&amp;表示的值类型不确定，可能是左值又可能是右值，这一点看起来有点奇怪，这就是右值引用的一个特点。</p>\n<p>右值引用的第三个特点<br>　　T&amp;&amp; t在发生自动类型推断的时候，它是未定的引用类型（universal references），如果被一个左值初始化，它就是一个左值；如果它被一个右值初始化，它就是一个右值，它是左值还是右值取决于它的初始化。</p>\n<p>我们再回过头看上面的代码，对于函数template<typename t=\"\">void f(T&amp;&amp; t)，当参数为右值10的时候，根据universal references的特点，t被一个右值初始化，那么t就是右值；当参数为左值x时，t被一个左值引用初始化，那么t就是一个左值。需要注意的是，仅仅是当发生自动类型推导（如函数模板的类型自动推导，或auto关键字）的时候，T&amp;&amp;才是universal references。再看看下面的例子：</typename></p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(T&amp;&amp; param)</span></span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> &#123;</span></span><br><span class=\"line\">    Test(Test&amp;&amp; rhs); </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p>　　上面的例子中，param是universal reference，rhs是Test&amp;&amp;右值引用，因为模版函数f发生了类型推断，而Test&amp;&amp;并没有发生类型推导，因为Test&amp;&amp;是确定的类型了。</p>\n<p>　　正是因为右值引用可能是左值也可能是右值，依赖于初始化，并不是一下子就确定的特点，我们可以利用这一点做很多文章，比如后面要介绍的移动语义和完美转发。</p>\n<p>　　这里再提一下引用折叠，正是因为引入了右值引用，所以可能存在左值引用与右值引用和右值引用与右值引用的折叠，C++11确定了引用折叠的规则，规则是这样的：</p>\n<ul>\n<li>所有的右值引用叠加到右值引用上仍然还是一个右值引用；</li>\n<li>所有的其他引用类型之间的叠加都将变成左值引用。</li>\n</ul>\n<h3 id=\"第3行代码的故事\">第3行代码的故事<a href=\"posts/右值引用#第3行代码的故事\"></a></h3><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">T</span>(<span class=\"built_in\">T</span>&amp;&amp; a) <span class=\"symbol\">:</span> m_val(val)&#123; a.m_val=nullptr; &#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>　　这行代码实际上来自于一个类的构造函数，构造函数的一个参数是一个右值引用，为什么将右值引用作为构造函数的参数呢？在解答这个问题之前我们先看一个例子。如代码清单1-2所示。</p>\n<p>代码清单1-2</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    A():m_ptr(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">0</span>))&#123;<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"construct\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\">    A(<span class=\"keyword\">const</span> A&amp; a):m_ptr(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(*a.m_ptr)) <span class=\"comment\">//深拷贝的拷贝构造函数</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"copy construct\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~A()&#123; <span class=\"keyword\">delete</span> m_ptr;&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* m_ptr;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    A a = GetA();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    输出：</span><br><span class=\"line\">construct</span><br><span class=\"line\">copy construct</span><br><span class=\"line\">copy construct</span><br></pre></td></tr></table></div></figure>\n\n<p>　　这个例子很简单，一个带有堆内存的类，必须提供一个深拷贝拷贝构造函数，因为默认的拷贝构造函数是浅拷贝，会发生“指针悬挂”的问题。如果不提供深拷贝的拷贝构造函数，上面的测试代码将会发生错误（编译选项-fno-elide-constructors），内部的m_ptr将会被删除两次，一次是临时右值析构的时候删除一次，第二次外面构造的a对象释放时删除一次，而这两个对象的m_ptr是同一个指针，这就是所谓的指针悬挂问题。提供深拷贝的拷贝构造函数虽然可以保证正确，但是在有些时候会造成额外的性能损耗，因为有时候这种深拷贝是不必要的。比如下面的代码：</p>\n<p>　　上面代码中的GetA函数会返回临时变量，然后通过这个临时变量拷贝构造了一个新的对象a，临时变量在拷贝构造完成之后就销毁了，如果堆内存很大的话，那么，这个拷贝构造的代价会很大，带来了额外的性能损失。每次都会产生临时变量并造成额外的性能损失，有没有办法避免临时变量造成的性能损失呢？答案是肯定的，C++11已经有了解决方法，看看下面的代码。如代码清单1-3所示。</p>\n<p>代码清单1-3</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    A() :m_ptr(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">0</span>))&#123;&#125;</span><br><span class=\"line\">    A(<span class=\"keyword\">const</span> A&amp; a):m_ptr(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(*a.m_ptr)) <span class=\"comment\">//深拷贝的拷贝构造函数</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"copy construct\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    A(A&amp;&amp; a) :m_ptr(a.m_ptr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        a.m_ptr = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"move construct\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~A()&#123; <span class=\"keyword\">delete</span> m_ptr;&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* m_ptr;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    A a = Get(<span class=\"literal\">false</span>); </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">输出：</span><br><span class=\"line\">construct</span><br><span class=\"line\">move construct</span><br><span class=\"line\">move construct</span><br></pre></td></tr></table></div></figure>\n\n<p>　　代码清单1-3和1-2相比只多了一个构造函数，输出结果表明，并没有调用拷贝构造函数，只调用了move construct函数，让我们来看看这个move construct函数：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A(A&amp;&amp; a) :m_ptr(a.m_ptr)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    a.m_ptr = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"move construct\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>　　这个构造函数并没有做深拷贝，仅仅是将指针的所有者转移到了另外一个对象，同时，将参数对象a的指针置为空，这里仅仅是做了浅拷贝，因此，这个构造函数避免了临时变量的深拷贝问题。</p>\n<p>　　上面这个函数其实就是移动构造函数，他的参数是一个右值引用类型，这里的A&amp;&amp;表示右值，为什么？前面已经提到，这里没有发生类型推断，是确定的右值引用类型。为什么会匹配到这个构造函数？因为这个构造函数只能接受右值参数，而函数返回值是右值，所以就会匹配到这个构造函数。这里的A&amp;&amp;可以看作是临时值的标识，对于临时值我们仅仅需要做浅拷贝即可，无需再做深拷贝，从而解决了前面提到的临时变量拷贝构造产生的性能损失的问题。这就是所谓的移动语义，右值引用的一个重要作用是用来支持移动语义的。</p>\n<p>　　需要注意的一个细节是，我们提供移动构造函数的同时也会提供一个拷贝构造函数，以防止移动不成功的时候还能拷贝构造，使我们的代码更安全。</p>\n<p>　　我们知道移动语义是通过右值引用来匹配临时值的，那么，普通的左值是否也能借助移动语义来优化性能呢，那该怎么做呢？事实上C++11为了解决这个问题，提供了std::move方法来将左值转换为右值，从而方便应用移动语义。move是将对象资源的所有权从一个对象转移到另一个对象，只是转移，没有内存的拷贝，这就是所谓的move语义。如图1-1所示是深拷贝和move的区别。</p>\n<p>图1-1 深拷贝和move的区别</p>\n<p>　　再看看下面的例子：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">list</span>&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt; tokens;</span><br><span class=\"line\">    <span class=\"comment\">//省略初始化...</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">list</span>&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt; t = tokens; <span class=\"comment\">//这里存在拷贝 </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">list</span>&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt; tokens;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">list</span>&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt; t = <span class=\"built_in\">std</span>::move(tokens);  <span class=\"comment\">//这里没有拷贝</span></span><br></pre></td></tr></table></div></figure>\n\n<p>　　如果不用std::move，拷贝的代价很大，性能较低。使用move几乎没有任何代价，只是转换了资源的所有权。他实际上将左值变成右值引用，然后应用移动语义，调用移动构造函数，就避免了拷贝，提高了程序性能。如果一个对象内部有较大的对内存或者动态数组时，很有必要写move语义的拷贝构造函数和赋值函数，避免无谓的深拷贝，以提高性能。事实上，C++11中所有的容器都实现了移动语义，方便我们做性能优化。</p>\n<p>　　这里也要注意对move语义的误解，move实际上它并不能移动任何东西，它唯一的功能是将一个左值强制转换为一个右值引用。如果是一些基本类型比如int和char[10]定长数组等类型，使用move的话仍然会发生拷贝（因为没有对应的移动构造函数）。所以，move对于含资源（堆内存或句柄）的对象来说更有意义。</p>\n<h3 id=\"第4行代码故事\">第4行代码故事<a href=\"posts/右值引用#第4行代码故事\"></a></h3><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(T&amp;&amp; val)</span></span>&#123; foo(<span class=\"built_in\">std</span>::forward&lt;T&gt;(val)); &#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>　　C++11之前调用模板函数时，存在一个比较头疼的问题，如何正确的传递参数。比如： </p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">forwardValue</span><span class=\"params\">(T&amp; val)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    processValue(val); <span class=\"comment\">//右值参数会变成左值 </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">forwardValue</span><span class=\"params\">(<span class=\"keyword\">const</span> T&amp; val)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    processValue(val); <span class=\"comment\">//参数都变成常量左值引用了 </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>都不能按照参数的本来的类型进行转发。</p>\n<p>　　C++11引入了完美转发：在函数模板中，完全依照模板的参数的类型（即保持参数的左值、右值特征），将参数传递给函数模板中调用的另外一个函数。C++11中的std::forward正是做这个事情的，他会按照参数的实际类型进行转发。看下面的例子：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">processValue</span><span class=\"params\">(<span class=\"keyword\">int</span>&amp; a)</span></span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"lvalue\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">processValue</span><span class=\"params\">(<span class=\"keyword\">int</span>&amp;&amp; a)</span></span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"rvalue\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">forwardValue</span><span class=\"params\">(T&amp;&amp; val)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    processValue(<span class=\"built_in\">std</span>::forward&lt;T&gt;(val)); <span class=\"comment\">//照参数本来的类型进行转发。</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Testdelcl</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    forwardValue(i); <span class=\"comment\">//传入左值 </span></span><br><span class=\"line\">    forwardValue(<span class=\"number\">0</span>);<span class=\"comment\">//传入右值 </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">输出：</span><br><span class=\"line\">lvaue </span><br><span class=\"line\">rvalue</span><br></pre></td></tr></table></div></figure>\n\n<p>　　右值引用T&amp;&amp;是一个universal references，可以接受左值或者右值，正是这个特性让他适合作为一个参数的路由，然后再通过std::forward按照参数的实际类型去匹配对应的重载函数，最终实现完美转发。</p>\n<p>　　我们可以结合完美转发和移动语义来实现一个泛型的工厂函数，这个工厂函数可以创建所有类型的对象。具体实现如下：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span>…  Args&gt;</span><br><span class=\"line\"><span class=\"function\">T* <span class=\"title\">Instance</span><span class=\"params\">(Args&amp;&amp;… args)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> T(<span class=\"built_in\">std</span>::forward&lt;Args &gt;(args)…);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>　　这个工厂函数的参数是右值引用类型，内部使用std::forward按照参数的实际类型进行转发，如果参数的实际类型是右值，那么创建的时候会自动匹配移动构造，如果是左值则会匹配拷贝构造。</p>\n<h2 id=\"总结\">总结<a href=\"posts/右值引用#总结\"></a></h2><p>　　通过4行代码我们知道了什么是右值和右值引用，以及右值引用的一些特点，利用这些特点我们才方便实现移动语义和完美转发。C++11正是通过引入右值引用来优化性能，具体来说是通过移动语义来避免无谓拷贝的问题，通过move语义来将临时生成的左值中的资源无代价的转移到另外一个对象中去，通过完美转发来解决不能按照参数实际类型来转发的问题（同时，完美转发获得的一个好处是可以实现移动语义）。</p>\n<p><em>本文曾发表于《程序员》2015年1月刊。转载请注明出处。</em></p>\n<p><em>后记：</em>本文的内容主要来自于我在公司内部培训的一次课程，因为很多人对C++11右值引用搞不清或者理解得不深入，所以我觉得有必要拿出来分享一下，让更多的人看到，就整理了一下发到程序员杂志了，我相信读者看完之后对右值引用会有全面深入的了解。</p>\n<p>一点梦想：尽自己一份力，让c++的世界变得更美好！</p>\n","slug":"右值引用","updated":"2019-07-14T01:22:55.309Z","comments":true,"link":"posts/右值引用","permalink":"https://shuntan.github.io/posts/右值引用/","excerpt":"概述 右值引用的概念有些读者可能会感到陌生，其实他和C++98/03中的左值引用有些类似，例如，c++98/03中的左值引用是这样的： 12int i = 0;int&amp; j = i; 这里的int&amp;是对左值进行绑定（但是int&amp;却不能绑定右值），相应的，对右值进行绑定的引用就是右值引用，他的语法是这样的A&amp;&amp;，通过双引号来表示绑定类型为A的右值。通过&amp;&amp;我们就可以很方便的绑定右值了，比如我们可以这样绑定一个右值：","categories":[{"name":"C++","slug":"C","permalink":"https://shuntan.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://shuntan.github.io/tags/C/"}]},{"title":"squid介绍及其简单配置","date":"2019-05-15T07:15:30.000Z","path":"posts/squid/","text":"squid的概念squid是一种用来缓存Internet数据的软件。接受来自人们需要下载的目标（object）的请求并适当的处理这些请求。也就是说，如果一个人想下载一web界面，他请求squid为他取得这个页面。squid随之连接到远程服务器并向这个页面发出请求。然后，squid显式地聚集数据到客户端机器，而且同时复制一份。当下一次有人需要同一页面时， squid可以简单的从磁盘中读到它，那样数据会立即传输到客户机上。 下载地址squid-cache 官网 http://www.squid-cache.org squid介绍及其简单配置 https://www.cnblogs.com/cherishry/p/5706736.html CentOS 7安装squid代理服务器 https://blog.csdn.net/ithomer/article/details/78136993 squid代理的作用 通过缓存的方式为用户提供Web访问加速 对用户的Web访问进行过滤控制 工作流程当代理服务器中有客户端需要的数据时： a.客户端向代理服务器发送数据请求； b.代理服务器检查自己的数据缓存； c.代理服务器在缓存中找到了用户想要的数据，取出数据； d.代理服务器将从缓存中取得的数据返回给客户端。 当代理服务器中没有客户端需要的数据时了： 1.客户端向代理服务器发送数据请求； 2.代理服务器检查自己的数据缓存； 3.代理服务器在缓存中没有找到用户想要的数据； 4.代理服务器向Internet 上的远端服务器发送数据请求； 5.远端服务器响应，返回相应的数据； 6.代理服务器取得远端服务器的数据，返回给客户端，并保留一份到自己的数据缓存中。 Squid代理服务器工作在TCP/IP应用层 Squid各种代理的定义正向代理标准的代理缓冲服务器一个标准的代理缓冲服务被用于缓存静态的网页到本地网络上的一台主机上（即代理服务器）。当被缓存的页面被第二次访问的时候，浏览器将直接从本地代理服务器那里获取请求数据而不再向原web站点请求数据。这样就节省了宝贵的网络带宽，而且提高了访问速度。但是，要想实现这种方式，必须在每一个内部主机的浏览器上明确指名代理服务器的IP地址和端口号。客户端上网时，每次都把请求发送给代理服务器处理,代理服务器根据请求确定是否连接到远程web服务器获取数据。如果在本地缓冲区有目标文件，则直接将文件传给用户即可。如果没有的话则先取回文件，先在本地保存一份缓冲，然后将文件发送给客户端浏览器。 透明代理缓冲服务器透明代理缓冲服务器和标准代理服务器的功能完全相同。但是，代理操作对客户端的浏览器是透明的（即不需指明代理服务器的IP和端口）。透明代理服务器阻断网络通信，并且过滤出访问外部的HTTP（80端口）流量。如果客户端的请求在本地有缓冲则将缓冲的数据直接发给用户，如果在本地没有缓冲则向远程web服务器发出请求，其余操作和标准的代理服务器完全相同。对于linux操作系统来说，透明代理使用Iptables或者Ipchains实现。因此不需要对浏览器作任何设置，所以，透明代理对于ISP（Internet服务器提供商）特别有用。 反向代理反向代理缓冲器反向代理是和前两种代理完全不同的一种代理服务。使用它可以降低原始WEB服务器的负载。反向代理服务器承担了对原始WEB服务器的静态页面的请求，防止原始服务器过载。它位于WEB服务器和Internet之间，处理所有对WEB服务器的请求，组织了WEB服务器和Internet的直接通信。如果互联网用户请求的页面在代理服务器上有缓冲的话，代理服务器直接将缓冲内容发送给用户。如果没有缓冲则先向WEB服务器发出请求，取回数据，本地缓存后再发给用户。这种方式通过降低了WEB服务器的请求数从而降低了WEB服务器的负载。 正向代理与反向代理的区别概念正向代理：对于原始服务器而言，就是客户端的代言人反向代理：对于客户端而言，就像是原始服务器 用途正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。反向代理还可以为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。另外，反向代理还可以启用高级URL策略和管理技术，从而使处于不同web服务器系统的web页面同时存在于同一个URL空间下。 安全性正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。 Squid主要组成部分服务名：squid主程序：/usr/sbin/squid配置目录：/etc/squid主配置文件：/etc/squid/squid.conf监听tcp端口号：3128默认访问日志文件：/var/log/squid/access.log squid常用配置选项/etc/squid/squid.conf 123456789101112131415http_port 3128 (还可以只监听一个IP http_port 192.168.0.1:3128)cache_mem 64MB #缓存占内存大小maximum_object_size 4096KB #最大缓存块reply_body_max_size 1024000 allow all #限定下载文件大小access_log /var/log/squid/access.log #访问日志存放的地方visible_hostname proxy.test.xom #可见的主机名cache_dir ufs /var/spool/squid 100 16 256 #ufs:缓存数据的存储格式#/var/spool/squid 缓存目录#100：缓存目录占磁盘空间大小（M）#16：缓存空间一级子目录个数#256：缓存空间二级子目录个数cache_mgr webmaster@test.com #定义管理员邮箱http_access deny all #访问控制 squid中的访问控制 使用访问控制特性，可以控制在访问时根据特定的时间间隔进行缓存、访问特定站点或一组站点等等。squid访问控制有两个要素：ACL元素和访问列表。访问列表可以允许或拒绝某些用户对此服务的访问。 ACL元素类型 src：源地址（即客户机IP地址） dst：目标地址（即服务器IP地址） srcdomain：源名称（即客户机名称） dstdomain：目标名称（即服务器名称） time：一天中的时刻和一周内的一天 url_regex：URL规则表达式匹配 urlpath_regex：URL-path规则表达式匹配，略去协议和主机名 proxy_auth：通过外部程序进行用户验证 maxconn：单一IP的最大连接数 ACL格式为了使用控制功能，必须先设置ACL规则并应用。ACL声明的格式如下：注： acl_element_name 可以是任一个在ACL中定义的名称 任何两个ACL元素不能用相同的名字 每个ACL由列表值组成。当进行匹配检测的时候，多个值由逻辑或运算连接；换言之，即任一ACL元素的值被匹配，则这个ACL元素即被匹配。 并不是所有ACL元素都能使用访问列表中的全部类型 不同的ACL元素写在不同行中，squid将把他们组合在一个列表中 访问条目我们可以使用许多不同的访问条目。下面是我们常用的几个： http_access:允许HTTP访问 no_cache:定义对缓存请求的响应。访问列表的规则由一些类似’allow’或‘deny’的关键字构成，用以允许或拒绝向特定或一组ACL元素提供服务。 一个访问列表可以由多条规则组成 如果没有任何规则与访问请求匹配，默认动作将与列表中最后一条规则对应。 一个访问条目中所有元素将用逻辑与运算连接http_access Action 声明1 AND 声明2 AND 声明 OR.http_access Action 声明3多个http_accesss声明间用或运算连接，但每个访问条目的元素间用与运算连接。 列表中的规则总是遵循由上而下的顺序 这些规则按照他们的排列顺序进行匹配检测，一旦检测到匹配的规则，匹配就立即结束。 Squid.conf配置文件详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#acl all src 0.0.0.0/0.0.0.0 and http_access allow all选项定义了一个访问控制列表。详细情况参见和Squid软件#携带的文档。这里的访问控制列表允许所有对代理服务的访问，因为这里该代理是加速web服务器。acl all src 0.0.0.0/0.0.0.0 #允许所有IP访问acl manager proto http #manager url协议为httpacl localhost src 127.0.0.1/255.255.255.255 #允午本机IPacl to_localhost dst 127.0.0.1 #允午目的地址为本机IPacl Safe_ports port 80 # 允许安全更新的端口为80acl CONNECT method CONNECT #请求方法以CONNECThttp_access allow all #允许所有人使用该代理.因为这里是代理加速web服务器http_reply_access allow all #允许所有客户端使用该代理acl OverConnLimit maxconn 16 #限制每个IP最大允许16个连接，防止攻击http_access deny OverConnLimiticp_access deny all #禁止从邻居服务器缓冲内发送和接收ICP请求.miss_access allow all #允许直接更新请求ident_lookup_access deny all #禁止lookup检查DNShttp_port 8080 transparent #指定Squid监听浏览器客户请求的端口号。hierarchy_stoplist cgi-bin ? #用来强制某些特定的对象不被缓存，主要是处于安全的目的。acl QUERY urlpath_regex cgi-bin \\?cache deny QUERYcache_mem 1 GB #这是一个优化选项，增加该内存值有利于缓存。应该注意的是： #一般来说如果系统有内存，设置该值为(n/)3M。现在是3G 所以这里1Gfqdncache_size 1024 #FQDN 高速缓存大小maximum_object_size_in_memory 2 MB #允许最大的文件载入内存memory_replacement_policy heap LFUDA #动态使用最小的，移出内存cachecache_replacement_policy heap LFUDA #动态使用最小的，移出硬盘cachecache_dir ufs /home/cache 5000 32 512 #高速缓存目录 ufs 类型 使用的缓冲值最大允午1000MB空间，#32个一级目录，512个二级目录max_open_disk_fds 0 #允许最大打开文件数量,0 无限制minimum_object_size 1 KB #允午最小文件请求体大小maximum_object_size 20 MB #允午最大文件请求体大小cache_swap_low 90 #最小允许使用swap 90%cache_swap_high 95 #最多允许使用swap 95%ipcache_size 2048 # IP 地址高速缓存大小 2Mipcache_low 90 #最小允许ipcache使用swap 90%ipcache_high 95 #最大允许ipcache使用swap 90%access_log /var/log/squid/access.log squid #定义日志存放记录cache_log /var/log/squid/cache.log squidcache_store_log none #禁止store日志emulate_httpd_log on #将使Squid仿照Web服务器的格式创建访问记录。如果希望使用 #Web访问记录分析程序，就需要设置这个参数。refresh_pattern . 0 20% 4320 override-expire override-lastmod reload-into-ims ignore-reload #更新cache规则acl buggy_server url_regex ^http://.... http:// #只允许http的请求broken_posts allow buggy_serveracl apache rep_header Server ^Apache #允许apache的编码broken_vary_encoding allow apacherequest_entities off #禁止非http的标分准请求，防止攻击header_access header allow all #允许所有的http报头relaxed_header_parser on #不严格分析http报头.client_lifetime 120 minute #最大客户连接时间 120分钟cache_mgr sky@test.com #指定当缓冲出现问题时向缓冲管理者发送告警信息的地址信息。cache_effective_user squid #这里以用户squid的身份Squid服务器cache_effective_group squidicp_port 0 #指定Squid从邻居服务器缓冲内发送和接收ICP请求的端口号。 #这里设置为0是因为这里配置Squid为内部Web服务器的加速器， #所以不需要使用邻居服务器的缓冲。0是禁用# cache_peer 设置允许更新缓存的主机，因是本机所以127.0.0.1cache_peer 127.0.0.1 parent 80 0 no-query default multicast-responder no-netdb-exchangecache_peer_domain 127.0.0.1 hostname_aliases 127.0.0.1error_directory /usr/share/squid/errors/Simplify_Chinese #定义错误路径always_direct allow all # cache丢失或不存在是允许所有请求直接转发到原始服务器ignore_unknown_nameservers on #开反DNS查询，当域名地址不相同时候，禁止访问coredump_dir /var/log/squid #定义dump的目录max_filedesc 2048 #最大打开的文件描述half_closed_clients off #使Squid在当read不再返回数据时立即关闭客户端的连接。 #有时read不再返回数据是由于某些客户关闭TCP的发送数据 #而仍然保持接收数据。而Squid分辨不出TCP半关闭和完全关闭。buffered_logs on #若打开选项“buffered_logs”可以稍稍提高加速某些对日志文件的写入，该选项主要是实现优化特性。#防止天涯盗链，转嫁给百度acl tianya referer_regex -i tianyahttp_access deny tianyadeny_info tianya#阻止baidu蜘蛛acl baidu req_header User-Agent Baiduspiderhttp_access deny baidu#限制同一IP客户端的最大连接数acl OverConnLimit maxconn 128http_access deny OverConnLimit#防止被人利用为HTTP代理，设置允许访问的IP地址acl myip dst 222.18.63.37http_access deny !myip#允许本地管理acl Manager proto cache_objectacl Localhost src 127.0.0.1 222.18.63.37http_access allow Manager Localhostcachemgr_passwd 53034338 allhttp_access deny Manager#仅仅允许80端口的代理acl all src 0.0.0.0/0.0.0.0acl Safe_ports port 80 # httphttp_access deny !Safe_portshttp_access allow all#Squid信息设置visible_hostname happy.swjtu.edu.cncache_mgr ooopic2008@qq.com#基本设置cache_effective_user squidcache_effective_group squidtcp_recv_bufsize 65535 bytes#2.6的反向代理加速配置cache_peer 127.0.0.1 parent 80 0 no-query originserver#错误文档error_directory /usr/local/squid/share/errors/Simplify_Chinese#单台使用，不使用该功能icp_port 0hierarchy_stoplist cgi-bin ?acl QUERY urlpath_regex cgi-bin \\? .php .cgi .avi .wmv .rm .ram .mpg .mpeg .zip .execache deny QUERYacl apache rep_header Server ^Apachebroken_vary_encoding allow apacherefresh_pattern ^ftp: 1440 20% 10080refresh_pattern ^gopher: 1440 0% 1440refresh_pattern . 0 20% 4320cache_store_log nonepid_filename /usr/local/squid/var/logs/squid.pidemulate_httpd_log on Squid常用命令 初始化在squid.conf里配置的cache目录squid -z如果有错误提示，请检查cache目录的权限，可以更改目录权限chown -R squid:squid /cache目录 对squid.conf排错，即验证squid.conf的语法和配置squid -k parse如果在squid.conf中有语法或配置错误，这里会返回提示，若无返回，尝试启动squid 前台启动squid，并输出启动过程/usr/local/squid/sbin/squid -N -d1如果有ready to server reques相关信息，说明squid启动成功然后ctrl+c ,停止squid,并以后台运行的方式启动它 启动squid在后台运行squid -s可以使用ps -ax | grep squid 来查看squid进程是否存在 停止squidsquid -k shutdown 重新引导修改过的squid.confsquid -k reconfigure -f /XXX/squid.conf当squid进行配置更改后，可以使用该命令进行squid配置重载 把squid添加到系统启动项vim /etc/rc.local/usr/local/squid/sbin/squid -s 修改cache缓存目录的权限chown -R squid.squid /cache目录cache缓存目录根据自己的配置更改，squid用户和组是squid，squid 修改squid日志目录的权限chown -R squid.squid 定义的日志文件所在目录这一步并不是适合每一个使用squid的用户，意为让squid有权限在该目录里进行写操作 查看你的日志文档more /usr/local/squid/var/logs/access.log | grep TCP_MEM_HIT该指令可以看到在squid运行过程中，有那些文件被squid缓存到内存中，并返回给访问用户。more /usr/local/squid/var/logs/access.log | grep TCP_HIT该指令可以看到在squid运行过程中，有那些文件被squid缓存到cache目录中，并返回给访问用户。more /usr/local/squid/var/logs/access.log | grep TCP_MISS该指令可以看到在squid运行过程中，有那些文件没有被squid缓存，而是从原始服务器获取并返回给访问用户。 Squid命中率分析12/usr/local/squid/bin/squidclient -p 80 mgr:info/usr/local/squid/bin/squidclient -p 80 mgr:5min 可以看到详细的性能情况,其中PORT是你的proxy的端口，5min可以是60min取得squid运行状态信息： 1squidclient -p 80 mgr:info 取得squid内存使用情况： 1squidclient -p 80 mgr:mem 取得squid已经缓存的列表： 1squidclient -p 80 mgr:bjects. use it carefully,it may crash 取得squid的磁盘使用情况： 1squidclient -p 80 mgr:diskd 强制更新某个url： 1squidclient -p 80 -m PURGE http://www.xxx.com/xxx.php 更多的请查看：squidclient-h 或者 squidclient -p 80 mgr:查命中率： 1squidclient -h IP(具体侦听IP) -p 80(具体侦听端口) mgr:info 定期清理swap.state内无效数据123/path/to/squid/sbin/squid -k rotate -f /path/to/squid/conf_filevi /etc/crontab0 0 * * * root /usr/local/sbin/squid -k rotate -f /usr/local/etc/squid/squid1.conf 当squid应用运行了一段时间之后，cache_dir对应的swap.state文件就会变得越来越大，里面的无效接口数据越来越多，这可能影响squid的响应时间，因此需要使用squid清理swap.state里面的无效数据，减少swap.state的大小。","raw":"---\ntitle: squid介绍及其简单配置\ncopyright: true\ntags:\n  - squid\n  - proxy\ncategories:\n  - Linux\nabbrlink: 55e3d16d\ndate: 2019-05-15 15:15:30\ntype:\nkeyword:\ntop:\ncomments:\npassword:\nthumbnail:\n---\n\n# squid的概念\n\nsquid是一种用来缓存Internet数据的软件。接受来自人们需要下载的目标（object）的请求并适当的处理这些请求。也就是说，如果一个人想下载一web界面，他请求squid为他取得这个页面。squid随之连接到远程服务器并向这个页面发出请求。然后，squid显式地聚集数据到客户端机器，而且同时复制一份。当下一次有人需要同一页面时， squid可以简单的从磁盘中读到它，那样数据会立即传输到客户机上。\n\n<!-- more -->\n\n# 下载地址\n\nsquid-cache 官网 http://www.squid-cache.org\n\nsquid介绍及其简单配置 https://www.cnblogs.com/cherishry/p/5706736.html\n\nCentOS 7安装squid代理服务器 https://blog.csdn.net/ithomer/article/details/78136993\n\n## squid代理的作用\n\n*   通过缓存的方式为用户提供Web访问加速\n*   对用户的Web访问进行过滤控制\n\n## 工作流程\n\n当代理服务器中有客户端需要的数据时：\n\na.客户端向代理服务器发送数据请求；\n\nb.代理服务器检查自己的数据缓存；\n\nc.代理服务器在缓存中找到了用户想要的数据，取出数据；\n\nd.代理服务器将从缓存中取得的数据返回给客户端。\n\n当代理服务器中没有客户端需要的数据时了：\n\n1.客户端向代理服务器发送数据请求；\n\n2.代理服务器检查自己的数据缓存；\n\n3.代理服务器在缓存中没有找到用户想要的数据；\n\n4.代理服务器向Internet 上的远端服务器发送数据请求；\n\n5.远端服务器响应，返回相应的数据；\n\n6.代理服务器取得远端服务器的数据，返回给客户端，并保留一份到自己的数据缓存中。\n\n![](https://images2015.cnblogs.com/blog/872781/201607/872781-20160726112850919-758636566.jpg)\n\nSquid代理服务器工作在TCP/IP应用层\n\n![](https://images2015.cnblogs.com/blog/872781/201607/872781-20160726112935653-887103660.jpg)\n\n## Squid各种代理的定义\n\n### 正向代理\n\n#### 标准的代理缓冲服务器\n\n一个标准的代理缓冲服务被用于缓存静态的网页到本地网络上的一台主机上（即代理服务器）。当被缓存的页面被第二次访问的时候，浏览器将直接从本地代理服务器那里获取请求数据而不再向原web站点请求数据。这样就节省了宝贵的网络带宽，而且提高了访问速度。但是，要想实现这种方式，必须在每一个内部主机的浏览器上明确指名代理服务器的IP地址和端口号。客户端上网时，每次都把请求发送给代理服务器处理,代理服务器根据请求确定是否连接到远程web服务器获取数据。如果在本地缓冲区有目标文件，则直接将文件传给用户即可。如果没有的话则先取回文件，先在本地保存一份缓冲，然后将文件发送给客户端浏览器。\n\n#### 透明代理缓冲服务器\n\n透明代理缓冲服务器和标准代理服务器的功能完全相同。但是，代理操作对客户端的浏览器是透明的（即不需指明代理服务器的IP和端口）。透明代理服务器阻断网络通信，并且过滤出访问外部的HTTP（80端口）流量。如果客户端的请求在本地有缓冲则将缓冲的数据直接发给用户，如果在本地没有缓冲则向远程web服务器发出请求，其余操作和标准的代理服务器完全相同。对于linux操作系统来说，透明代理使用Iptables或者Ipchains实现。因此不需要对浏览器作任何设置，所以，透明代理对于ISP（Internet服务器提供商）特别有用。\n\n### 反向代理\n\n#### 反向代理缓冲器\n\n反向代理是和前两种代理完全不同的一种代理服务。使用它可以降低原始WEB服务器的负载。反向代理服务器承担了对原始WEB服务器的静态页面的请求，防止原始服务器过载。它位于WEB服务器和Internet之间，处理所有对WEB服务器的请求，组织了WEB服务器和Internet的直接通信。如果互联网用户请求的页面在代理服务器上有缓冲的话，代理服务器直接将缓冲内容发送给用户。如果没有缓冲则先向WEB服务器发出请求，取回数据，本地缓存后再发给用户。这种方式通过降低了WEB服务器的请求数从而降低了WEB服务器的负载。\n\n### 正向代理与反向代理的区别\n\n### 概念\n\n正向代理：对于原始服务器而言，就是客户端的代言人\n反向代理：对于客户端而言，就像是原始服务器\n\n### 用途\n\n正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。\n反向代理还可以为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。另外，反向代理还可以启用高级URL策略和管理技术，从而使处于不同web服务器系统的web页面同时存在于同一个URL空间下。\n\n### 安全性\n\n正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。\n反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。\n\n## Squid主要组成部分\n\n服务名：`squid`\n主程序：`/usr/sbin/squid`\n配置目录：`/etc/squid`\n主配置文件：`/etc/squid/squid.conf`\n监听tcp端口号：`3128`\n默认访问日志文件：`/var/log/squid/access.log`\n\n## squid常用配置选项\n\n`/etc/squid/squid.conf`\n\n```\n\nhttp_port 3128  (还可以只监听一个IP http_port 192.168.0.1:3128)\ncache_mem 64MB  #缓存占内存大小\nmaximum_object_size 4096KB  #最大缓存块\nreply_body_max_size  1024000 allow all      #限定下载文件大小\naccess_log /var/log/squid/access.log    #访问日志存放的地方\nvisible_hostname    proxy.test.xom  #可见的主机名\ncache_dir ufs /var/spool/squid  100 16 256 \n#ufs:缓存数据的存储格式\n#/var/spool/squid    缓存目录\n#100：缓存目录占磁盘空间大小（M）\n#16：缓存空间一级子目录个数\n#256：缓存空间二级子目录个数\ncache_mgr webmaster@test.com    #定义管理员邮箱\nhttp_access deny all    #访问控制\n\n```\n## squid中的访问控制\n\n  使用访问控制特性，可以控制在访问时根据特定的时间间隔进行缓存、访问特定站点或一组站点等等。squid访问控制有两个要素：ACL元素和访问列表。访问列表可以允许或拒绝某些用户对此服务的访问。\n\n### ACL元素类型\n\n*   src：源地址（即客户机IP地址）\n*   dst：目标地址（即服务器IP地址）\n*   srcdomain：源名称（即客户机名称）\n*   dstdomain：目标名称（即服务器名称）\n*   time：一天中的时刻和一周内的一天\n*   url_regex：URL规则表达式匹配\n*   urlpath_regex：URL-path规则表达式匹配，略去协议和主机名\n*   proxy_auth：通过外部程序进行用户验证\n*   maxconn：单一IP的最大连接数\n\n### ACL格式\n\n\t为了使用控制功能，必须先设置ACL规则并应用。ACL声明的格式如下：\n\n注：\n\n*   acl_element_name 可以是任一个在ACL中定义的名称\n*   任何两个ACL元素不能用相同的名字\n*   每个ACL由列表值组成。当进行匹配检测的时候，多个值由逻辑或运算连接；换言之，即任一ACL元素的值被匹配，则这个ACL元素即被匹配。\n*   并不是所有ACL元素都能使用访问列表中的全部类型\n*   不同的ACL元素写在不同行中，squid将把他们组合在一个列表中\n\n### 访问条目\n\n我们可以使用许多不同的访问条目。下面是我们常用的几个：\n\n*   http_access:允许HTTP访问\n*   no_cache:定义对缓存请求的响应。\n    访问列表的规则由一些类似'allow'或‘deny’的关键字构成，用以允许或拒绝向特定或一组ACL元素提供服务。\n\n1.  一个访问列表可以由多条规则组成\n2.  如果没有任何规则与访问请求匹配，默认动作将与列表中最后一条规则对应。\n3.  一个访问条目中所有元素将用逻辑与运算连接\n    http_access Action 声明1 AND 声明2 AND 声明 OR.\n    http_access Action 声明3\n    多个http_accesss声明间用或运算连接，但每个访问条目的元素间用与运算连接。\n4.  列表中的规则总是遵循由上而下的顺序\n5.  这些规则按照他们的排列顺序进行匹配检测，一旦检测到匹配的规则，匹配就立即结束。\n\n## Squid.conf配置文件详解\n\n```\n#acl all src 0.0.0.0/0.0.0.0 and http_access allow all选项定义了一个访问控制列表。详细情况参见和Squid软件\n#携带的文档。这里的访问控制列表允许所有对代理服务的访问，因为这里该代理是加速web服务器。\nacl all src 0.0.0.0/0.0.0.0                 #允许所有IP访问\nacl manager proto http                 #manager url协议为http\nacl localhost src 127.0.0.1/255.255.255.255  #允午本机IP\nacl to_localhost dst 127.0.0.1                 #允午目的地址为本机IP\nacl Safe_ports port 80                # 允许安全更新的端口为80\nacl CONNECT method CONNECT        #请求方法以CONNECT\nhttp_access allow all                #允许所有人使用该代理.因为这里是代理加速web服务器\nhttp_reply_access allow all                #允许所有客户端使用该代理\n\nacl OverConnLimit maxconn 16        #限制每个IP最大允许16个连接，防止攻击\nhttp_access deny OverConnLimit\n\nicp_access deny all                        #禁止从邻居服务器缓冲内发送和接收ICP请求.\nmiss_access allow all                #允许直接更新请求\nident_lookup_access deny all                                #禁止lookup检查DNS\nhttp_port 8080 transparent                                #指定Squid监听浏览器客户请求的端口号。\n\nhierarchy_stoplist cgi-bin ?                #用来强制某些特定的对象不被缓存，主要是处于安全的目的。\nacl QUERY urlpath_regex cgi-bin \\?\ncache deny QUERY\n\ncache_mem 1 GB        #这是一个优化选项，增加该内存值有利于缓存。应该注意的是：\n                     #一般来说如果系统有内存，设置该值为(n/)3M。现在是3G 所以这里1G\nfqdncache_size 1024        #FQDN 高速缓存大小\nmaximum_object_size_in_memory 2 MB        #允许最大的文件载入内存\n\nmemory_replacement_policy heap LFUDA  #动态使用最小的，移出内存cache\ncache_replacement_policy heap LFUDA         #动态使用最小的，移出硬盘cache\n\ncache_dir ufs /home/cache 5000 32 512  #高速缓存目录 ufs 类型 使用的缓冲值最大允午1000MB空间，\n#32个一级目录，512个二级目录\n\nmax_open_disk_fds 0                                 #允许最大打开文件数量,0 无限制\nminimum_object_size 1 KB                         #允午最小文件请求体大小\nmaximum_object_size 20 MB                 #允午最大文件请求体大小\n\ncache_swap_low 90                            #最小允许使用swap 90%\ncache_swap_high 95                            #最多允许使用swap 95%\n\nipcache_size 2048                                # IP 地址高速缓存大小 2M\nipcache_low 90                                #最小允许ipcache使用swap 90%\nipcache_high 95                                  #最大允许ipcache使用swap 90%\n\n\naccess_log /var/log/squid/access.log squid        #定义日志存放记录\ncache_log /var/log/squid/cache.log squid\ncache_store_log none                        #禁止store日志\n\nemulate_httpd_log on        #将使Squid仿照Web服务器的格式创建访问记录。如果希望使用\n                                #Web访问记录分析程序，就需要设置这个参数。\n\nrefresh_pattern . 0 20% 4320 override-expire override-lastmod reload-into-ims ignore-reload   #更新cache规则\n\nacl buggy_server url_regex ^http://.... http://          #只允许http的请求\nbroken_posts allow buggy_server\n\nacl apache rep_header Server ^Apache                 #允许apache的编码\nbroken_vary_encoding allow apache\n\nrequest_entities off                                        #禁止非http的标分准请求，防止攻击\nheader_access header allow all                        #允许所有的http报头\nrelaxed_header_parser on                                #不严格分析http报头.\nclient_lifetime 120 minute                                #最大客户连接时间 120分钟\n\ncache_mgr sky@test.com                        #指定当缓冲出现问题时向缓冲管理者发送告警信息的地址信息。\n\ncache_effective_user squid                        #这里以用户squid的身份Squid服务器\ncache_effective_group squid\n\nicp_port 0                       #指定Squid从邻居服务器缓冲内发送和接收ICP请求的端口号。\n                     #这里设置为0是因为这里配置Squid为内部Web服务器的加速器，\n                     #所以不需要使用邻居服务器的缓冲。0是禁用\n\n# cache_peer 设置允许更新缓存的主机，因是本机所以127.0.0.1\ncache_peer 127.0.0.1 parent 80 0 no-query default multicast-responder no-netdb-exchange\ncache_peer_domain 127.0.0.1                                 \nhostname_aliases 127.0.0.1\n\nerror_directory /usr/share/squid/errors/Simplify_Chinese        #定义错误路径\n\nalways_direct allow all                # cache丢失或不存在是允许所有请求直接转发到原始服务器\nignore_unknown_nameservers on        #开反DNS查询，当域名地址不相同时候，禁止访问\ncoredump_dir  /var/log/squid                 #定义dump的目录\n\nmax_filedesc 2048                #最大打开的文件描述\n\nhalf_closed_clients off        #使Squid在当read不再返回数据时立即关闭客户端的连接。\n                                #有时read不再返回数据是由于某些客户关闭TCP的发送数据\n                                #而仍然保持接收数据。而Squid分辨不出TCP半关闭和完全关闭。\n\nbuffered_logs on #若打开选项“buffered_logs”可以稍稍提高加速某些对日志文件的写入，该选项主要是实现优化特性。\n\n#防止天涯盗链，转嫁给百度\nacl tianya referer_regex -i tianya\nhttp_access deny tianya\ndeny_info  tianya\n#阻止baidu蜘蛛\nacl baidu req_header User-Agent Baiduspider\nhttp_access deny baidu\n#限制同一IP客户端的最大连接数\nacl OverConnLimit maxconn 128\nhttp_access deny OverConnLimit\n\n#防止被人利用为HTTP代理，设置允许访问的IP地址\nacl myip dst 222.18.63.37\nhttp_access deny !myip\n\n#允许本地管理\nacl Manager proto cache_object\nacl Localhost src 127.0.0.1 222.18.63.37\nhttp_access allow Manager Localhost\ncachemgr_passwd 53034338 all\nhttp_access deny Manager\n\n#仅仅允许80端口的代理\nacl all src 0.0.0.0/0.0.0.0\nacl Safe_ports port 80 # http\nhttp_access deny !Safe_ports\nhttp_access allow all\n\n#Squid信息设置\nvisible_hostname happy.swjtu.edu.cn\ncache_mgr  ooopic2008@qq.com\n\n#基本设置\ncache_effective_user squid\ncache_effective_group squid\ntcp_recv_bufsize 65535 bytes\n\n#2.6的反向代理加速配置\ncache_peer 127.0.0.1 parent 80 0 no-query originserver\n\n#错误文档\nerror_directory /usr/local/squid/share/errors/Simplify_Chinese\n\n#单台使用，不使用该功能\nicp_port 0\n\nhierarchy_stoplist cgi-bin ?\n\nacl QUERY urlpath_regex cgi-bin \\? .php .cgi .avi .wmv .rm .ram .mpg .mpeg .zip .exe\ncache deny QUERY\n\nacl apache rep_header Server ^Apache\nbroken_vary_encoding allow apache\n\n\nrefresh_pattern ^ftp:           1440 20%     10080\nrefresh_pattern ^gopher:        1440 0%    1440\nrefresh_pattern .             0    20%     4320\n\ncache_store_log none\npid_filename /usr/local/squid/var/logs/squid.pid\nemulate_httpd_log on\n```\n\n## Squid常用命令\n\n1.  初始化在squid.conf里配置的cache目录\n    squid -z\n    如果有错误提示，请检查cache目录的权限，可以更改目录权限\n    chown -R squid:squid /cache目录\n2.  对squid.conf排错，即验证squid.conf的语法和配置\n    squid -k parse\n    如果在squid.conf中有语法或配置错误，这里会返回提示，若无返回，尝试启动squid\n3.  前台启动squid，并输出启动过程\n    /usr/local/squid/sbin/squid -N -d1\n    如果有ready to server reques相关信息，说明squid启动成功\n    然后ctrl+c ,停止squid,并以后台运行的方式启动它\n4.  启动squid在后台运行\n    squid -s\n    可以使用ps -ax | grep squid 来查看squid进程是否存在\n5.  停止squid\n    squid -k shutdown\n6.  重新引导修改过的squid.conf\n    squid -k reconfigure -f /XXX/squid.conf\n    当squid进行配置更改后，可以使用该命令进行squid配置重载\n7.  把squid添加到系统启动项\n    vim /etc/rc.local\n    /usr/local/squid/sbin/squid -s\n8.  修改cache缓存目录的权限\n    chown -R squid.squid /cache目录\n    cache缓存目录根据自己的配置更改，squid用户和组是squid，squid\n9.  修改squid日志目录的权限\n    chown -R squid.squid 定义的日志文件所在目录\n    这一步并不是适合每一个使用squid的用户，意为让squid有权限在该目录里进行写操作\n10.  查看你的日志文档\n    more /usr/local/squid/var/logs/access.log | grep TCP_MEM_HIT\n    该指令可以看到在squid运行过程中，有那些文件被squid缓存到内存中，并返回给访问用户。\n    more /usr/local/squid/var/logs/access.log | grep TCP_HIT\n    该指令可以看到在squid运行过程中，有那些文件被squid缓存到cache目录中，并返回给访问用户。\n    more /usr/local/squid/var/logs/access.log | grep TCP_MISS\n    该指令可以看到在squid运行过程中，有那些文件没有被squid缓存，而是从原始服务器获取并返回给访问用户。\n\n## Squid命中率分析\n\n```\n/usr/local/squid/bin/squidclient -p 80 mgr:info\n/usr/local/squid/bin/squidclient -p 80 mgr:5min\n```\n可以看到详细的性能情况,其中PORT是你的proxy的端口，5min可以是60min\n取得squid运行状态信息：\n\n```\n squidclient -p 80 mgr:info\n```\n\n取得squid内存使用情况：\n\n```\nsquidclient -p 80 mgr:mem\n```\n\n取得squid已经缓存的列表：\n\n```\nsquidclient -p 80 mgr:bjects. use it carefully,it may crash\n```\n\n取得squid的磁盘使用情况：\n\n```\nsquidclient -p 80 mgr:diskd\n```\n\n强制更新某个url：\n\n```\nsquidclient -p 80 -m PURGE http://www.xxx.com/xxx.php\n```\n\n更多的请查看：squidclient-h 或者 squidclient -p 80 mgr:\n查命中率：\n\n```\nsquidclient -h IP(具体侦听IP) -p 80(具体侦听端口) mgr:info\n```\n\n## 定期清理swap.state内无效数据\n\n```\n/path/to/squid/sbin/squid -k rotate -f /path/to/squid/conf_file\nvi /etc/crontab\n0        0       *       *       *       root    /usr/local/sbin/squid -k rotate -f /usr/local/etc/squid/squid1.conf\n```\n\n当squid应用运行了一段时间之后，cache_dir对应的swap.state文件就会变得越来越大，里面的无效接口数据越来越多，这可能影响squid的响应时间，因此需要使用squid清理swap.state里面的无效数据，减少swap.state的大小。\n","content":"<h1 id=\"squid的概念\">squid的概念<a href=\"posts/squid#squid的概念\"></a></h1><p>squid是一种用来缓存Internet数据的软件。接受来自人们需要下载的目标（object）的请求并适当的处理这些请求。也就是说，如果一个人想下载一web界面，他请求squid为他取得这个页面。squid随之连接到远程服务器并向这个页面发出请求。然后，squid显式地聚集数据到客户端机器，而且同时复制一份。当下一次有人需要同一页面时， squid可以简单的从磁盘中读到它，那样数据会立即传输到客户机上。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"下载地址\">下载地址<a href=\"posts/squid#下载地址\"></a></h1><p>squid-cache 官网 <a href=\"http://www.squid-cache.org\" target=\"_blank\" rel=\"noopener\">http://www.squid-cache.org</a></p>\n<p>squid介绍及其简单配置 <a href=\"https://www.cnblogs.com/cherishry/p/5706736.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/cherishry/p/5706736.html</a></p>\n<p>CentOS 7安装squid代理服务器 <a href=\"https://blog.csdn.net/ithomer/article/details/78136993\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/ithomer/article/details/78136993</a></p>\n<h2 id=\"squid代理的作用\">squid代理的作用<a href=\"posts/squid#squid代理的作用\"></a></h2><ul>\n<li>通过缓存的方式为用户提供Web访问加速</li>\n<li>对用户的Web访问进行过滤控制</li>\n</ul>\n<h2 id=\"工作流程\">工作流程<a href=\"posts/squid#工作流程\"></a></h2><p>当代理服务器中有客户端需要的数据时：</p>\n<p>a.客户端向代理服务器发送数据请求；</p>\n<p>b.代理服务器检查自己的数据缓存；</p>\n<p>c.代理服务器在缓存中找到了用户想要的数据，取出数据；</p>\n<p>d.代理服务器将从缓存中取得的数据返回给客户端。</p>\n<p>当代理服务器中没有客户端需要的数据时了：</p>\n<p>1.客户端向代理服务器发送数据请求；</p>\n<p>2.代理服务器检查自己的数据缓存；</p>\n<p>3.代理服务器在缓存中没有找到用户想要的数据；</p>\n<p>4.代理服务器向Internet 上的远端服务器发送数据请求；</p>\n<p>5.远端服务器响应，返回相应的数据；</p>\n<p>6.代理服务器取得远端服务器的数据，返回给客户端，并保留一份到自己的数据缓存中。</p>\n<p><img src=\"https://images2015.cnblogs.com/blog/872781/201607/872781-20160726112850919-758636566.jpg\" alt=\"\" class=\"article-img\"></p>\n<p>Squid代理服务器工作在TCP/IP应用层</p>\n<p><img src=\"https://images2015.cnblogs.com/blog/872781/201607/872781-20160726112935653-887103660.jpg\" alt=\"\" class=\"article-img\"></p>\n<h2 id=\"Squid各种代理的定义\">Squid各种代理的定义<a href=\"posts/squid#Squid各种代理的定义\"></a></h2><h3 id=\"正向代理\">正向代理<a href=\"posts/squid#正向代理\"></a></h3><h4 id=\"标准的代理缓冲服务器\">标准的代理缓冲服务器<a href=\"posts/squid#标准的代理缓冲服务器\"></a></h4><p>一个标准的代理缓冲服务被用于缓存静态的网页到本地网络上的一台主机上（即代理服务器）。当被缓存的页面被第二次访问的时候，浏览器将直接从本地代理服务器那里获取请求数据而不再向原web站点请求数据。这样就节省了宝贵的网络带宽，而且提高了访问速度。但是，要想实现这种方式，必须在每一个内部主机的浏览器上明确指名代理服务器的IP地址和端口号。客户端上网时，每次都把请求发送给代理服务器处理,代理服务器根据请求确定是否连接到远程web服务器获取数据。如果在本地缓冲区有目标文件，则直接将文件传给用户即可。如果没有的话则先取回文件，先在本地保存一份缓冲，然后将文件发送给客户端浏览器。</p>\n<h4 id=\"透明代理缓冲服务器\">透明代理缓冲服务器<a href=\"posts/squid#透明代理缓冲服务器\"></a></h4><p>透明代理缓冲服务器和标准代理服务器的功能完全相同。但是，代理操作对客户端的浏览器是透明的（即不需指明代理服务器的IP和端口）。透明代理服务器阻断网络通信，并且过滤出访问外部的HTTP（80端口）流量。如果客户端的请求在本地有缓冲则将缓冲的数据直接发给用户，如果在本地没有缓冲则向远程web服务器发出请求，其余操作和标准的代理服务器完全相同。对于linux操作系统来说，透明代理使用Iptables或者Ipchains实现。因此不需要对浏览器作任何设置，所以，透明代理对于ISP（Internet服务器提供商）特别有用。</p>\n<h3 id=\"反向代理\">反向代理<a href=\"posts/squid#反向代理\"></a></h3><h4 id=\"反向代理缓冲器\">反向代理缓冲器<a href=\"posts/squid#反向代理缓冲器\"></a></h4><p>反向代理是和前两种代理完全不同的一种代理服务。使用它可以降低原始WEB服务器的负载。反向代理服务器承担了对原始WEB服务器的静态页面的请求，防止原始服务器过载。它位于WEB服务器和Internet之间，处理所有对WEB服务器的请求，组织了WEB服务器和Internet的直接通信。如果互联网用户请求的页面在代理服务器上有缓冲的话，代理服务器直接将缓冲内容发送给用户。如果没有缓冲则先向WEB服务器发出请求，取回数据，本地缓存后再发给用户。这种方式通过降低了WEB服务器的请求数从而降低了WEB服务器的负载。</p>\n<h3 id=\"正向代理与反向代理的区别\">正向代理与反向代理的区别<a href=\"posts/squid#正向代理与反向代理的区别\"></a></h3><h3 id=\"概念\">概念<a href=\"posts/squid#概念\"></a></h3><p>正向代理：对于原始服务器而言，就是客户端的代言人<br>反向代理：对于客户端而言，就像是原始服务器</p>\n<h3 id=\"用途\">用途<a href=\"posts/squid#用途\"></a></h3><p>正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。<br>反向代理还可以为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。另外，反向代理还可以启用高级URL策略和管理技术，从而使处于不同web服务器系统的web页面同时存在于同一个URL空间下。</p>\n<h3 id=\"安全性\">安全性<a href=\"posts/squid#安全性\"></a></h3><p>正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。<br>反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。</p>\n<h2 id=\"Squid主要组成部分\">Squid主要组成部分<a href=\"posts/squid#Squid主要组成部分\"></a></h2><p>服务名：<code>squid</code><br>主程序：<code>/usr/sbin/squid</code><br>配置目录：<code>/etc/squid</code><br>主配置文件：<code>/etc/squid/squid.conf</code><br>监听tcp端口号：<code>3128</code><br>默认访问日志文件：<code>/var/log/squid/access.log</code></p>\n<h2 id=\"squid常用配置选项\">squid常用配置选项<a href=\"posts/squid#squid常用配置选项\"></a></h2><p><code>/etc/squid/squid.conf</code></p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">http_port <span class=\"number\">3128</span>  (还可以只监听一个IP http_port <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">3128</span>)</span><br><span class=\"line\">cache_mem <span class=\"number\">64</span>MB  <span class=\"meta\">#缓存占内存大小</span></span><br><span class=\"line\">maximum_object_size <span class=\"number\">4096</span>KB  <span class=\"meta\">#最大缓存块</span></span><br><span class=\"line\">reply_body_max_size  <span class=\"number\">1024000</span> allow <span class=\"built_in\">all</span>      <span class=\"meta\">#限定下载文件大小</span></span><br><span class=\"line\">access_log /var/<span class=\"built_in\">log</span>/squid/access.<span class=\"built_in\">log</span>    <span class=\"meta\">#访问日志存放的地方</span></span><br><span class=\"line\">visible_hostname    proxy.test.xom  <span class=\"meta\">#可见的主机名</span></span><br><span class=\"line\">cache_dir ufs /var/spool/squid  <span class=\"number\">100</span> <span class=\"number\">16</span> <span class=\"number\">256</span> </span><br><span class=\"line\"><span class=\"meta\">#ufs:缓存数据的存储格式</span></span><br><span class=\"line\"><span class=\"meta\">#/var/spool/squid    缓存目录</span></span><br><span class=\"line\"><span class=\"meta\">#100：缓存目录占磁盘空间大小（M）</span></span><br><span class=\"line\"><span class=\"meta\">#16：缓存空间一级子目录个数</span></span><br><span class=\"line\"><span class=\"meta\">#256：缓存空间二级子目录个数</span></span><br><span class=\"line\">cache_mgr webmaster@test.com    <span class=\"meta\">#定义管理员邮箱</span></span><br><span class=\"line\">http_access deny <span class=\"built_in\">all</span>    <span class=\"meta\">#访问控制</span></span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"squid中的访问控制\">squid中的访问控制<a href=\"posts/squid#squid中的访问控制\"></a></h2><p>  使用访问控制特性，可以控制在访问时根据特定的时间间隔进行缓存、访问特定站点或一组站点等等。squid访问控制有两个要素：ACL元素和访问列表。访问列表可以允许或拒绝某些用户对此服务的访问。</p>\n<h3 id=\"ACL元素类型\">ACL元素类型<a href=\"posts/squid#ACL元素类型\"></a></h3><ul>\n<li>src：源地址（即客户机IP地址）</li>\n<li>dst：目标地址（即服务器IP地址）</li>\n<li>srcdomain：源名称（即客户机名称）</li>\n<li>dstdomain：目标名称（即服务器名称）</li>\n<li>time：一天中的时刻和一周内的一天</li>\n<li>url_regex：URL规则表达式匹配</li>\n<li>urlpath_regex：URL-path规则表达式匹配，略去协议和主机名</li>\n<li>proxy_auth：通过外部程序进行用户验证</li>\n<li>maxconn：单一IP的最大连接数</li>\n</ul>\n<h3 id=\"ACL格式\">ACL格式<a href=\"posts/squid#ACL格式\"></a></h3><pre><code>为了使用控制功能，必须先设置ACL规则并应用。ACL声明的格式如下：</code></pre><p>注：</p>\n<ul>\n<li>acl_element_name 可以是任一个在ACL中定义的名称</li>\n<li>任何两个ACL元素不能用相同的名字</li>\n<li>每个ACL由列表值组成。当进行匹配检测的时候，多个值由逻辑或运算连接；换言之，即任一ACL元素的值被匹配，则这个ACL元素即被匹配。</li>\n<li>并不是所有ACL元素都能使用访问列表中的全部类型</li>\n<li>不同的ACL元素写在不同行中，squid将把他们组合在一个列表中</li>\n</ul>\n<h3 id=\"访问条目\">访问条目<a href=\"posts/squid#访问条目\"></a></h3><p>我们可以使用许多不同的访问条目。下面是我们常用的几个：</p>\n<ul>\n<li>http_access:允许HTTP访问</li>\n<li>no_cache:定义对缓存请求的响应。<br>访问列表的规则由一些类似’allow’或‘deny’的关键字构成，用以允许或拒绝向特定或一组ACL元素提供服务。</li>\n</ul>\n<ol>\n<li>一个访问列表可以由多条规则组成</li>\n<li>如果没有任何规则与访问请求匹配，默认动作将与列表中最后一条规则对应。</li>\n<li>一个访问条目中所有元素将用逻辑与运算连接<br>http_access Action 声明1 AND 声明2 AND 声明 OR.<br>http_access Action 声明3<br>多个http_accesss声明间用或运算连接，但每个访问条目的元素间用与运算连接。</li>\n<li>列表中的规则总是遵循由上而下的顺序</li>\n<li>这些规则按照他们的排列顺序进行匹配检测，一旦检测到匹配的规则，匹配就立即结束。</li>\n</ol>\n<h2 id=\"Squid-conf配置文件详解\">Squid.conf配置文件详解<a href=\"posts/squid#Squid-conf配置文件详解\"></a></h2><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#acl all src 0.0.0.0/0.0.0.0 and http_access allow all选项定义了一个访问控制列表。详细情况参见和Squid软件</span></span><br><span class=\"line\"><span class=\"comment\">#携带的文档。这里的访问控制列表允许所有对代理服务的访问，因为这里该代理是加速web服务器。</span></span><br><span class=\"line\">acl all src 0.0.0.0/0.0.0.0                 <span class=\"comment\">#允许所有IP访问</span></span><br><span class=\"line\">acl manager proto http                 <span class=\"comment\">#manager url协议为http</span></span><br><span class=\"line\">acl localhost src 127.0.0.1/255.255.255.255  <span class=\"comment\">#允午本机IP</span></span><br><span class=\"line\">acl to_localhost dst 127.0.0.1                 <span class=\"comment\">#允午目的地址为本机IP</span></span><br><span class=\"line\">acl Safe_ports port 80                <span class=\"comment\"># 允许安全更新的端口为80</span></span><br><span class=\"line\">acl CONNECT method CONNECT        <span class=\"comment\">#请求方法以CONNECT</span></span><br><span class=\"line\">http_access allow all                <span class=\"comment\">#允许所有人使用该代理.因为这里是代理加速web服务器</span></span><br><span class=\"line\">http_reply_access allow all                <span class=\"comment\">#允许所有客户端使用该代理</span></span><br><span class=\"line\"></span><br><span class=\"line\">acl OverConnLimit maxconn 16        <span class=\"comment\">#限制每个IP最大允许16个连接，防止攻击</span></span><br><span class=\"line\">http_access deny OverConnLimit</span><br><span class=\"line\"></span><br><span class=\"line\">icp_access deny all                        <span class=\"comment\">#禁止从邻居服务器缓冲内发送和接收ICP请求.</span></span><br><span class=\"line\">miss_access allow all                <span class=\"comment\">#允许直接更新请求</span></span><br><span class=\"line\">ident_lookup_access deny all                                <span class=\"comment\">#禁止lookup检查DNS</span></span><br><span class=\"line\">http_port 8080 transparent                                <span class=\"comment\">#指定Squid监听浏览器客户请求的端口号。</span></span><br><span class=\"line\"></span><br><span class=\"line\">hierarchy_stoplist cgi-bin ?                <span class=\"comment\">#用来强制某些特定的对象不被缓存，主要是处于安全的目的。</span></span><br><span class=\"line\">acl QUERY urlpath_regex cgi-bin \\?</span><br><span class=\"line\"><span class=\"keyword\">cache</span> deny <span class=\"keyword\">QUERY</span></span><br><span class=\"line\"></span><br><span class=\"line\">cache_mem <span class=\"number\">1</span> GB        <span class=\"comment\">#这是一个优化选项，增加该内存值有利于缓存。应该注意的是：</span></span><br><span class=\"line\">                     <span class=\"comment\">#一般来说如果系统有内存，设置该值为(n/)3M。现在是3G 所以这里1G</span></span><br><span class=\"line\">fqdncache_size <span class=\"number\">1024</span>        <span class=\"comment\">#FQDN 高速缓存大小</span></span><br><span class=\"line\">maximum_object_size_in_memory <span class=\"number\">2</span> MB        <span class=\"comment\">#允许最大的文件载入内存</span></span><br><span class=\"line\"></span><br><span class=\"line\">memory_replacement_policy <span class=\"keyword\">heap</span> LFUDA  <span class=\"comment\">#动态使用最小的，移出内存cache</span></span><br><span class=\"line\">cache_replacement_policy <span class=\"keyword\">heap</span> LFUDA         <span class=\"comment\">#动态使用最小的，移出硬盘cache</span></span><br><span class=\"line\"></span><br><span class=\"line\">cache_dir ufs /home/<span class=\"keyword\">cache</span> <span class=\"number\">5000</span> <span class=\"number\">32</span> <span class=\"number\">512</span>  <span class=\"comment\">#高速缓存目录 ufs 类型 使用的缓冲值最大允午1000MB空间，</span></span><br><span class=\"line\"><span class=\"comment\">#32个一级目录，512个二级目录</span></span><br><span class=\"line\"></span><br><span class=\"line\">max_open_disk_fds <span class=\"number\">0</span>                                 <span class=\"comment\">#允许最大打开文件数量,0 无限制</span></span><br><span class=\"line\">minimum_object_size <span class=\"number\">1</span> KB                         <span class=\"comment\">#允午最小文件请求体大小</span></span><br><span class=\"line\">maximum_object_size <span class=\"number\">20</span> MB                 <span class=\"comment\">#允午最大文件请求体大小</span></span><br><span class=\"line\"></span><br><span class=\"line\">cache_swap_low <span class=\"number\">90</span>                            <span class=\"comment\">#最小允许使用swap 90%</span></span><br><span class=\"line\">cache_swap_high <span class=\"number\">95</span>                            <span class=\"comment\">#最多允许使用swap 95%</span></span><br><span class=\"line\"></span><br><span class=\"line\">ipcache_size <span class=\"number\">2048</span>                                <span class=\"comment\"># IP 地址高速缓存大小 2M</span></span><br><span class=\"line\">ipcache_low <span class=\"number\">90</span>                                <span class=\"comment\">#最小允许ipcache使用swap 90%</span></span><br><span class=\"line\">ipcache_high <span class=\"number\">95</span>                                  <span class=\"comment\">#最大允许ipcache使用swap 90%</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">access_log /<span class=\"keyword\">var</span>/<span class=\"keyword\">log</span>/squid/access.log squid        <span class=\"comment\">#定义日志存放记录</span></span><br><span class=\"line\">cache_log /<span class=\"keyword\">var</span>/<span class=\"keyword\">log</span>/squid/cache.log squid</span><br><span class=\"line\">cache_store_log <span class=\"keyword\">none</span>                        <span class=\"comment\">#禁止store日志</span></span><br><span class=\"line\"></span><br><span class=\"line\">emulate_httpd_log <span class=\"keyword\">on</span>        <span class=\"comment\">#将使Squid仿照Web服务器的格式创建访问记录。如果希望使用</span></span><br><span class=\"line\">                                <span class=\"comment\">#Web访问记录分析程序，就需要设置这个参数。</span></span><br><span class=\"line\"></span><br><span class=\"line\">refresh_pattern . <span class=\"number\">0</span> <span class=\"number\">20</span>% <span class=\"number\">4320</span> override-<span class=\"keyword\">expire</span> override-lastmod reload-<span class=\"keyword\">into</span>-ims <span class=\"keyword\">ignore</span>-reload   <span class=\"comment\">#更新cache规则</span></span><br><span class=\"line\"></span><br><span class=\"line\">acl buggy_server url_regex ^<span class=\"keyword\">http</span>://.... <span class=\"keyword\">http</span>://          <span class=\"comment\">#只允许http的请求</span></span><br><span class=\"line\">broken_posts <span class=\"keyword\">allow</span> buggy_server</span><br><span class=\"line\"></span><br><span class=\"line\">acl apache rep_header <span class=\"keyword\">Server</span> ^Apache                 <span class=\"comment\">#允许apache的编码</span></span><br><span class=\"line\">broken_vary_encoding <span class=\"keyword\">allow</span> apache</span><br><span class=\"line\"></span><br><span class=\"line\">request_entities <span class=\"keyword\">off</span>                                        <span class=\"comment\">#禁止非http的标分准请求，防止攻击</span></span><br><span class=\"line\">header_access header <span class=\"keyword\">allow</span> all                        <span class=\"comment\">#允许所有的http报头</span></span><br><span class=\"line\">relaxed_header_parser <span class=\"keyword\">on</span>                                <span class=\"comment\">#不严格分析http报头.</span></span><br><span class=\"line\">client_lifetime <span class=\"number\">120</span> <span class=\"keyword\">minute</span>                                <span class=\"comment\">#最大客户连接时间 120分钟</span></span><br><span class=\"line\"></span><br><span class=\"line\">cache_mgr sky@test.com                        <span class=\"comment\">#指定当缓冲出现问题时向缓冲管理者发送告警信息的地址信息。</span></span><br><span class=\"line\"></span><br><span class=\"line\">cache_effective_user squid                        <span class=\"comment\">#这里以用户squid的身份Squid服务器</span></span><br><span class=\"line\">cache_effective_group squid</span><br><span class=\"line\"></span><br><span class=\"line\">icp_port <span class=\"number\">0</span>                       <span class=\"comment\">#指定Squid从邻居服务器缓冲内发送和接收ICP请求的端口号。</span></span><br><span class=\"line\">                     <span class=\"comment\">#这里设置为0是因为这里配置Squid为内部Web服务器的加速器，</span></span><br><span class=\"line\">                     <span class=\"comment\">#所以不需要使用邻居服务器的缓冲。0是禁用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># cache_peer 设置允许更新缓存的主机，因是本机所以127.0.0.1</span></span><br><span class=\"line\">cache_peer <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span> <span class=\"keyword\">parent</span> <span class=\"number\">80</span> <span class=\"number\">0</span> <span class=\"keyword\">no</span>-<span class=\"keyword\">query</span> <span class=\"keyword\">default</span> multicast-responder <span class=\"keyword\">no</span>-netdb-<span class=\"keyword\">exchange</span></span><br><span class=\"line\">cache_peer_domain <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>                                 </span><br><span class=\"line\">hostname_aliases <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span></span><br><span class=\"line\"></span><br><span class=\"line\">error_directory /usr/<span class=\"keyword\">share</span>/squid/<span class=\"keyword\">errors</span>/Simplify_Chinese        <span class=\"comment\">#定义错误路径</span></span><br><span class=\"line\"></span><br><span class=\"line\">always_direct <span class=\"keyword\">allow</span> all                <span class=\"comment\"># cache丢失或不存在是允许所有请求直接转发到原始服务器</span></span><br><span class=\"line\">ignore_unknown_nameservers <span class=\"keyword\">on</span>        <span class=\"comment\">#开反DNS查询，当域名地址不相同时候，禁止访问</span></span><br><span class=\"line\">coredump_dir  /<span class=\"keyword\">var</span>/<span class=\"keyword\">log</span>/squid                 <span class=\"comment\">#定义dump的目录</span></span><br><span class=\"line\"></span><br><span class=\"line\">max_filedesc <span class=\"number\">2048</span>                <span class=\"comment\">#最大打开的文件描述</span></span><br><span class=\"line\"></span><br><span class=\"line\">half_closed_clients <span class=\"keyword\">off</span>        <span class=\"comment\">#使Squid在当read不再返回数据时立即关闭客户端的连接。</span></span><br><span class=\"line\">                                <span class=\"comment\">#有时read不再返回数据是由于某些客户关闭TCP的发送数据</span></span><br><span class=\"line\">                                <span class=\"comment\">#而仍然保持接收数据。而Squid分辨不出TCP半关闭和完全关闭。</span></span><br><span class=\"line\"></span><br><span class=\"line\">buffered_logs <span class=\"keyword\">on</span> <span class=\"comment\">#若打开选项“buffered_logs”可以稍稍提高加速某些对日志文件的写入，该选项主要是实现优化特性。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#防止天涯盗链，转嫁给百度</span></span><br><span class=\"line\">acl tianya referer_regex -i tianya</span><br><span class=\"line\">http_access deny tianya</span><br><span class=\"line\">deny_info  tianya</span><br><span class=\"line\"><span class=\"comment\">#阻止baidu蜘蛛</span></span><br><span class=\"line\">acl baidu req_header <span class=\"keyword\">User</span>-<span class=\"keyword\">Agent</span> Baiduspider</span><br><span class=\"line\">http_access deny baidu</span><br><span class=\"line\"><span class=\"comment\">#限制同一IP客户端的最大连接数</span></span><br><span class=\"line\">acl OverConnLimit maxconn <span class=\"number\">128</span></span><br><span class=\"line\">http_access deny OverConnLimit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#防止被人利用为HTTP代理，设置允许访问的IP地址</span></span><br><span class=\"line\">acl myip dst <span class=\"number\">222.18</span><span class=\"number\">.63</span><span class=\"number\">.37</span></span><br><span class=\"line\">http_access deny !myip</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#允许本地管理</span></span><br><span class=\"line\">acl Manager proto cache_object</span><br><span class=\"line\">acl Localhost src <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span> <span class=\"number\">222.18</span><span class=\"number\">.63</span><span class=\"number\">.37</span></span><br><span class=\"line\">http_access <span class=\"keyword\">allow</span> Manager Localhost</span><br><span class=\"line\">cachemgr_passwd <span class=\"number\">53034338</span> all</span><br><span class=\"line\">http_access deny Manager</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#仅仅允许80端口的代理</span></span><br><span class=\"line\">acl all src <span class=\"number\">0.0</span><span class=\"number\">.0</span><span class=\"number\">.0</span>/<span class=\"number\">0.0</span><span class=\"number\">.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">acl Safe_ports port <span class=\"number\">80</span> <span class=\"comment\"># http</span></span><br><span class=\"line\">http_access deny !Safe_ports</span><br><span class=\"line\">http_access <span class=\"keyword\">allow</span> all</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Squid信息设置</span></span><br><span class=\"line\">visible_hostname happy.swjtu.edu.cn</span><br><span class=\"line\">cache_mgr  ooopic2008@qq.com</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#基本设置</span></span><br><span class=\"line\">cache_effective_user squid</span><br><span class=\"line\">cache_effective_group squid</span><br><span class=\"line\">tcp_recv_bufsize <span class=\"number\">65535</span> <span class=\"keyword\">bytes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#2.6的反向代理加速配置</span></span><br><span class=\"line\">cache_peer <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span> <span class=\"keyword\">parent</span> <span class=\"number\">80</span> <span class=\"number\">0</span> <span class=\"keyword\">no</span>-<span class=\"keyword\">query</span> originserver</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#错误文档</span></span><br><span class=\"line\">error_directory /usr/<span class=\"keyword\">local</span>/squid/<span class=\"keyword\">share</span>/<span class=\"keyword\">errors</span>/Simplify_Chinese</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#单台使用，不使用该功能</span></span><br><span class=\"line\">icp_port <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">hierarchy_stoplist cgi-<span class=\"keyword\">bin</span> ?</span><br><span class=\"line\"></span><br><span class=\"line\">acl <span class=\"keyword\">QUERY</span> urlpath_regex cgi-<span class=\"keyword\">bin</span> \\? .php .cgi .avi .wmv .rm .ram .mpg .mpeg .zip .exe</span><br><span class=\"line\"><span class=\"keyword\">cache</span> deny <span class=\"keyword\">QUERY</span></span><br><span class=\"line\"></span><br><span class=\"line\">acl apache rep_header <span class=\"keyword\">Server</span> ^Apache</span><br><span class=\"line\">broken_vary_encoding <span class=\"keyword\">allow</span> apache</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">refresh_pattern ^<span class=\"keyword\">ftp</span>:           <span class=\"number\">1440</span> <span class=\"number\">20</span>%     <span class=\"number\">10080</span></span><br><span class=\"line\">refresh_pattern ^gopher:        <span class=\"number\">1440</span> <span class=\"number\">0</span>%    <span class=\"number\">1440</span></span><br><span class=\"line\">refresh_pattern .             <span class=\"number\">0</span>    <span class=\"number\">20</span>%     <span class=\"number\">4320</span></span><br><span class=\"line\"></span><br><span class=\"line\">cache_store_log <span class=\"keyword\">none</span></span><br><span class=\"line\">pid_filename /usr/<span class=\"keyword\">local</span>/squid/<span class=\"keyword\">var</span>/<span class=\"keyword\">logs</span>/squid.pid</span><br><span class=\"line\">emulate_httpd_log <span class=\"keyword\">on</span></span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"Squid常用命令\">Squid常用命令<a href=\"posts/squid#Squid常用命令\"></a></h2><ol>\n<li>初始化在squid.conf里配置的cache目录<br>squid -z<br>如果有错误提示，请检查cache目录的权限，可以更改目录权限<br>chown -R squid:squid /cache目录</li>\n<li>对squid.conf排错，即验证squid.conf的语法和配置<br>squid -k parse<br>如果在squid.conf中有语法或配置错误，这里会返回提示，若无返回，尝试启动squid</li>\n<li>前台启动squid，并输出启动过程<br>/usr/local/squid/sbin/squid -N -d1<br>如果有ready to server reques相关信息，说明squid启动成功<br>然后ctrl+c ,停止squid,并以后台运行的方式启动它</li>\n<li>启动squid在后台运行<br>squid -s<br>可以使用ps -ax | grep squid 来查看squid进程是否存在</li>\n<li>停止squid<br>squid -k shutdown</li>\n<li>重新引导修改过的squid.conf<br>squid -k reconfigure -f /XXX/squid.conf<br>当squid进行配置更改后，可以使用该命令进行squid配置重载</li>\n<li>把squid添加到系统启动项<br>vim /etc/rc.local<br>/usr/local/squid/sbin/squid -s</li>\n<li>修改cache缓存目录的权限<br>chown -R squid.squid /cache目录<br>cache缓存目录根据自己的配置更改，squid用户和组是squid，squid</li>\n<li>修改squid日志目录的权限<br>chown -R squid.squid 定义的日志文件所在目录<br>这一步并不是适合每一个使用squid的用户，意为让squid有权限在该目录里进行写操作</li>\n<li>查看你的日志文档<br>more /usr/local/squid/var/logs/access.log | grep TCP_MEM_HIT<br>该指令可以看到在squid运行过程中，有那些文件被squid缓存到内存中，并返回给访问用户。<br>more /usr/local/squid/var/logs/access.log | grep TCP_HIT<br>该指令可以看到在squid运行过程中，有那些文件被squid缓存到cache目录中，并返回给访问用户。<br>more /usr/local/squid/var/logs/access.log | grep TCP_MISS<br>该指令可以看到在squid运行过程中，有那些文件没有被squid缓存，而是从原始服务器获取并返回给访问用户。</li>\n</ol>\n<h2 id=\"Squid命中率分析\">Squid命中率分析<a href=\"posts/squid#Squid命中率分析\"></a></h2><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">/usr/</span>local<span class=\"regexp\">/squid/</span>bin/squidclient -p <span class=\"number\">80</span> <span class=\"string\">mgr:</span>info</span><br><span class=\"line\"><span class=\"regexp\">/usr/</span>local<span class=\"regexp\">/squid/</span>bin/squidclient -p <span class=\"number\">80</span> <span class=\"string\">mgr:</span><span class=\"number\">5</span>min</span><br></pre></td></tr></table></div></figure>\n\n<p>可以看到详细的性能情况,其中PORT是你的proxy的端口，5min可以是60min<br>取得squid运行状态信息：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">squidclient</span> -p <span class=\"number\">80</span> mgr:<span class=\"literal\">info</span></span><br></pre></td></tr></table></div></figure>\n\n<p>取得squid内存使用情况：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">squidclient -<span class=\"selector-tag\">p</span> <span class=\"number\">80</span> mgr:mem</span><br></pre></td></tr></table></div></figure>\n\n<p>取得squid已经缓存的列表：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">squidclient</span> -p <span class=\"number\">80</span> mgr:<span class=\"keyword\">bjects. </span>use <span class=\"keyword\">it </span>carefully,<span class=\"keyword\">it </span>may crash</span><br></pre></td></tr></table></div></figure>\n\n<p>取得squid的磁盘使用情况：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">squidclient -<span class=\"selector-tag\">p</span> <span class=\"number\">80</span> mgr:diskd</span><br></pre></td></tr></table></div></figure>\n\n<p>强制更新某个url：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">squidclient -<span class=\"selector-tag\">p</span> <span class=\"number\">80</span> -m PURGE http:<span class=\"comment\">//www.xxx.com/xxx.php</span></span><br></pre></td></tr></table></div></figure>\n\n<p>更多的请查看：squidclient-h 或者 squidclient -p 80 mgr:<br>查命中率：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">squidclient</span> -h <span class=\"built_in\">IP</span>(具体侦听<span class=\"built_in\">IP</span>) -p <span class=\"number\">80</span>(具体侦听端口) mgr:<span class=\"meta\">info</span></span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"定期清理swap-state内无效数据\">定期清理swap.state内无效数据<a href=\"posts/squid#定期清理swap-state内无效数据\"></a></h2><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta-keyword\">/path/</span>to<span class=\"meta-keyword\">/squid/</span>sbin/squid -k rotate -f <span class=\"meta-keyword\">/path/</span>to<span class=\"meta-keyword\">/squid/</span>conf_file</span><br><span class=\"line\">vi <span class=\"meta-keyword\">/etc/</span>crontab</span><br><span class=\"line\"><span class=\"number\">0</span>        <span class=\"number\">0</span>       *       *       *       root    <span class=\"meta-keyword\">/usr/</span>local<span class=\"meta-keyword\">/sbin/</span>squid -k rotate -f <span class=\"meta-keyword\">/usr/</span>local<span class=\"meta-keyword\">/etc/</span>squid/squid1.conf</span><br></pre></td></tr></table></div></figure>\n\n<p>当squid应用运行了一段时间之后，cache_dir对应的swap.state文件就会变得越来越大，里面的无效接口数据越来越多，这可能影响squid的响应时间，因此需要使用squid清理swap.state里面的无效数据，减少swap.state的大小。</p>\n","slug":"squid","updated":"2019-07-14T01:23:21.617Z","comments":true,"link":"posts/squid","permalink":"https://shuntan.github.io/posts/squid/","excerpt":"squid的概念squid是一种用来缓存Internet数据的软件。接受来自人们需要下载的目标（object）的请求并适当的处理这些请求。也就是说，如果一个人想下载一web界面，他请求squid为他取得这个页面。squid随之连接到远程服务器并向这个页面发出请求。然后，squid显式地聚集数据到客户端机器，而且同时复制一份。当下一次有人需要同一页面时， squid可以简单的从磁盘中读到它，那样数据会立即传输到客户机上。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://shuntan.github.io/categories/Linux/"}],"tags":[{"name":"squid","slug":"squid","permalink":"https://shuntan.github.io/tags/squid/"},{"name":"proxy","slug":"proxy","permalink":"https://shuntan.github.io/tags/proxy/"}]},{"title":"科学上网：用 VPS 搭建 shadowsocks 服务器","date":"2019-05-15T06:38:46.000Z","path":"posts/shadowsocks/","text":"shadowsocks 简介shadowsocks 是一款自定义协议的代理软件，由于其流量特征不明显，（直到不久前）一直可以稳定提供上网代理。 shadowsocks 客户端会在本地开启一个 socks5 代理，通过此代理的网络访问请求由客户端发送至服务端，服务端发出请求，收到响应数据后再发回客户端。 因此使用 shadowsocks 需要一台墙外的服务器来部署 shadowsocks 服务端。 购买 VPS 服务器 主流的 VPS（虚拟主机）服务器提供商有三家： linode digital ocean bandwagon 下面的比上面的便宜。如果只是自用，bandwagon 足够。 一般使用 paypal 绑定一个 visa 或 mastercard 信用卡来付款。注意要用国际 paypal 帐号，国内的是不能用外币付款的。 在 bandwagon 购买 VPS 以后会获得一个主机地址和用于 ssh 登录的 root 密码。 远程登陆 VPS Mac或 Linux 下直接在终端中ssh root@your_vps_ip your_ssh_port即可。在 windows 系统下需要专门的客户端来 SSH 登录 VPS。在&nbsp;xShell 官网&nbsp;&nbsp;下载 xShell。 家庭和学校用户可以免费试用，下载时选择 home&nbsp;and&nbsp;school&nbsp;use 即可。需要用邮箱注册一下，下载链接会发送到邮箱中。 xShell 中新建一个连接，会要求输入目标 IP 地址和端口，以及 root 密码，按提示操作即可。 安装 shadowsocks最好是centos7 1.安装pip 由于安装的是python 版本的 shadowsocks，所以首先安装pip $ curl &quot;https://bootstrap.pypa.io/get-pip.py&quot; -o &quot;get-pip.py&quot; $ python get-pip.py2.安装shadowsocks $ pip install --upgrade pip $ pip install shadowsocks3.创建配置文件 创建文件所在目录:/etc创建文件命令 $ vi /etc/shadowsocks.json若进入了etc目录 $ vi shadowsocks.json配置文件内容： 单端口： 1234567891011121314151617&#123; \"server\":\"0.0.0.0\", --服务器IP，直接用0.0.0.0也可 \"server_port\":8888, --端口端口 \"local_address\": \"127.0.0.1\", --本地地址，可省略 \"local_port\":1080,--本地端口，可省略 \"password\":\"password\",--密码 \"timeout\":300, --超时时间，可省略 \"method\":\"aes-256-cfb\", --加密策略，有多重策略，具体自查&#125; 多端口： 12345678910111213141516171819202122232425&#123; \"server\":\"0.0.0.0\", \"local_address\":\"127.0.0.1\", \"local_port\":1080, \"port_password\":&#123;--每个端口对应一个密码 \"1111\":\"password1\", \"1112\":\"password2\", \"1113\":\"password3\" &#125;, \"timeout\":300, \"method\":\"aes-256-cfb\", \"fast_open\":false&#125; 4.启动shadowsocks 启动 ssserver -c /etc/shadowsocks.json -d start停止 ssserver -c /etc/shadowsocks.json -d stop重启 ssserver -c /etc/shadowsocks.json -d restart启动成功即可通过ss客户端使用。 在window端可以在控制台通过以下命令查看端口是否打开 telnet {ip} {port}5.配置自启动 新建启动脚本文件/etc/systemd/system/shadowsocks.service，内容如下：[Unit] Description=Shadowsocks[Service] TimeoutStartSec=0 ExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json[Install] WantedBy=multi-user.target通过以下命令注册，启动服务 $ systemctl enable shadowsocks $ systemctl start shadowsocks启动后可以查看服务状态 $ systemctl status shadowsocks -l若启动成功： ● shadowsocks.service - Shadowsocks Loaded: loaded (/etc/systemd/system/shadowsocks.service; enabled; vendor preset: disabled) Active: active (running) since Sun 2017-08-13 18:03:41 CST; 1h 29min ago Main PID: 9567 (ssserver) CGroup: /system.slice/shadowsocks.service └─9567 /usr/bin/python2 /usr/bin/ssserver -c /etc/shadowsocks.json如果，服务失败，重启服务器试一下 安装并启动 shadowsocks 客户端 shadowsocks 支持 windows、Mac&nbsp;OS&nbsp;X、Linux、Android、iOS 等多个平台。不过 iOS 由于系统对应用后台运行的限制，推荐使用客户端内嵌的浏览器科学上网，给其他应用代理时需要每过几分钟重新启动一下 app。 shadowsocks 项目 Github 主页在这里。 里面可以找到客户端下载地址。 下载安装客户端以后，只需按服务器的配置填写 IP 地址、服务器端口、本地端口（如果没有本地端口选项，就是默认的 1080）、密码、加密方式等参数，启动就可以了。 客户端支持全局代理和 PAC 代理两种方式，后者会使用一个脚本来自动检查一个网站是否在需要代理的网站列表中，自动选择直接连接或代理连接。 PAC 列表可以在线更新，但是难免有收录不全的情况。这时可以选择关闭 shadowsocks 代理（实际上是取消对系统代理的配置，shadowsocks 客户端仍然保持工作），然后使用支持自定义规则的代理管理插件来实现自动切换代理，比如 switchyOmega。 使用 switchyOmega 实现自动切换代理switchyOmega 是 chrome 浏览器上一个很好用的代理管理插件。它的前身 switchySharp 更有名。 chrome 应用商店本身需要翻墙才能访问，因此需要先在 shadowsocks 启动代理模式下下载安装，再关闭 shadowsocks 代理。 安装完毕后，右击 switchyOmega 图标，选择选项，进入 switchOmega 配置界面。创建 shadowsocks 情景模式新建一个情景模式，比如叫 SS，代理协议选择 socks5，代理地址为 127.0.0.1，端口 1080。 现在切换到 SS 情景模式就可以通过 shadowsocks 科学上网了。后面获取自动切换规则列表设置自动切换模式 在设置界面选择自动切换模式，在 “切换规则” 中勾选“规则列表规则”，对应的情景模式选择刚刚新建的 SS。 然后在下面的规则列表地址中填写 https://autoproxy-gfwlist.googlecode.com/svn/trunk/gfwlist.txt 规则列表格式选择 AutoProxy。 然后点击立即更新情景模式， 更新完成后会有提示。 点击左侧的 “应用选项”。然后单击 switchyOmega 图标，选择自动切换，就可以在访问“不存在的网站” 时自动切换到 shadowsocks 代理了。 添加自定义规则 如果遇到某个国外网站无法直接连接或速度太慢时，可以单击 switchyOmega 图标，选择 “添加条件”，情景模式选择 SS，就可以了。 这时打开 switchyOmega 选项，在自动切换模式的切换规则中就可以看到刚刚添加的规则。可以在这里管理自定义的规则。 导入和导出 switchyOmega 设置 如果换了一台电脑，重新设置一遍 switchyOmega 就太麻烦了。可以在设置好的 switchyOmega 中导出设置文件，在另一个 chrome 浏览器中导入，就可以直接复制原来的设置了。 在 switchyOmega 选项的左侧点击 “导入 / 导出”，点击“生成备份文件” 即可生成 switchyOmega 设置备份。点击 “从备份文件恢复” 可以导入备份文件。","raw":"---\ntitle: 科学上网：用 VPS 搭建 shadowsocks 服务器\ncopyright: true\ntags:\n  - VPS\n  - shadowsocks\ncategories: Linux\nabbrlink: a067636e\ndate: 2019-05-15 14:38:46\ntype:\nkeyword:\ntop:\ncomments:\npassword:\nthumbnail: /posts/shadowsocks/20190907152753.jpg\n---\n\n## shadowsocks 简介\n\nshadowsocks 是一款自定义协议的代理软件，由于其流量特征不明显，（直到不久前）一直可以稳定提供上网代理。\n\nshadowsocks 客户端会在本地开启一个 socks5 代理，通过此代理的网络访问请求由客户端发送至服务端，服务端发出请求，收到响应数据后再发回客户端。\n\n因此使用 shadowsocks 需要一台墙外的服务器来部署 shadowsocks 服务端。\n\n<!-- more -->\n\n## 购买 VPS 服务器\n\n  主流的 VPS（虚拟主机）服务器提供商有三家：\n\n*   linode\n*   digital ocean\n*   bandwagon\n\n下面的比上面的便宜。如果只是自用，bandwagon 足够。\n\n一般使用 paypal 绑定一个 visa 或 mastercard 信用卡来付款。注意要用国际 paypal 帐号，国内的是不能用外币付款的。\n\n在 bandwagon 购买 VPS 以后会获得一个主机地址和用于 ssh 登录的 root 密码。\n\n## 远程登陆 VPS\n\n  Mac或 Linux 下直接在终端中ssh root@your_vps_ip your_ssh_port即可。\n在 windows 系统下需要专门的客户端来 SSH 登录 VPS。在&nbsp;[xShell 官网](http://www.netsarang.com/download/down_form.html?code=522&amp;utm_source=textarea.com&amp;utm_medium=textarea.com&amp;utm_campaign=article)&nbsp;&nbsp;下载 xShell。\n\n  家庭和学校用户可以免费试用，下载时选择 home&nbsp;and&nbsp;school&nbsp;use 即可。需要用邮箱注册一下，下载链接会发送到邮箱中。\n\n  xShell 中新建一个连接，会要求输入目标 IP 地址和端口，以及 root 密码，按提示操作即可。\n\n## 安装 shadowsocks\n\n最好是centos7\n\n1.安装pip\n\n由于安装的是python 版本的 shadowsocks，所以首先安装pip\n\n\t$ curl \"https://bootstrap.pypa.io/get-pip.py\" -o \"get-pip.py\"\n\t\n\t$ python get-pip.py\n\n2.安装shadowsocks\t\n\n\t$ pip install --upgrade pip\n\t\n\t$ pip install shadowsocks\n\n3.创建配置文件\n\n\t创建文件所在目录:/etc\n\n创建文件命令\n\n\t$ vi /etc/shadowsocks.json\n\n若进入了etc目录\n\n\t$ vi shadowsocks.json\n\n配置文件内容：\n\n单端口：\n\n```\n{\n\n \"server\":\"0.0.0.0\", --服务器IP，直接用0.0.0.0也可\n\n \"server_port\":8888, --端口端口\n\n \"local_address\": \"127.0.0.1\", --本地地址，可省略\n\n \"local_port\":1080,--本地端口，可省略\n\n \"password\":\"password\",--密码\n\n \"timeout\":300, --超时时间，可省略\n\n \"method\":\"aes-256-cfb\", --加密策略，有多重策略，具体自查\n\n}\n```\n\n多端口：\n\n```\n{\n\n \"server\":\"0.0.0.0\",\n\n \"local_address\":\"127.0.0.1\",\n\n \"local_port\":1080,\n\n \"port_password\":{--每个端口对应一个密码\n\n \"1111\":\"password1\",\n\n \"1112\":\"password2\",\n\n \"1113\":\"password3\"\n\n },\n\n \"timeout\":300,\n\n \"method\":\"aes-256-cfb\",\n\n \"fast_open\":false\n\n}\n```\n\n4.启动shadowsocks\n\n启动\n\n\tssserver -c /etc/shadowsocks.json -d start\n\n停止\n\n\tssserver -c /etc/shadowsocks.json -d stop\n\n重启\n\n\tssserver -c /etc/shadowsocks.json -d restart\n\n启动成功即可通过ss客户端使用。\n\n在window端可以在控制台通过以下命令查看端口是否打开\n\n\ttelnet {ip} {port}\n\n5.配置自启动\n\n\t新建启动脚本文件/etc/systemd/system/shadowsocks.service，内容如下：\n\n[Unit]\n\n\tDescription=Shadowsocks\n\n[Service]\n\n\tTimeoutStartSec=0\n\t\n\tExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json\n\n[Install]\n\n\tWantedBy=multi-user.target\n\n通过以下命令注册，启动服务\n\n\t$ systemctl enable shadowsocks\n\t\n\t$ systemctl start shadowsocks\n\n启动后可以查看服务状态\n\n\t$ systemctl status shadowsocks -l\n\n若启动成功：\n\n● shadowsocks.service - Shadowsocks\n\nLoaded: loaded (/etc/systemd/system/shadowsocks.service; enabled; vendor preset: disabled)\n\nActive: active (running) since Sun 2017-08-13 18:03:41 CST; 1h 29min ago\n\nMain PID: 9567 (ssserver)\n\nCGroup: /system.slice/shadowsocks.service\n\n└─9567 /usr/bin/python2 /usr/bin/ssserver -c /etc/shadowsocks.json\n如果，服务失败，重启服务器试一下\n\n## 安装并启动 shadowsocks 客户端\n\n  shadowsocks 支持 windows、Mac&nbsp;OS&nbsp;X、Linux、Android、iOS 等多个平台。不过 iOS 由于系统对应用后台运行的限制，推荐使用客户端内嵌的浏览器科学上网，给其他应用代理时需要每过几分钟重新启动一下 app。\n\n  shadowsocks 项目 Github 主页在[这里](https://github.com/shadowsocks/shadowsocks?utm_source=textarea.com&amp;utm_medium=textarea.com&amp;utm_campaign=article)。\n\n  里面可以找到客户端下载地址。\n\n  下载安装客户端以后，只需按服务器的配置填写 IP 地址、服务器端口、本地端口（如果没有本地端口选项，就是默认的 1080）、密码、加密方式等参数，启动就可以了。\n\n  客户端支持全局代理和 PAC 代理两种方式，后者会使用一个脚本来自动检查一个网站是否在需要代理的网站列表中，自动选择直接连接或代理连接。\n\n  PAC 列表可以在线更新，但是难免有收录不全的情况。这时可以选择关闭 shadowsocks 代理（实际上是取消对系统代理的配置，shadowsocks 客户端仍然保持工作），然后使用支持自定义规则的代理管理插件来实现自动切换代理，比如 switchyOmega。\n\n## 使用 switchyOmega 实现自动切换代理\n\n\tswitchyOmega 是 chrome 浏览器上一个很好用的代理管理插件。它的前身 switchySharp 更有名。\n\t\n\tchrome 应用商店本身需要翻墙才能访问，因此需要先在 shadowsocks 启动代理模式下下载安装，再关闭 shadowsocks 代理。\n\t\n\t安装完毕后，右击 switchyOmega 图标，选择选项，进入 switchOmega 配置界面。\n\n### 创建 shadowsocks 情景模式\n\n\t新建一个情景模式，比如叫 SS，代理协议选择 socks5，代理地址为 127.0.0.1，端口 1080。\n\t\n\t现在切换到 SS 情景模式就可以通过 shadowsocks 科学上网了。后面获取自动切换规则列表\n\n### 设置自动切换模式\n\n  在设置界面选择自动切换模式，在 “切换规则” 中勾选“规则列表规则”，对应的情景模式选择刚刚新建的 SS。\n\n  然后在下面的规则列表地址中填写\n\n  https://autoproxy-gfwlist.googlecode.com/svn/trunk/gfwlist.txt\n\n  规则列表格式选择 AutoProxy。\n\n  然后点击立即更新情景模式， 更新完成后会有提示。\n\n  点击左侧的 “应用选项”。然后单击 switchyOmega 图标，选择自动切换，就可以在访问“不存在的网站” 时自动切换到 shadowsocks 代理了。\n\n### 添加自定义规则\n\n  如果遇到某个国外网站无法直接连接或速度太慢时，可以单击 switchyOmega 图标，选择 “添加条件”，情景模式选择 SS，就可以了。\n\n  这时打开 switchyOmega 选项，在自动切换模式的切换规则中就可以看到刚刚添加的规则。可以在这里管理自定义的规则。\n\n### 导入和导出 switchyOmega 设置\n\n  如果换了一台电脑，重新设置一遍 switchyOmega 就太麻烦了。可以在设置好的 switchyOmega 中导出设置文件，在另一个 chrome 浏览器中导入，就可以直接复制原来的设置了。\n\n  在 switchyOmega 选项的左侧点击 “导入 / 导出”，点击“生成备份文件” 即可生成 switchyOmega 设置备份。点击 “从备份文件恢复” 可以导入备份文件。\n","content":"<h2 id=\"shadowsocks-简介\">shadowsocks 简介<a href=\"posts/shadowsocks#shadowsocks-简介\"></a></h2><p>shadowsocks 是一款自定义协议的代理软件，由于其流量特征不明显，（直到不久前）一直可以稳定提供上网代理。</p>\n<p>shadowsocks 客户端会在本地开启一个 socks5 代理，通过此代理的网络访问请求由客户端发送至服务端，服务端发出请求，收到响应数据后再发回客户端。</p>\n<p>因此使用 shadowsocks 需要一台墙外的服务器来部署 shadowsocks 服务端。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"购买-VPS-服务器\">购买 VPS 服务器<a href=\"posts/shadowsocks#购买-VPS-服务器\"></a></h2><p>  主流的 VPS（虚拟主机）服务器提供商有三家：</p>\n<ul>\n<li>linode</li>\n<li>digital ocean</li>\n<li>bandwagon</li>\n</ul>\n<p>下面的比上面的便宜。如果只是自用，bandwagon 足够。</p>\n<p>一般使用 paypal 绑定一个 visa 或 mastercard 信用卡来付款。注意要用国际 paypal 帐号，国内的是不能用外币付款的。</p>\n<p>在 bandwagon 购买 VPS 以后会获得一个主机地址和用于 ssh 登录的 root 密码。</p>\n<h2 id=\"远程登陆-VPS\">远程登陆 VPS<a href=\"posts/shadowsocks#远程登陆-VPS\"></a></h2><p>  Mac或 Linux 下直接在终端中ssh root@your_vps_ip your_ssh_port即可。<br>在 windows 系统下需要专门的客户端来 SSH 登录 VPS。在&nbsp;<a href=\"http://www.netsarang.com/download/down_form.html?code=522&amp;utm_source=textarea.com&amp;utm_medium=textarea.com&amp;utm_campaign=article\" target=\"_blank\" rel=\"noopener\">xShell 官网</a>&nbsp;&nbsp;下载 xShell。</p>\n<p>  家庭和学校用户可以免费试用，下载时选择 home&nbsp;and&nbsp;school&nbsp;use 即可。需要用邮箱注册一下，下载链接会发送到邮箱中。</p>\n<p>  xShell 中新建一个连接，会要求输入目标 IP 地址和端口，以及 root 密码，按提示操作即可。</p>\n<h2 id=\"安装-shadowsocks\">安装 shadowsocks<a href=\"posts/shadowsocks#安装-shadowsocks\"></a></h2><p>最好是centos7</p>\n<p>1.安装pip</p>\n<p>由于安装的是python 版本的 shadowsocks，所以首先安装pip</p>\n<pre><code>$ curl &quot;https://bootstrap.pypa.io/get-pip.py&quot; -o &quot;get-pip.py&quot;\n\n$ python get-pip.py</code></pre><p>2.安装shadowsocks    </p>\n<pre><code>$ pip install --upgrade pip\n\n$ pip install shadowsocks</code></pre><p>3.创建配置文件</p>\n<pre><code>创建文件所在目录:/etc</code></pre><p>创建文件命令</p>\n<pre><code>$ vi /etc/shadowsocks.json</code></pre><p>若进入了etc目录</p>\n<pre><code>$ vi shadowsocks.json</code></pre><p>配置文件内容：</p>\n<p>单端口：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"string\">\"server\"</span>:<span class=\"string\">\"0.0.0.0\"</span>, <span class=\"comment\">--服务器IP，直接用0.0.0.0也可</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"string\">\"server_port\"</span>:<span class=\"number\">8888</span>, <span class=\"comment\">--端口端口</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"string\">\"local_address\"</span>: <span class=\"string\">\"127.0.0.1\"</span>, <span class=\"comment\">--本地地址，可省略</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"string\">\"local_port\"</span>:<span class=\"number\">1080</span>,<span class=\"comment\">--本地端口，可省略</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"string\">\"password\"</span>:<span class=\"string\">\"password\"</span>,<span class=\"comment\">--密码</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"string\">\"timeout\"</span>:<span class=\"number\">300</span>, <span class=\"comment\">--超时时间，可省略</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"string\">\"method\"</span>:<span class=\"string\">\"aes-256-cfb\"</span>, <span class=\"comment\">--加密策略，有多重策略，具体自查</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>多端口：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"string\">\"server\"</span>:<span class=\"string\">\"0.0.0.0\"</span>,</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"string\">\"local_address\"</span>:<span class=\"string\">\"127.0.0.1\"</span>,</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"string\">\"local_port\"</span>:<span class=\"number\">1080</span>,</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"string\">\"port_password\"</span>:&#123;--每个端口对应一个密码</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"string\">\"1111\"</span>:<span class=\"string\">\"password1\"</span>,</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"string\">\"1112\"</span>:<span class=\"string\">\"password2\"</span>,</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"string\">\"1113\"</span>:<span class=\"string\">\"password3\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"string\">\"timeout\"</span>:<span class=\"number\">300</span>,</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"string\">\"method\"</span>:<span class=\"string\">\"aes-256-cfb\"</span>,</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"string\">\"fast_open\"</span><span class=\"symbol\">:false</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>4.启动shadowsocks</p>\n<p>启动</p>\n<pre><code>ssserver -c /etc/shadowsocks.json -d start</code></pre><p>停止</p>\n<pre><code>ssserver -c /etc/shadowsocks.json -d stop</code></pre><p>重启</p>\n<pre><code>ssserver -c /etc/shadowsocks.json -d restart</code></pre><p>启动成功即可通过ss客户端使用。</p>\n<p>在window端可以在控制台通过以下命令查看端口是否打开</p>\n<pre><code>telnet {ip} {port}</code></pre><p>5.配置自启动</p>\n<pre><code>新建启动脚本文件/etc/systemd/system/shadowsocks.service，内容如下：</code></pre><p>[Unit]</p>\n<pre><code>Description=Shadowsocks</code></pre><p>[Service]</p>\n<pre><code>TimeoutStartSec=0\n\nExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json</code></pre><p>[Install]</p>\n<pre><code>WantedBy=multi-user.target</code></pre><p>通过以下命令注册，启动服务</p>\n<pre><code>$ systemctl enable shadowsocks\n\n$ systemctl start shadowsocks</code></pre><p>启动后可以查看服务状态</p>\n<pre><code>$ systemctl status shadowsocks -l</code></pre><p>若启动成功：</p>\n<p>● shadowsocks.service - Shadowsocks</p>\n<p>Loaded: loaded (/etc/systemd/system/shadowsocks.service; enabled; vendor preset: disabled)</p>\n<p>Active: active (running) since Sun 2017-08-13 18:03:41 CST; 1h 29min ago</p>\n<p>Main PID: 9567 (ssserver)</p>\n<p>CGroup: /system.slice/shadowsocks.service</p>\n<p>└─9567 /usr/bin/python2 /usr/bin/ssserver -c /etc/shadowsocks.json<br>如果，服务失败，重启服务器试一下</p>\n<h2 id=\"安装并启动-shadowsocks-客户端\">安装并启动 shadowsocks 客户端<a href=\"posts/shadowsocks#安装并启动-shadowsocks-客户端\"></a></h2><p>  shadowsocks 支持 windows、Mac&nbsp;OS&nbsp;X、Linux、Android、iOS 等多个平台。不过 iOS 由于系统对应用后台运行的限制，推荐使用客户端内嵌的浏览器科学上网，给其他应用代理时需要每过几分钟重新启动一下 app。</p>\n<p>  shadowsocks 项目 Github 主页在<a href=\"https://github.com/shadowsocks/shadowsocks?utm_source=textarea.com&amp;utm_medium=textarea.com&amp;utm_campaign=article\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n<p>  里面可以找到客户端下载地址。</p>\n<p>  下载安装客户端以后，只需按服务器的配置填写 IP 地址、服务器端口、本地端口（如果没有本地端口选项，就是默认的 1080）、密码、加密方式等参数，启动就可以了。</p>\n<p>  客户端支持全局代理和 PAC 代理两种方式，后者会使用一个脚本来自动检查一个网站是否在需要代理的网站列表中，自动选择直接连接或代理连接。</p>\n<p>  PAC 列表可以在线更新，但是难免有收录不全的情况。这时可以选择关闭 shadowsocks 代理（实际上是取消对系统代理的配置，shadowsocks 客户端仍然保持工作），然后使用支持自定义规则的代理管理插件来实现自动切换代理，比如 switchyOmega。</p>\n<h2 id=\"使用-switchyOmega-实现自动切换代理\">使用 switchyOmega 实现自动切换代理<a href=\"posts/shadowsocks#使用-switchyOmega-实现自动切换代理\"></a></h2><pre><code>switchyOmega 是 chrome 浏览器上一个很好用的代理管理插件。它的前身 switchySharp 更有名。\n\nchrome 应用商店本身需要翻墙才能访问，因此需要先在 shadowsocks 启动代理模式下下载安装，再关闭 shadowsocks 代理。\n\n安装完毕后，右击 switchyOmega 图标，选择选项，进入 switchOmega 配置界面。</code></pre><h3 id=\"创建-shadowsocks-情景模式\">创建 shadowsocks 情景模式<a href=\"posts/shadowsocks#创建-shadowsocks-情景模式\"></a></h3><pre><code>新建一个情景模式，比如叫 SS，代理协议选择 socks5，代理地址为 127.0.0.1，端口 1080。\n\n现在切换到 SS 情景模式就可以通过 shadowsocks 科学上网了。后面获取自动切换规则列表</code></pre><h3 id=\"设置自动切换模式\">设置自动切换模式<a href=\"posts/shadowsocks#设置自动切换模式\"></a></h3><p>  在设置界面选择自动切换模式，在 “切换规则” 中勾选“规则列表规则”，对应的情景模式选择刚刚新建的 SS。</p>\n<p>  然后在下面的规则列表地址中填写</p>\n<p>  <a href=\"https://autoproxy-gfwlist.googlecode.com/svn/trunk/gfwlist.txt\" target=\"_blank\" rel=\"noopener\">https://autoproxy-gfwlist.googlecode.com/svn/trunk/gfwlist.txt</a></p>\n<p>  规则列表格式选择 AutoProxy。</p>\n<p>  然后点击立即更新情景模式， 更新完成后会有提示。</p>\n<p>  点击左侧的 “应用选项”。然后单击 switchyOmega 图标，选择自动切换，就可以在访问“不存在的网站” 时自动切换到 shadowsocks 代理了。</p>\n<h3 id=\"添加自定义规则\">添加自定义规则<a href=\"posts/shadowsocks#添加自定义规则\"></a></h3><p>  如果遇到某个国外网站无法直接连接或速度太慢时，可以单击 switchyOmega 图标，选择 “添加条件”，情景模式选择 SS，就可以了。</p>\n<p>  这时打开 switchyOmega 选项，在自动切换模式的切换规则中就可以看到刚刚添加的规则。可以在这里管理自定义的规则。</p>\n<h3 id=\"导入和导出-switchyOmega-设置\">导入和导出 switchyOmega 设置<a href=\"posts/shadowsocks#导入和导出-switchyOmega-设置\"></a></h3><p>  如果换了一台电脑，重新设置一遍 switchyOmega 就太麻烦了。可以在设置好的 switchyOmega 中导出设置文件，在另一个 chrome 浏览器中导入，就可以直接复制原来的设置了。</p>\n<p>  在 switchyOmega 选项的左侧点击 “导入 / 导出”，点击“生成备份文件” 即可生成 switchyOmega 设置备份。点击 “从备份文件恢复” 可以导入备份文件。</p>\n","slug":"shadowsocks","updated":"2019-09-07T07:34:14.316Z","comments":true,"link":"posts/shadowsocks","permalink":"https://shuntan.github.io/posts/shadowsocks/","excerpt":"shadowsocks 简介shadowsocks 是一款自定义协议的代理软件，由于其流量特征不明显，（直到不久前）一直可以稳定提供上网代理。 shadowsocks 客户端会在本地开启一个 socks5 代理，通过此代理的网络访问请求由客户端发送至服务端，服务端发出请求，收到响应数据后再发回客户端。 因此使用 shadowsocks 需要一台墙外的服务器来部署 shadowsocks 服务端。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://shuntan.github.io/categories/Linux/"}],"tags":[{"name":"VPS","slug":"VPS","permalink":"https://shuntan.github.io/tags/VPS/"},{"name":"shadowsocks","slug":"shadowsocks","permalink":"https://shuntan.github.io/tags/shadowsocks/"}]},{"title":"Tag Plugins","date":"2019-05-10T04:35:58.000Z","path":"posts/Tag Plugins/","text":"FAQWelcome to tag-plugins Tag Plugin is a way to make special style contents supported by Hexo. For example, we cannot show a image with custom size in standard Markdown. And then we can use tag plugins to solve it. Hexo has a lot of tags which can help user. And Hexo also have interfaces to themes which make themes able to create their own tags. Following tags is provided by NexT: Centered Quote Include Raw Button Full Image Group Pictures Label Mermaid Note PDF Tabs Video Centered QuoteThis tag will make a quote with two lines before and after it, and text quoted will be centered. When using centered quote, if we have multi-line text, and each line has a different length, the quote won’t be symmetrical, so it’s recommended to use when only have single line text. For example before article all after article to make a summary. Usagecenter-quote.js123&#123;% centerquote %&#125;Something&#123;% endcenterquote %&#125;&lt;!-- Tag Alias --&gt;&#123;% cq %&#125;Something&#123;% endcq %&#125; Example1&#123;% cq %&#125;Elegant in code, simple in core&#123;% endcq %&#125; Elegant in code, simple in core Include RawThis tag include any raw content into your posts. Path is relative to your site source directory. Usageinclude-raw.js1&#123;% include_raw '_data/path/to/file.html' %&#125; ExampleLet’s create include-raw.html file in _data directory under site root directory with following content: 1Any &lt;strong&gt;raw content&lt;/strong&gt; may be included with this tag. Then in any post we can use this content with include_raw tag: 1&#123;% include_raw '_data/path/to/include-raw.html' %&#125;","raw":"---\ntitle: Tag Plugins\ncopyright: true\ntags:\n  - Hexo\n  - Next\ncategories:\n  - Hexo\nabbrlink: e2e5eeac\ndate: 2019-05-10 12:35:58\ntype:\nkeyword:\ntop:\ncomments:\npassword:\nthumbnail:\n---\n\n{% note info %}\n### FAQ\n**Welcome** to [tag-plugins](https://theme-next.org/docs/tag-plugins/)\n{% endnote %}\n\nTag Plugin is a way to make special style contents supported by Hexo. For example, we cannot show a image with custom size in standard Markdown. And then we can use tag plugins to solve it. [Hexo has a lot of tags](https://hexo.io/docs/tag-plugins) which can help user. And Hexo also have interfaces to themes which make themes able to create their own tags. Following tags is provided by NexT:\n\n<!--more-->\n\n* [Centered Quote](#Centered-Quote)\n* [Include Raw](#Include-Raw)\n* [Button](/docs/tag-plugins/button)\n* [Full Image](/docs/tag-plugins/full-image)\n* [Group Pictures](/docs/tag-plugins/group-pictures)\n* [Label](/docs/tag-plugins/label)\n* [Mermaid](/docs/tag-plugins/mermaid)\n* [Note](/docs/tag-plugins/note)\n* [PDF](/docs/tag-plugins/pdf)\n* [Tabs](/docs/tag-plugins/tabs)\n* [Video](/docs/tag-plugins/video)\n\n### Centered Quote\n\nThis tag will make a quote with two lines before and after it, and text quoted will be centered. When using centered quote, if we have multi-line text, and each line has a different length, the quote won't be symmetrical, so it's recommended to use when only have single line text. For example before article all after article to make a summary.\n\n#### Usage\n\n```html center-quote.js\n{% centerquote %}Something{% endcenterquote %}\n<!-- Tag Alias -->\n{% cq %}Something{% endcq %}\n```\n\n#### Example\n\n```md\n{% cq %}Elegant in code, simple in core{% endcq %}\n```\n\n{% cq %}Elegant in code, simple in core{% endcq %}\n\n### Include Raw\n\nThis tag include any raw content into your posts. Path is relative to your site source directory.\n\n#### Usage\n\n```html include-raw.js\n{% include_raw '_data/path/to/file.html' %}\n```\n\n#### Example\n\nLet's create `include-raw.html` file in `_data` directory under {% label info@site root directory %} with following content:\n\n```html\nAny <strong>raw content</strong> may be included with this tag.\n```\n\nThen in any post we can use this content with `include_raw` tag:\n\n```md\n{% include_raw '_data/path/to/include-raw.html' %}\n```\n\n{% include_raw '_data/include-raw.html' %}","content":"<div class=\"note info\">\n            <h3 id=\"FAQ\"><a href=\"posts/Tag Plugins#FAQ\" class=\"headerlink\" title=\"FAQ\"></a>FAQ</h3><p><strong>Welcome</strong> to <a href=\"https://theme-next.org/docs/tag-plugins/\" target=\"_blank\" rel=\"noopener\">tag-plugins</a></p>\n          </div>\n\n<p>Tag Plugin is a way to make special style contents supported by Hexo. For example, we cannot show a image with custom size in standard Markdown. And then we can use tag plugins to solve it. <a href=\"https://hexo.io/docs/tag-plugins\" target=\"_blank\" rel=\"noopener\">Hexo has a lot of tags</a> which can help user. And Hexo also have interfaces to themes which make themes able to create their own tags. Following tags is provided by NexT:</p>\n<a id=\"more\"></a>\n\n<ul>\n<li><a href=\"posts/Tag Plugins#Centered-Quote\">Centered Quote</a></li>\n<li><a href=\"posts/Tag Plugins#Include-Raw\">Include Raw</a></li>\n<li><a href=\"/docs/tag-plugins/button\">Button</a></li>\n<li><a href=\"/docs/tag-plugins/full-image\">Full Image</a></li>\n<li><a href=\"/docs/tag-plugins/group-pictures\">Group Pictures</a></li>\n<li><a href=\"/docs/tag-plugins/label\">Label</a></li>\n<li><a href=\"/docs/tag-plugins/mermaid\">Mermaid</a></li>\n<li><a href=\"/docs/tag-plugins/note\">Note</a></li>\n<li><a href=\"/docs/tag-plugins/pdf\">PDF</a></li>\n<li><a href=\"/docs/tag-plugins/tabs\">Tabs</a></li>\n<li><a href=\"/docs/tag-plugins/video\">Video</a></li>\n</ul>\n<h3 id=\"Centered-Quote\">Centered Quote<a href=\"posts/Tag Plugins#Centered-Quote\"></a></h3><p>This tag will make a quote with two lines before and after it, and text quoted will be centered. When using centered quote, if we have multi-line text, and each line has a different length, the quote won’t be symmetrical, so it’s recommended to use when only have single line text. For example before article all after article to make a summary.</p>\n<h4 id=\"Usage\">Usage<a href=\"posts/Tag Plugins#Usage\"></a></h4><figure class=\"highlight\"><figcaption><span>center-quote.js</span></figcaption><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% centerquote %&#125;Something&#123;% endcenterquote %&#125;</span><br><span class=\"line\"><span class=\"comment\">&lt;!-- Tag Alias --&gt;</span></span><br><span class=\"line\">&#123;% cq %&#125;Something&#123;% endcq %&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h4 id=\"Example\">Example<a href=\"posts/Tag Plugins#Example\"></a></h4><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% cq %&#125;Elegant in code, simple in core&#123;% endcq %&#125;</span><br></pre></td></tr></table></div></figure>\n\n<blockquote class=\"blockquote-center\"><p>Elegant in code, simple in core</p>\n</blockquote>\n\n<h3 id=\"Include-Raw\">Include Raw<a href=\"posts/Tag Plugins#Include-Raw\"></a></h3><p>This tag include any raw content into your posts. Path is relative to your site source directory.</p>\n<h4 id=\"Usage-1\">Usage<a href=\"posts/Tag Plugins#Usage-1\"></a></h4><figure class=\"highlight\"><figcaption><span>include-raw.js</span></figcaption><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% include_raw '_data/path/to/file.html' %&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h4 id=\"Example-1\">Example<a href=\"posts/Tag Plugins#Example-1\"></a></h4><p>Let’s create <code>include-raw.html</code> file in <code>_data</code> directory under <span class=\"label info\">site root directory</span> with following content:</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Any <span class=\"tag\">&lt;<span class=\"name\">strong</span>&gt;</span>raw content<span class=\"tag\">&lt;/<span class=\"name\">strong</span>&gt;</span> may be included with this tag.</span><br></pre></td></tr></table></div></figure>\n\n<p>Then in any post we can use this content with <code>include_raw</code> tag:</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% include<span class=\"emphasis\">_raw '_</span>data/path/to/include-raw.html' %&#125;</span><br></pre></td></tr></table></div></figure>\n\n","slug":"Tag Plugins","updated":"2019-07-14T01:23:30.547Z","comments":true,"link":"posts/Tag Plugins","permalink":"https://shuntan.github.io/posts/Tag Plugins/","excerpt":"FAQWelcome to tag-plugins Tag Plugin is a way to make special style contents supported by Hexo. For example, we cannot show a image with custom size in standard Markdown. And then we can use tag plugins to solve it. Hexo has a lot of tags which can help user. And Hexo also have interfaces to themes which make themes able to create their own tags. Following tags is provided by NexT:","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://shuntan.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://shuntan.github.io/tags/Hexo/"},{"name":"Next","slug":"Next","permalink":"https://shuntan.github.io/tags/Next/"}]},{"title":"《辐射4》二次元萌妹MOD","date":"2019-05-06T15:03:34.000Z","path":"posts/《辐射4》二次元萌妹MOD/","text":"《辐射4》二次元萌妹MOD 补丁类型：游戏MOD 整理时间：2019-05-05 大小：18.73MB 补丁制作：hiyokomod 补丁语言：多国 版本：v1.0 download 由N网作者“hiyokomod”制作的一款人物外观替换美化mod“二次元萌妹MOD”，将游戏中将游戏中多位女性NPC外观修改为二次元美少女，非常精致的面部建模和可修改项，带给每一个老冰棍！喜欢这些萌妹子就来3DM下载体验吧！ 截图 注意事项需要下载“LooksMenu捏脸菜单==&gt;点我下载”。 使用说明NMM自动安装方法：点我下载NMM 1、添加压缩包到NMM(列表中出现)； 2、双击列表安装； 3、进入游戏即可。 **手动安装方法(不推荐)：** 1、解压缩； 2、将data文件夹复制到游戏根目录； 3、用MOD管理器加载ESP； 4、进入游戏中即可。演示视频 分流 百度网盘(提取码：br93) 本地 电信网通 高速下载电信下载联通下载","raw":"---\ntitle: 《辐射4》二次元萌妹MOD\ncopyright: true\ncategories:\n  - Mod\ntags:\n  - Games\n  - PC\ntop:\ndescription: 由N网作者“hiyokomod”制作的一款人物外观替换美化mod“**二次元萌妹MOD**”，将游戏中将游戏中多位女性NPC外观修改为二次元美少女，非常精致的面部建模和可修改项，带给每一个老冰棍！喜欢这些萌妹子就来3DM下载体验吧！\nabbrlink: 8c023e79\ndate: 2019-05-06 23:03:34\ntype:\nthumbnail:\n---\n\n### 《辐射4》二次元萌妹MOD\n\n\n*   补丁类型：游戏MOD\n*   整理时间：2019-05-05\n*   大小：18.73MB\n*   补丁制作：hiyokomod\n*   补丁语言：多国\n*   版本：v1.0\n\n\n[download](http://id.ttz9.cn/thn/%E3%80%8A%E8%BE%90%E5%B0%844%E3%80%8B%E4%BA%8C%E6%AC%A1%E5%85%83%E8%90%8C%E5%A6%B9MOD_id371@371_2138610)\n\n{% blockquote %}\n由N网作者“hiyokomod”制作的一款人物外观替换美化mod“**二次元萌妹MOD**”，\n将游戏中将游戏中多位女性NPC外观修改为二次元美少女，非常精致的面部建模和可修改项，\n带给每一个老冰棍！喜欢这些萌妹子就来3DM下载体验吧！\n{% endblockquote %}\n\n<!-- more -->\n\n### 截图\n\n![《辐射4》二次元萌妹MOD](https://img.3dmgame.com/uploads/images/news/20190505/1557045450_376264.png) \n\n![《辐射4》二次元萌妹MOD](https://img.3dmgame.com/uploads/images/news/20190505/1557045450_327571.jpeg) \n\n![《辐射4》二次元萌妹MOD](https://img.3dmgame.com/uploads/images/news/20190505/1557045450_903130.jpeg) \n\n![《辐射4》二次元萌妹MOD](https://img.3dmgame.com/uploads/images/news/20190505/1557045450_319499.jpeg) \n\n![《辐射4》二次元萌妹MOD](https://img.3dmgame.com/uploads/images/news/20190505/1557045450_929840.jpeg) \n\n![《辐射4》二次元萌妹MOD](https://img.3dmgame.com/uploads/images/news/20190505/1557045450_553987.jpeg) \n\n![《辐射4》二次元萌妹MOD](https://img.3dmgame.com/uploads/images/news/20190505/1557045450_557348.jpeg) \n\n![《辐射4》二次元萌妹MOD](https://img.3dmgame.com/uploads/images/news/20190505/1557045450_140245.jpeg) \n\n![《辐射4》二次元萌妹MOD](https://img.3dmgame.com/uploads/images/news/20190505/1557045450_907658.jpeg) \n\n![《辐射4》二次元萌妹MOD](https://img.3dmgame.com/uploads/images/news/20190505/1557045450_261890.jpeg) \n\n### 注意事项\n\n需要下载“**<span style=\"color:#E53333;\">LooksMenu捏脸菜单</span>**==&gt;[点我下载](https://dl.3dmgame.com/patch/138611.html)”。\n\n### 使用说明\n\n**NMM自动安装方法：** \n[点我下载NMM](https://dl.3dmgame.com/patch/128998.html)\n\n\t1、添加压缩包到NMM(列表中出现)；\n\t\n\t2、双击列表安装；\n\t\n\t3、进入游戏即可。\n\t\n\t**手动安装方法(不推荐)：** \n\t\n\t1、解压缩；\n\t\n\t2、将data文件夹复制到游戏根目录；\n\t\n\t3、用MOD管理器加载ESP；\n\t\n\t4、进入游戏中即可。\n\n\n### 演示视频\n\n<iframe src=\"https://player.youku.com/embed/XNDE2Njc1OTM0MA==?client_id=5a73c0df8eb0d91d\" allowfullscreen=\"\" width=\"640\" height=\"480\" frameborder=\"0\">\n</iframe>\n\n<iframe src=\"https://player.youku.com/embed/XNDE2Njc2MjM2NA==?client_id=5a73c0df8eb0d91d\" allowfullscreen=\"\" width=\"640\" height=\"480\" frameborder=\"0\">\n</iframe>\n\n\n分流\n\n>[百度网盘(提取码：br93)](https://pan.baidu.com/s/1hYTBEc2DQbmP2k98JLSwkA)\n\n\n本地\n\n>[电信](http://dl1.cudown.com/buding/mod/3DMGAME-FO4AnimeRaceNanakochanmod.rar)\n[网通](http://dl1.cudown.com/buding/mod/3DMGAME-FO4AnimeRaceNanakochanmod.rar)\n\n>[高速下载](http://id.ttz9.cn/thn/%E3%80%8A%E8%BE%90%E5%B0%844%E3%80%8B%E4%BA%8C%E6%AC%A1%E5%85%83%E8%90%8C%E5%A6%B9MOD_id372@372_2138610)\n[电信下载](http://id.ttz9.cn/thn/%E3%80%8A%E8%BE%90%E5%B0%844%E3%80%8B%E4%BA%8C%E6%AC%A1%E5%85%83%E8%90%8C%E5%A6%B9MOD_id372@372_2138610)\n[联通下载](http://id.ttz9.cn/thn/%E3%80%8A%E8%BE%90%E5%B0%844%E3%80%8B%E4%BA%8C%E6%AC%A1%E5%85%83%E8%90%8C%E5%A6%B9MOD_id372@372_2138610)\n\n","content":"<h3 id=\"《辐射4》二次元萌妹MOD\">《辐射4》二次元萌妹MOD<a href=\"posts/《辐射4》二次元萌妹MOD#《辐射4》二次元萌妹MOD\"></a></h3><ul>\n<li>补丁类型：游戏MOD</li>\n<li>整理时间：2019-05-05</li>\n<li>大小：18.73MB</li>\n<li>补丁制作：hiyokomod</li>\n<li>补丁语言：多国</li>\n<li>版本：v1.0</li>\n</ul>\n<p><a href=\"http://id.ttz9.cn/thn/%E3%80%8A%E8%BE%90%E5%B0%844%E3%80%8B%E4%BA%8C%E6%AC%A1%E5%85%83%E8%90%8C%E5%A6%B9MOD_id371@371_2138610\" target=\"_blank\" rel=\"noopener\">download</a></p>\n<blockquote><p>由N网作者“hiyokomod”制作的一款人物外观替换美化mod“<strong>二次元萌妹MOD</strong>”，<br>将游戏中将游戏中多位女性NPC外观修改为二次元美少女，非常精致的面部建模和可修改项，<br>带给每一个老冰棍！喜欢这些萌妹子就来3DM下载体验吧！</p>\n</blockquote>\n\n<a id=\"more\"></a>\n\n<h3 id=\"截图\">截图<a href=\"posts/《辐射4》二次元萌妹MOD#截图\"></a></h3><p><img src=\"https://img.3dmgame.com/uploads/images/news/20190505/1557045450_376264.png\" alt=\"《辐射4》二次元萌妹MOD\" class=\"article-img\"> </p>\n<p><img src=\"https://img.3dmgame.com/uploads/images/news/20190505/1557045450_327571.jpeg\" alt=\"《辐射4》二次元萌妹MOD\" class=\"article-img\"> </p>\n<p><img src=\"https://img.3dmgame.com/uploads/images/news/20190505/1557045450_903130.jpeg\" alt=\"《辐射4》二次元萌妹MOD\" class=\"article-img\"> </p>\n<p><img src=\"https://img.3dmgame.com/uploads/images/news/20190505/1557045450_319499.jpeg\" alt=\"《辐射4》二次元萌妹MOD\" class=\"article-img\"> </p>\n<p><img src=\"https://img.3dmgame.com/uploads/images/news/20190505/1557045450_929840.jpeg\" alt=\"《辐射4》二次元萌妹MOD\" class=\"article-img\"> </p>\n<p><img src=\"https://img.3dmgame.com/uploads/images/news/20190505/1557045450_553987.jpeg\" alt=\"《辐射4》二次元萌妹MOD\" class=\"article-img\"> </p>\n<p><img src=\"https://img.3dmgame.com/uploads/images/news/20190505/1557045450_557348.jpeg\" alt=\"《辐射4》二次元萌妹MOD\" class=\"article-img\"> </p>\n<p><img src=\"https://img.3dmgame.com/uploads/images/news/20190505/1557045450_140245.jpeg\" alt=\"《辐射4》二次元萌妹MOD\" class=\"article-img\"> </p>\n<p><img src=\"https://img.3dmgame.com/uploads/images/news/20190505/1557045450_907658.jpeg\" alt=\"《辐射4》二次元萌妹MOD\" class=\"article-img\"> </p>\n<p><img src=\"https://img.3dmgame.com/uploads/images/news/20190505/1557045450_261890.jpeg\" alt=\"《辐射4》二次元萌妹MOD\" class=\"article-img\"> </p>\n<h3 id=\"注意事项\">注意事项<a href=\"posts/《辐射4》二次元萌妹MOD#注意事项\"></a></h3><p>需要下载“<strong><span style=\"color:#E53333;\">LooksMenu捏脸菜单</span></strong>==&gt;<a href=\"https://dl.3dmgame.com/patch/138611.html\" target=\"_blank\" rel=\"noopener\">点我下载</a>”。</p>\n<h3 id=\"使用说明\">使用说明<a href=\"posts/《辐射4》二次元萌妹MOD#使用说明\"></a></h3><p><strong>NMM自动安装方法：</strong><br><a href=\"https://dl.3dmgame.com/patch/128998.html\" target=\"_blank\" rel=\"noopener\">点我下载NMM</a></p>\n<pre><code>1、添加压缩包到NMM(列表中出现)；\n\n2、双击列表安装；\n\n3、进入游戏即可。\n\n**手动安装方法(不推荐)：** \n\n1、解压缩；\n\n2、将data文件夹复制到游戏根目录；\n\n3、用MOD管理器加载ESP；\n\n4、进入游戏中即可。</code></pre><h3 id=\"演示视频\">演示视频<a href=\"posts/《辐射4》二次元萌妹MOD#演示视频\"></a></h3><iframe src=\"https://player.youku.com/embed/XNDE2Njc1OTM0MA==?client_id=5a73c0df8eb0d91d\" allowfullscreen width=\"640\" height=\"480\" frameborder=\"0\">\n</iframe>\n\n<iframe src=\"https://player.youku.com/embed/XNDE2Njc2MjM2NA==?client_id=5a73c0df8eb0d91d\" allowfullscreen width=\"640\" height=\"480\" frameborder=\"0\">\n</iframe>\n\n\n<p>分流</p>\n<blockquote>\n<p><a href=\"https://pan.baidu.com/s/1hYTBEc2DQbmP2k98JLSwkA\" target=\"_blank\" rel=\"noopener\">百度网盘(提取码：br93)</a></p>\n</blockquote>\n<p>本地</p>\n<blockquote>\n<p><a href=\"http://dl1.cudown.com/buding/mod/3DMGAME-FO4AnimeRaceNanakochanmod.rar\" target=\"_blank\" rel=\"noopener\">电信</a><br><a href=\"http://dl1.cudown.com/buding/mod/3DMGAME-FO4AnimeRaceNanakochanmod.rar\" target=\"_blank\" rel=\"noopener\">网通</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"http://id.ttz9.cn/thn/%E3%80%8A%E8%BE%90%E5%B0%844%E3%80%8B%E4%BA%8C%E6%AC%A1%E5%85%83%E8%90%8C%E5%A6%B9MOD_id372@372_2138610\" target=\"_blank\" rel=\"noopener\">高速下载</a><br><a href=\"http://id.ttz9.cn/thn/%E3%80%8A%E8%BE%90%E5%B0%844%E3%80%8B%E4%BA%8C%E6%AC%A1%E5%85%83%E8%90%8C%E5%A6%B9MOD_id372@372_2138610\" target=\"_blank\" rel=\"noopener\">电信下载</a><br><a href=\"http://id.ttz9.cn/thn/%E3%80%8A%E8%BE%90%E5%B0%844%E3%80%8B%E4%BA%8C%E6%AC%A1%E5%85%83%E8%90%8C%E5%A6%B9MOD_id372@372_2138610\" target=\"_blank\" rel=\"noopener\">联通下载</a></p>\n</blockquote>\n","slug":"《辐射4》二次元萌妹MOD","updated":"2019-07-14T01:28:06.370Z","comments":true,"link":"posts/《辐射4》二次元萌妹MOD","permalink":"https://shuntan.github.io/posts/《辐射4》二次元萌妹MOD/","excerpt":"《辐射4》二次元萌妹MOD 补丁类型：游戏MOD 整理时间：2019-05-05 大小：18.73MB 补丁制作：hiyokomod 补丁语言：多国 版本：v1.0 download 由N网作者“hiyokomod”制作的一款人物外观替换美化mod“二次元萌妹MOD”，将游戏中将游戏中多位女性NPC外观修改为二次元美少女，非常精致的面部建模和可修改项，带给每一个老冰棍！喜欢这些萌妹子就来3DM下载体验吧！","categories":[{"name":"Mod","slug":"Mod","permalink":"https://shuntan.github.io/categories/Mod/"}],"tags":[{"name":"Games","slug":"Games","permalink":"https://shuntan.github.io/tags/Games/"},{"name":"PC","slug":"PC","permalink":"https://shuntan.github.io/tags/PC/"}]},{"title":"给hexo博客next主题添加背景音乐","date":"2019-05-06T13:11:05.000Z","path":"posts/给hexo博客next主题添加背景音乐/","text":"请访问我的个人博客 sourcod 我的hexo博客使用的是next主题所有次教程在next主题上修改。 修改 themes/next/layout/_macro/sidebar.swig 文件添加音乐播放器内容 在 themes/next/_config.yml 配置文件中添加歌单地址配置background_music: //music.163.com/outchain/player?type=0&amp;amp;id=2120628564&amp;amp;auto=1&amp;amp;height=66 注册网易云音乐自己研究 创建歌单自己研究 给歌单添加自己喜欢的音乐看你自己了 分享歌单不会获取外链的请上度娘: 怎么把自己的歌单做成外链 获取外链播放器 把地址copy出来height=90改成 66 这样以后只需要修改网易云音乐的歌单，博客的背景音乐就会自动修改了。 如果出现音乐不自动播放，那是资源的问题，自己上网易云音乐生成外链的页面看看会不会自动播放。把坏资源删除就OK了。 修改完我的博客的效果","raw":"---\ntitle: 给hexo博客next主题添加背景音乐\ncopyright: true\ncategories:\n  - Hexo教程\ntags:\n  - hexo\nabbrlink: 96f89d1\ndate: 2019-05-06 21:11:05\nthumbnail:\n---\n\n* 请访问我的个人博客 [sourcod](//blog.sourcod.com)\n\n> 我的hexo博客使用的是next主题所有次教程在next主题上修改。\n\n### 修改 `themes/next/layout/_macro/sidebar.swig` 文件\n\n添加音乐播放器内容 \n\n![sidebar](http://sourcod.oss-cn-beijing.aliyuncs.com/hexo/91fc7624571cb9276c6338b1c9913fa3.png)\n\n<!-- more -->\n\n### 在 `themes/next/_config.yml` 配置文件中添加歌单地址配置\n\n`background_music: //music.163.com/outchain/player?type=0&amp;id=2120628564&amp;auto=1&amp;height=66` \n\n![歌单地址配置](http://sourcod.oss-cn-beijing.aliyuncs.com/hexo/676e3e18fa9bdc5af7621bc471cc2895.png)\n\n### <a name=\"t2\"></a>注册网易云音乐\n\n自己研究\n\n### <a name=\"t3\"></a>创建歌单\n\n自己研究\n\n### <a name=\"t4\"></a>给歌单添加自己喜欢的音乐\n\n看你自己了\n\n### <a name=\"t5\"></a>分享歌单\n\n不会获取外链的请上度娘: [怎么把自己的歌单做成外链](https://jingyan.baidu.com/article/d7130635dcdf6813fdf475c7.html)\n\n### <a name=\"t6\"></a>获取外链播放器\n\n![外链播放器](http://sourcod.oss-cn-beijing.aliyuncs.com/hexo/3684d31ccbbb950e018b16113068a967.png)\n\n### <a name=\"t7\"></a>把地址copy出来`height=90`改成 `66`\n\n![外链](http://sourcod.oss-cn-beijing.aliyuncs.com/hexo/47f61ed64adaa3db93c0eceec989978e.png)\n\n> 这样以后只需要修改网易云音乐的歌单，博客的背景音乐就会自动修改了。\n> \n> 如果出现音乐不自动播放，那是资源的问题，自己上网易云音乐生成外链的页面看看会不会自动播放。把坏资源删除就OK了。\n\n* * *\n\n_修改完我的博客的效果_\n\n![博客效果](http://sourcod.oss-cn-beijing.aliyuncs.com/hexo/e10246452ccbc9a5eb5e2f2b8c5c70e7.png)","content":"<ul>\n<li>请访问我的个人博客 <a href=\"//blog.sourcod.com\">sourcod</a></li>\n</ul>\n<blockquote>\n<p>我的hexo博客使用的是next主题所有次教程在next主题上修改。</p>\n</blockquote>\n<h3 id=\"修改-themes-next-layout-macro-sidebar-swig-文件\">修改 <code>themes/next/layout/_macro/sidebar.swig</code> 文件<a href=\"posts/给hexo博客next主题添加背景音乐#修改-themes-next-layout-macro-sidebar-swig-文件\"></a></h3><p>添加音乐播放器内容 </p>\n<p><img src=\"http://sourcod.oss-cn-beijing.aliyuncs.com/hexo/91fc7624571cb9276c6338b1c9913fa3.png\" alt=\"sidebar\" class=\"article-img\"></p>\n<a id=\"more\"></a>\n\n<h3 id=\"在-themes-next-config-yml-配置文件中添加歌单地址配置\">在 <code>themes/next/_config.yml</code> 配置文件中添加歌单地址配置<a href=\"posts/给hexo博客next主题添加背景音乐#在-themes-next-config-yml-配置文件中添加歌单地址配置\"></a></h3><p><code>background_music: //music.163.com/outchain/player?type=0&amp;amp;id=2120628564&amp;amp;auto=1&amp;amp;height=66</code> </p>\n<p><img src=\"http://sourcod.oss-cn-beijing.aliyuncs.com/hexo/676e3e18fa9bdc5af7621bc471cc2895.png\" alt=\"歌单地址配置\" class=\"article-img\"></p>\n<h3 id=\"注册网易云音乐\"><a name=\"t2\"></a>注册网易云音乐<a href=\"posts/给hexo博客next主题添加背景音乐#注册网易云音乐\"></a></h3><p>自己研究</p>\n<h3 id=\"创建歌单\"><a name=\"t3\"></a>创建歌单<a href=\"posts/给hexo博客next主题添加背景音乐#创建歌单\"></a></h3><p>自己研究</p>\n<h3 id=\"给歌单添加自己喜欢的音乐\"><a name=\"t4\"></a>给歌单添加自己喜欢的音乐<a href=\"posts/给hexo博客next主题添加背景音乐#给歌单添加自己喜欢的音乐\"></a></h3><p>看你自己了</p>\n<h3 id=\"分享歌单\"><a name=\"t5\"></a>分享歌单<a href=\"posts/给hexo博客next主题添加背景音乐#分享歌单\"></a></h3><p>不会获取外链的请上度娘: <a href=\"https://jingyan.baidu.com/article/d7130635dcdf6813fdf475c7.html\" target=\"_blank\" rel=\"noopener\">怎么把自己的歌单做成外链</a></p>\n<h3 id=\"获取外链播放器\"><a name=\"t6\"></a>获取外链播放器<a href=\"posts/给hexo博客next主题添加背景音乐#获取外链播放器\"></a></h3><p><img src=\"http://sourcod.oss-cn-beijing.aliyuncs.com/hexo/3684d31ccbbb950e018b16113068a967.png\" alt=\"外链播放器\" class=\"article-img\"></p>\n<h3 id=\"把地址copy出来height-90改成-66\"><a name=\"t7\"></a>把地址copy出来<code>height=90</code>改成 <code>66</code><a href=\"posts/给hexo博客next主题添加背景音乐#把地址copy出来height-90改成-66\"></a></h3><p><img src=\"http://sourcod.oss-cn-beijing.aliyuncs.com/hexo/47f61ed64adaa3db93c0eceec989978e.png\" alt=\"外链\" class=\"article-img\"></p>\n<blockquote>\n<p>这样以后只需要修改网易云音乐的歌单，博客的背景音乐就会自动修改了。</p>\n<p>如果出现音乐不自动播放，那是资源的问题，自己上网易云音乐生成外链的页面看看会不会自动播放。把坏资源删除就OK了。</p>\n</blockquote>\n<hr>\n<p><em>修改完我的博客的效果</em></p>\n<p><img src=\"http://sourcod.oss-cn-beijing.aliyuncs.com/hexo/e10246452ccbc9a5eb5e2f2b8c5c70e7.png\" alt=\"博客效果\" class=\"article-img\"></p>\n","slug":"给hexo博客next主题添加背景音乐","updated":"2019-07-14T01:22:20.630Z","comments":true,"link":"posts/给hexo博客next主题添加背景音乐","permalink":"https://shuntan.github.io/posts/给hexo博客next主题添加背景音乐/","excerpt":"请访问我的个人博客 sourcod 我的hexo博客使用的是next主题所有次教程在next主题上修改。 修改 themes/next/layout/_macro/sidebar.swig 文件添加音乐播放器内容","categories":[{"name":"Hexo教程","slug":"Hexo教程","permalink":"https://shuntan.github.io/categories/Hexo教程/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://shuntan.github.io/tags/hexo/"}]},{"title":"问道","date":"2019-04-11T11:12:20.000Z","path":"posts/问道/","text":"游戏背景介绍鸿蒙开化之初，中州大陆昆仑之颠的鸿钧上人创立道教，并收徒三人，各授以道门绝技，三徒皆修成混元大罗金仙万劫不坏之体，分别发展出道教的人道、阐教和截教三个分支。此三徒正是人道教主太上老君、阐教教主元始天尊和截教的通天教主。 三教主秉承师父鸿钧上人教诲，广收门徒将道教流传于世。只因入道门中即可修仙，使人跳出三界之外，不在五行之中，免除生死轮回之苦，使得入道修行之人多不胜数。但修仙之道并非苦心修炼便可达成，修行路上，均要经历三百年一小劫，一千五百年一大劫的劫数。修行之人均无法避开劫数，只能根据自身道行的深浅去经历劫数。值商周两朝交替之时，恰逢修仙一千五百年仙劫，于是三教主共议封神榜，以观众仙根行浅深。然劫数难逃，封神一役，致使道门内部阐教和截教不和，修仙众人俱遭屠戮，更引来西方教派参与纷争，后因鸿钧上人亲自出面调停，终得以平息。通天教主被鸿钧上人禁制在紫霄宫昆仑之颠修行思过。时光如梭，转眼已过千年，师尊鸿钧上人外出云游，不知所踪。而通天仿佛已经习惯了这种被禁固的生活，除了每日的必做的修真炼气和静诵《黄庭》，他更多的时间总是在断崖边静静坐着。也许只有这个时刻，他才能真真实实地感觉到自己的存在，千年的苦行使他的修为倍增，同时也让他饱受了孤单和寂寞，他已经很久没有说过一句话了，很久是多久，他自己也不知道，他只知道他在等，他们都在等。.空旷的断崖边，一个人影伫立，良久，一动不动。山风劲袭，人犹如与山浑然一体，仍是一动不动，坚毅的面容毫无表情，只有明亮的双眸在黑夜印衬下寒光闪现，眺望着远方。远处，骷髅山顶，一块顽石好象动了一动，又动了一动，仿佛有了呼吸。慢慢地，顽石周围竟然忽隐忽现出着玄黄色的光芒，最终幻化为一个人形的光团，缓缓飘向山后的幽冥涧。此时，人影的苍白面容上浮现出奇怪的笑意，令人不寒而栗，他是通天。五百年后的中洲大陆。在东海渔村，世世代代以捕鱼为生的渔民有一天突然发现离他们村子不远的海面上，竟然出现一个异常美丽的仙岛。在天墉城，熙熙攘攘地街道上突然多了一些身着奇装奇服，行为举止十分可疑之人。在揽仙镇，一个平凡冷清的小镇上突然间热闹了起来，从四面八方赶来的俊男美女络绎不绝。本来平静的《问道》世界中出现各种异象和征兆，而此时，准备一探究竟的玩家，正赶往揽仙镇的途中。 [1] 截图 ipsum 下载客户端下载登录器下载 目前只提供1.60.0905版本客户端百度云下载链接🔗 百度云 密码(kq7m) 与版本对应的登录器，服务器为公益服，不做任何盈利和不具备商业性质！ 链接：https://pan.baidu.com/s/1dllSI4gk4dEjf_84bf0AZQ 提取码：bebc复制这段内容后打开百度网盘手机App，操作更方便哦 Welcome join us! 更多资讯: Deployment","raw":"---\ntitle: 问道\ncopyright: true\npassword: 123\ncategories:\n  - PC\ntags:\n  - online\n  - game\nabbrlink: a3b6fe04\ndate: 2019-04-11 19:12:20\nthumbnail: /posts/问道/90945-1527190494-850029340.jpeg\n---\n\n### 游戏背景介绍\n\n鸿蒙开化之初，中州大陆昆仑之颠的鸿钧上人创立道教，并收徒三人，各授以道门绝技，三徒皆修成混元大罗金仙万劫不坏之体，分别发展出道教的人道、阐教和截教三个分支。此三徒正是人道教主太上老君、阐教教主元始天尊和截教的通天教主。\n<!-- more -->\n三教主秉承师父鸿钧上人教诲，广收门徒将道教流传于世。只因入道门中即可修仙，使人跳出三界之外，不在五行之中，免除生死轮回之苦，使得入道修行之人多不胜数。但修仙之道并非苦心修炼便可达成，修行路上，均要经历三百年一小劫，一千五百年一大劫的劫数。修行之人均无法避开劫数，只能根据自身道行的深浅去经历劫数。值商周两朝交替之时，恰逢修仙一千五百年仙劫，于是三教主共议封神榜，以观众仙根行浅深。然劫数难逃，封神一役，致使道门内部阐教和截教不和，修仙众人俱遭屠戮，更引来西方教派参与纷争，后因鸿钧上人亲自出面调停，终得以平息。通天教主被鸿钧上人禁制在紫霄宫昆仑之颠修行思过。\n时光如梭，转眼已过千年，师尊鸿钧上人外出云游，不知所踪。而通天仿佛已经习惯了这种被禁固的生活，除了每日的必做的修真炼气和静诵《黄庭》，他更多的时间总是在断崖边静静坐着。也许只有这个时刻，他才能真真实实地感觉到自己的存在，千年的苦行使他的修为倍增，同时也让他饱受了孤单和寂寞，他已经很久没有说过一句话了，很久是多久，他自己也不知道，他只知道他在等，他们都在等。.\n空旷的断崖边，一个人影伫立，良久，一动不动。山风劲袭，人犹如与山浑然一体，仍是一动不动，坚毅的面容毫无表情，只有明亮的双眸在黑夜印衬下寒光闪现，眺望着远方。远处，骷髅山顶，一块顽石好象动了一动，又动了一动，仿佛有了呼吸。慢慢地，顽石周围竟然忽隐忽现出着玄黄色的光芒，最终幻化为一个人形的光团，缓缓飘向山后的幽冥涧。此时，人影的苍白面容上浮现出奇怪的笑意，令人不寒而栗，他是通天。\n五百年后的中洲大陆。\n在东海渔村，世世代代以捕鱼为生的渔民有一天突然发现离他们村子不远的海面上，竟然出现一个异常美丽的仙岛。\n在天墉城，熙熙攘攘地街道上突然多了一些身着奇装奇服，行为举止十分可疑之人。\n在揽仙镇，一个平凡冷清的小镇上突然间热闹了起来，从四面八方赶来的俊男美女络绎不绝。\n本来平静的《问道》世界中出现各种异象和征兆，而此时，准备一探究竟的玩家，正赶往揽仙镇的途中。 [1] \n\n### 截图\n![](/posts/问道/261557566768_.pic_hd.jpg)\n\n{% label @ipsum %}\n\n### 下载\n{% tabs Fourth unique name %}\n<!-- tab 客户端下载@text-width -->\n{% note success %}\n\n### 目前只提供1.60.0905版本客户端百度云下载链接🔗\n\n{% endnote %}\n\n{% btn https://pan.baidu.com/s/1rsdS6oiuAxoYr5wXeZr22A, 百度云 密码(kq7m), edge, kq7m %}<!-- endtab -->\n\n<!-- tab 登录器下载 -->\n{% note warning %}\n### 与版本对应的登录器，服务器为公益服，不做任何盈利和不具备商业性质！\n\n{% endnote %}\n\n链接：https://pan.baidu.com/s/1dllSI4gk4dEjf_84bf0AZQ  \n\n提取码：bebc \n复制这段内容后打开百度网盘手机App，操作更方便哦\n\n\n\n<img src=\"/posts/问道/281557578598_.pic_hd.jpg\" width = \"100px\" height = \"100px\" />\n\n<!-- endtab -->\n{% endtabs %}\n\n\n\n{% centerquote %}Welcome join us!{% endcenterquote %}\n\n\n更多资讯: [Deployment](https://hexo.io/docs/deployment.html)\n","content":"<h3 id=\"游戏背景介绍\">游戏背景介绍<a href=\"posts/问道#游戏背景介绍\"></a></h3><p>鸿蒙开化之初，中州大陆昆仑之颠的鸿钧上人创立道教，并收徒三人，各授以道门绝技，三徒皆修成混元大罗金仙万劫不坏之体，分别发展出道教的人道、阐教和截教三个分支。此三徒正是人道教主太上老君、阐教教主元始天尊和截教的通天教主。</p>\n<a id=\"more\"></a>\n<p>三教主秉承师父鸿钧上人教诲，广收门徒将道教流传于世。只因入道门中即可修仙，使人跳出三界之外，不在五行之中，免除生死轮回之苦，使得入道修行之人多不胜数。但修仙之道并非苦心修炼便可达成，修行路上，均要经历三百年一小劫，一千五百年一大劫的劫数。修行之人均无法避开劫数，只能根据自身道行的深浅去经历劫数。值商周两朝交替之时，恰逢修仙一千五百年仙劫，于是三教主共议封神榜，以观众仙根行浅深。然劫数难逃，封神一役，致使道门内部阐教和截教不和，修仙众人俱遭屠戮，更引来西方教派参与纷争，后因鸿钧上人亲自出面调停，终得以平息。通天教主被鸿钧上人禁制在紫霄宫昆仑之颠修行思过。<br>时光如梭，转眼已过千年，师尊鸿钧上人外出云游，不知所踪。而通天仿佛已经习惯了这种被禁固的生活，除了每日的必做的修真炼气和静诵《黄庭》，他更多的时间总是在断崖边静静坐着。也许只有这个时刻，他才能真真实实地感觉到自己的存在，千年的苦行使他的修为倍增，同时也让他饱受了孤单和寂寞，他已经很久没有说过一句话了，很久是多久，他自己也不知道，他只知道他在等，他们都在等。.<br>空旷的断崖边，一个人影伫立，良久，一动不动。山风劲袭，人犹如与山浑然一体，仍是一动不动，坚毅的面容毫无表情，只有明亮的双眸在黑夜印衬下寒光闪现，眺望着远方。远处，骷髅山顶，一块顽石好象动了一动，又动了一动，仿佛有了呼吸。慢慢地，顽石周围竟然忽隐忽现出着玄黄色的光芒，最终幻化为一个人形的光团，缓缓飘向山后的幽冥涧。此时，人影的苍白面容上浮现出奇怪的笑意，令人不寒而栗，他是通天。<br>五百年后的中洲大陆。<br>在东海渔村，世世代代以捕鱼为生的渔民有一天突然发现离他们村子不远的海面上，竟然出现一个异常美丽的仙岛。<br>在天墉城，熙熙攘攘地街道上突然多了一些身着奇装奇服，行为举止十分可疑之人。<br>在揽仙镇，一个平凡冷清的小镇上突然间热闹了起来，从四面八方赶来的俊男美女络绎不绝。<br>本来平静的《问道》世界中出现各种异象和征兆，而此时，准备一探究竟的玩家，正赶往揽仙镇的途中。 [1] </p>\n<h3 id=\"截图\">截图<a href=\"posts/问道#截图\"></a></h3><p><img src=\"/posts/%E9%97%AE%E9%81%93/261557566768_.pic_hd.jpg\" alt=\"\" class=\"article-img\"></p>\n<span class=\"label default\">ipsum</span>\n\n<h3 id=\"下载\">下载<a href=\"posts/问道#下载\"></a></h3><div class=\"tabs\" id=\"fourth-unique-name\"><ul class=\"nav-tabs\"><li class=\"tab active\"><a href=\"posts/问道#fourth-unique-name-1\" data-toggle=\"tab\"><i class=\"fa fa-text-width\"></i>客户端下载</a></li><li class=\"tab\"><a href=\"posts/问道#fourth-unique-name-2\" data-toggle=\"tab\">登录器下载</a></li></ul><div class=\"tab-content\"><div class=\"tab-pane active\" id=\"fourth-unique-name-1\"><div class=\"note success\">\n            <h3 id=\"目前只提供1-60-0905版本客户端百度云下载链接🔗\"><a href=\"posts/问道#目前只提供1-60-0905版本客户端百度云下载链接🔗\" class=\"headerlink\" title=\"目前只提供1.60.0905版本客户端百度云下载链接🔗\"></a>目前只提供1.60.0905版本客户端百度云下载链接🔗</h3>\n          </div>\n\n<p><a class=\"btn\" href=\"https://pan.baidu.com/s/1rsdS6oiuAxoYr5wXeZr22A\" title=\"kq7m\" target=\"_blank\" rel=\"noopener\"><i class=\"fa fa-edge\"></i>百度云 密码(kq7m)</a></p></div><div class=\"tab-pane\" id=\"fourth-unique-name-2\"><div class=\"note warning\">\n            <h3 id=\"与版本对应的登录器，服务器为公益服，不做任何盈利和不具备商业性质！\"><a href=\"posts/问道#与版本对应的登录器，服务器为公益服，不做任何盈利和不具备商业性质！\" class=\"headerlink\" title=\"与版本对应的登录器，服务器为公益服，不做任何盈利和不具备商业性质！\"></a>与版本对应的登录器，服务器为公益服，不做任何盈利和不具备商业性质！</h3>\n          </div>\n\n<p>链接：<a href=\"https://pan.baidu.com/s/1dllSI4gk4dEjf_84bf0AZQ\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1dllSI4gk4dEjf_84bf0AZQ</a>  </p>\n<p>提取码：bebc<br>复制这段内容后打开百度网盘手机App，操作更方便哦</p>\n<img src=\"/posts/问道/281557578598_.pic_hd.jpg\" width=\"100px\" height=\"100px\"></div></div></div>\n\n\n\n<blockquote class=\"blockquote-center\"><p>Welcome join us!</p>\n</blockquote>\n\n\n<p>更多资讯: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","slug":"问道","updated":"2019-09-06T11:45:03.005Z","comments":true,"link":"posts/问道","permalink":"https://shuntan.github.io/posts/问道/","excerpt":"游戏背景介绍鸿蒙开化之初，中州大陆昆仑之颠的鸿钧上人创立道教，并收徒三人，各授以道门绝技，三徒皆修成混元大罗金仙万劫不坏之体，分别发展出道教的人道、阐教和截教三个分支。此三徒正是人道教主太上老君、阐教教主元始天尊和截教的通天教主。","categories":[{"name":"PC","slug":"PC","permalink":"https://shuntan.github.io/categories/PC/"}],"tags":[{"name":"online","slug":"online","permalink":"https://shuntan.github.io/tags/online/"},{"name":"game","slug":"game","permalink":"https://shuntan.github.io/tags/game/"}]},{"title":"Hello World","date":"2018-10-24T14:19:55.904Z","path":"posts/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy 更多资讯: Deployment","raw":"---\ntitle: Hello World\ncategories:\n  - Diary\ntags:\n  - Diary\nabbrlink: 4a17b156\nthumbnail: https://uploadbeta.com/api/pictures/random/\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!--more-->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\n更多资讯: [Deployment](https://hexo.io/docs/deployment.html)\n","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Quick-Start\">Quick Start<a href=\"posts/hello-world#Quick-Start\"></a></h2><h3 id=\"Create-a-new-post\">Create a new post<a href=\"posts/hello-world#Create-a-new-post\"></a></h3><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></div></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\">Run server<a href=\"posts/hello-world#Run-server\"></a></h3><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></div></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\">Generate static files<a href=\"posts/hello-world#Generate-static-files\"></a></h3><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></div></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\">Deploy to remote sites<a href=\"posts/hello-world#Deploy-to-remote-sites\"></a></h3><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></div></figure>\n\n<p>更多资讯: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","slug":"hello-world","updated":"2019-07-14T01:20:24.132Z","comments":true,"link":"posts/hello-world","permalink":"https://shuntan.github.io/posts/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","categories":[{"name":"Diary","slug":"Diary","permalink":"https://shuntan.github.io/categories/Diary/"}],"tags":[{"name":"Diary","slug":"Diary","permalink":"https://shuntan.github.io/tags/Diary/"}]}]}