{"meta":{"title":"Shawntan's Blog","subtitle":"Segmentfault","description":"shawntan@tencent.com","author":"Shawntan","url":"https://shuntan.github.io"},"pages":[{},{},{}],"posts":[{"title":"test TOC","date":"2019-06-22T06:16:57.000Z","path":"posts/test/","text":"This is H1test H1 This is H1fftest H1 This is H2test H2 This is H3 std::mutex std::recursive_mutex std::time_mutex std::recursive_timed_mutex This is H4test H4","raw":"---\ntitle: test TOC\nabbrlink: '46e17093'\ndate: 2019-06-22 14:16:57\ncopyright: true\ntags:\ncategories:\ndescription:\n---\n\n## This is H1\n\ntest H1\n\n## This is H1ff\n\ntest H1\n\n## This is H2\n\ntest H2\n\n### This is  H3\n\n- std::mutex\n\n- std::recursive_mutex\n\n- std::time_mutex\n\n- std::recursive_timed_mutex\n\n<!-- more -->\n\n####  This is  H4\n\ntest H4\n","content":"<h2 id=\"This-is-H1\">This is H1<a href=\"post/test#This-is-H1\"></a></h2><p>test H1</p>\n<h2 id=\"This-is-H1ff\">This is H1ff<a href=\"post/test#This-is-H1ff\"></a></h2><p>test H1</p>\n<h2 id=\"This-is-H2\">This is H2<a href=\"post/test#This-is-H2\"></a></h2><p>test H2</p>\n<h3 id=\"This-is-H3\">This is  H3<a href=\"post/test#This-is-H3\"></a></h3><ul>\n<li><p>std::mutex</p>\n</li>\n<li><p>std::recursive_mutex</p>\n</li>\n<li><p>std::time_mutex</p>\n</li>\n<li><p>std::recursive_timed_mutex</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<h4 id=\"This-is-H4\">This is  H4<a href=\"post/test#This-is-H4\"></a></h4><p>test H4</p>\n","slug":"test","updated":"2019-06-30T01:36:34.197Z","comments":true,"link":"post/test","permalink":"https://shuntan.github.io/posts/test/","excerpt":"This is H1test H1 This is H1fftest H1 This is H2test H2 This is H3 std::mutex std::recursive_mutex std::time_mutex std::recursive_timed_mutex","categories":[],"tags":[]},{"title":"mutex头文件介绍","date":"2019-06-14T03:00:47.000Z","path":"posts/Mutex介绍/","text":"HeadMutex 又称互斥量，C++ 11中与 Mutex 相关的类（包括锁类型）和函数都声明在 头文件中，所以如果你需要使用 std::mutex，就必须包含 头文件。 头文件介绍ewde2e Mutex 系列类(四种) std::mutex，最基本的 Mutex 类。 std::recursive_mutex，递归 Mutex 类。 std::time_mutex，定时 Mutex 类。 std::recursive_timed_mutex，定时递归 Mutex 类。 Lock 类（两种） std::lock_guard，与 Mutex RAII 相关，方便线程对互斥量上锁。 std::unique_lock，与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。 其他类型 std::once_flag std::adopt_lock_t std::defer_lock_t std::try_to_lock_t 函数 std::try_lock，尝试同时对多个互斥量上锁。 std::lock，可以同时对多个互斥量上锁。 std::call_once，如果多个线程需要同时调用某个函数，call_once 可以保证多个线程对该函数只调用一次。 std::mutex 介绍下面以 std::mutex 为例介绍 C++11 中的互斥量用法。 std::mutex 是C++11 中最基本的互斥量，std::mutex 对象提供了独占所有权的特性——即不支持递归地对 std::mutex 对象上锁，而 std::recursive_lock 则可以递归地对互斥量对象上锁。 std::mutex 的成员函数 构造函数，std::mutex不允许拷贝构造，也不允许 move 拷贝，最初产生的 mutex 对象是处于 unlocked 状态的。 lock()，调用线程将锁住该互斥量。线程调用该函数会发生下面 3 种情况：(1). 如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁。(2). 如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。 unlock()， 解锁，释放对互斥量的所有权。 try_lock()，尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面 3 种情况，(1). 如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量。(2). 如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。 下面给出一个与 std::mutex 的小例子（参考） 1234567891011121314151617181920212223242526#include &lt;iostream&gt; // std::cout#include &lt;thread&gt; // std::thread#include &lt;mutex&gt; // std::mutexvolatile int counter(0); // non-atomic counterstd::mutex mtx; // locks access to countervoid attempt_10k_increases() &#123; for (int i=0; i&lt;10000; ++i) &#123; if (mtx.try_lock()) &#123; // only increase if currently not locked: ++counter; mtx.unlock(); &#125; &#125;&#125;int main (int argc, const char* argv[]) &#123; std::thread threads[10]; for (int i=0; i&lt;10; ++i) threads[i] = std::thread(attempt_10k_increases); for (auto&amp; th : threads) th.join(); std::cout &lt;&lt; counter &lt;&lt; \" successful increases of the counter.\\n\"; return 0;&#125; 输出结果： 123$g++ -lpthread -std=c++11 -o main *.cpp$main9012 successful increases of the counter. 可以看出有很多次mtx.try_lock()返回了false，并没有执行++counter操作。 如果把mtx.try_lock()改成mtx.lock()，则必定会阻塞其他线程。 输出结果2: 123$g++ -lpthread -std=c++11 -o main *.cpp$main100000 successful increases of the counter. std::recursive_mutex 介绍std::recursive_mutex 与 std::mutex 一样，也是一种可以被上锁的对象，但是和 std::mutex 不同的是，std::recursive_mutex 允许同一个线程对互斥量多次上锁（即递归上锁），来获得对互斥量对象的多层所有权，std::recursive_mutex 释放互斥量时需要调用与该锁层次深度相同次数的 unlock()，可理解为 lock() 次数和 unlock() 次数相同，除此之外，std::recursive_mutex 的特性和 std::mutex 大致相同。 12345678910111213141516171819202122232425#include &lt;iostream&gt; // std::cout#include &lt;thread&gt; // std::thread#include &lt;mutex&gt; // std::mutexvolatile int counter(0); // non-atomic counterstd::recursive_mutex rmtx; // locks access to countervoid attempt_1k_increases() &#123; for (int i=0; i&lt;10000; ++i) &#123; rmtx.lock(); ++counter; &#125; for (int i=0; i&lt;10000; ++i) &#123; counter-=2; rmtx.unlock(); &#125;&#125;int main (int argc, const char* argv[]) &#123; auto th = std::thread(attempt_1k_increases); th.join(); std::cout &lt;&lt; counter &lt;&lt; \" successful increases of the counter.\\n\"; return 0;&#125; 输出结果： 123$g++ -lpthread -o main *.cpp$main-10000 successful increases of the counter. std::time_mutex 介绍std::time_mutex 比 std::mutex 多了两个成员函数，try_lock_for()，try_lock_until()。 try_lock_for 函数接受一个时间范围，表示在这一段时间范围之内线程如果没有获得锁则被阻塞住（与 std::mutex 的 try_lock() 不同，try_lock 如果被调用时没有获得锁则直接返回 false），如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。 try_lock_until 函数则接受一个时间点作为参数，在指定时间点未到来之前线程如果没有获得锁则被阻塞住，如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。 下面的小例子说明了 std::time_mutex 的用法（参考）。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt; // std::cout#include &lt;chrono&gt; // std::chrono::milliseconds#include &lt;thread&gt; // std::thread#include &lt;mutex&gt; // std::timed_mutexstd::timed_mutex mtx;void fireworks() &#123; // waiting to get a lock: each thread prints \"-\" every 200ms: while (!mtx.try_lock_for(std::chrono::milliseconds(200))) &#123; std::cout &lt;&lt; \"-\"; &#125; // got a lock! - wait for 1s, then this thread prints \"*\" std::this_thread::sleep_for(std::chrono::milliseconds(1000)); std::cout &lt;&lt; \"*\\n\"; mtx.unlock();&#125;int main ()&#123; std::thread threads[10]; // spawn 10 threads: for (int i=0; i&lt;10; ++i) threads[i] = std::thread(fireworks); for (auto&amp; th : threads) th.join(); return 0;&#125; 输出结果： 线程输出*表示该线程已经正常退出，并且释放该锁。否则将每200ms尝试获取mutex🔒，直到成功为止。 std::recursive_timed_mutex 介绍和 std:recursive_mutex 与 std::mutex 的关系一样，std::recursive_timed_mutex 的特性也可以从 std::timed_mutex 推导出来，感兴趣的同鞋可以自行查阅。 ;-) std::lock_guard 介绍与 Mutex RAII 相关，方便线程对互斥量上锁。例子（参考）: 1.std::lock_guard 在构造函数中进行加锁，析构函数中进行解锁。 2.锁在多线程编程中，使用较多，因此c++11提供了lock_guard模板类；在实际编程中，我们也可以根据自己的场景编写resource_guard RAII类，避免忘掉释放资源。 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt; // std::cout#include &lt;thread&gt; // std::thread#include &lt;mutex&gt; // std::mutex, std::lock_guard#include &lt;stdexcept&gt; // std::logic_errorstd::mutex mtx;void print_even (int x) &#123; if (x%2==0) std::cout &lt;&lt; x &lt;&lt; \" is even\\n\"; else throw (std::logic_error(\"not even\"));&#125;void print_thread_id (int id) &#123; try &#123; // using a local lock_guard to lock mtx guarantees unlocking on destruction / exception: std::lock_guard&lt;std::mutex&gt; lck (mtx); print_even(id); &#125; catch (std::logic_error&amp;) &#123; std::cout &lt;&lt; \"[exception caught]\\n\"; &#125;&#125;int main ()&#123; std::thread threads[10]; // spawn 10 threads: for (int i=0; i&lt;10; ++i) threads[i] = std::thread(print_thread_id,i+1); for (auto&amp; th : threads) th.join(); return 0;&#125; 输出结果： 123456789101112$g++ -lpthread -o main *.cpp$main[exception caught]4 is even[exception caught]2 is even[exception caught]6 is even8 is even[exception caught][exception caught]10 is even std::unique_lock 介绍与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。例子（参考）： 1.类 unique_lock 是通用互斥包装器，允许延迟锁定、锁定的有时限尝试、递归锁定、所有权转移和与条件变量一同使用。 2.unique_lock比lock_guard使用更加灵活，功能更加强大。使用unique_lock需要付出更多的时间、性能成本。 12345678910111213141516171819202122232425#include &lt;iostream&gt; // std::cout#include &lt;thread&gt; // std::thread#include &lt;mutex&gt; // std::mutex, std::unique_lockstd::mutex mtx; // mutex for critical sectionvoid print_block (int n, char c) &#123; // critical section (exclusive access to std::cout signaled by lifetime of lck): std::unique_lock&lt;std::mutex&gt; lck (mtx); for (int i=0; i&lt;n; ++i) &#123; std::cout &lt;&lt; c; &#125; std::cout &lt;&lt; '\\n';&#125;int main ()&#123; std::thread th1 (print_block,50,'*'); std::thread th2 (print_block,50,'$'); th1.join(); th2.join(); return 0;&#125; 输出结果： 1234$g++ -lpthread -o main *.cpp$main**************************************************$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ 好了，本文暂时讲到这里，还剩下 std::try_lock，std::lock，std::call_once 三个函数没有讲到，留在下一篇博客中讲吧 ;-)","raw":"---\ntitle: mutex头文件介绍\ntags:\n  - C++\n  - Mutex\ncategories: C++\nthumbnail: images/background.jpg\nabbrlink: e32ad4fc\ndate: 2019-06-14 11:00:47\n---\n\n## Head\n\nMutex 又称互斥量，C++ 11中与 Mutex 相关的类（包括锁类型）和函数都声明在 <mutex> 头文件中，所以如果你需要使用 std::mutex，就必须包含 <mutex> 头文件。\n\n## <mutex> 头文件介绍\n\newde2e\t\n\n### Mutex 系列类(四种)\n\n- std::mutex，最基本的 Mutex 类。\n\n- std::recursive_mutex，递归 Mutex 类。\n\n- std::time_mutex，定时 Mutex 类。\n\n- std::recursive_timed_mutex，定时递归 Mutex 类。\n\n<!-- more -->\n\n### Lock 类（两种）\n\n- std::lock_guard，与 Mutex RAII 相关，方便线程对互斥量上锁。\n- std::unique_lock，与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。\n\n### 其他类型\n\n- std::once_flag\n- std::adopt_lock_t\n- std::defer_lock_t\n- std::try_to_lock_t\n\n## 函数\n\n- std::try_lock，尝试同时对多个互斥量上锁。\n- std::lock，可以同时对多个互斥量上锁。\n- std::call_once，如果多个线程需要同时调用某个函数，call_once 可以保证多个线程对该函数只调用一次。\n\n### std::mutex 介绍\n\n下面以 std::mutex 为例介绍 C++11 中的互斥量用法。\n\nstd::mutex 是C++11 中最基本的互斥量，std::mutex 对象提供了独占所有权的特性——即不支持递归地对 std::mutex 对象上锁，而 std::recursive_lock 则可以递归地对互斥量对象上锁。\n\n### std::mutex 的成员函数\n\n- 构造函数，std::mutex不允许拷贝构造，也不允许 move 拷贝，最初产生的 mutex 对象是处于 unlocked 状态的。\n- lock()，调用线程将锁住该互斥量。线程调用该函数会发生下面 3 种情况：(1). 如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁。(2). 如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。\n- unlock()， 解锁，释放对互斥量的所有权。\n- try_lock()，尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面 3 种情况，(1). 如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量。(2). 如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。\n\n下面给出一个与 std::mutex 的小例子（[参考](http://www.cplusplus.com/reference/mutex/mutex/try_lock/)）\n\n```c++\n#include <iostream>       // std::cout\n#include <thread>         // std::thread\n#include <mutex>          // std::mutex\n\nvolatile int counter(0); // non-atomic counter\nstd::mutex mtx;           // locks access to counter\n\nvoid attempt_10k_increases() {\n    for (int i=0; i<10000; ++i) {\n        if (mtx.try_lock()) {   // only increase if currently not locked:\n            ++counter;\n            mtx.unlock();\n        }\n    }\n}\n\nint main (int argc, const char* argv[]) {\n    std::thread threads[10];\n    for (int i=0; i<10; ++i)\n        threads[i] = std::thread(attempt_10k_increases);\n\n    for (auto& th : threads) th.join();\n    std::cout << counter << \" successful increases of the counter.\\n\";\n\n    return 0;\n}\n```\n\n输出结果：\n\n```c++\n$g++ -lpthread -std=c++11 -o main *.cpp\n$main\n9012 successful increases of the counter.\n```\n\n> 可以看出有很多次mtx.try_lock()返回了false，并没有执行++counter操作。\n>\n> 如果把mtx.try_lock()改成mtx.lock()，则必定会阻塞其他线程。\n\n输出结果2:\n\n```c++\n$g++ -lpthread -std=c++11 -o main *.cpp\n$main\n100000 successful increases of the counter.\n```\n\n## std::recursive_mutex 介绍\n\nstd::recursive_mutex 与 std::mutex 一样，也是一种可以被上锁的对象，但是和 std::mutex 不同的是，std::recursive_mutex 允许同一个线程对互斥量多次上锁（即递归上锁），来获得对互斥量对象的多层所有权，std::recursive_mutex 释放互斥量时需要调用与该锁层次深度相同次数的 unlock()，可理解为 lock() 次数和 unlock() 次数相同，除此之外，std::recursive_mutex 的特性和 std::mutex 大致相同。\n\n```c++\n#include <iostream>       // std::cout\n#include <thread>         // std::thread\n#include <mutex>          // std::mutex\n\nvolatile int counter(0); // non-atomic counter\nstd::recursive_mutex  rmtx;           // locks access to counter\n\nvoid attempt_1k_increases() {\n    for (int i=0; i<10000; ++i) {\n        rmtx.lock();   \n        ++counter; \n    }\n    for (int i=0; i<10000; ++i) { \n        counter-=2; \n        rmtx.unlock();\n    }\n}\n\nint main (int argc, const char* argv[]) {\n    auto th = std::thread(attempt_1k_increases);\n    th.join();\n    std::cout << counter << \" successful increases of the counter.\\n\";\n\n    return 0;\n}\n```\n\n输出结果：\n\n```c++\n$g++ -lpthread -o main *.cpp\n$main\n-10000 successful increases of the counter.\n```\n\n## std::time_mutex 介绍\n\nstd::time_mutex 比 std::mutex 多了两个成员函数，try_lock_for()，try_lock_until()。\n\ntry_lock_for 函数接受一个时间范围，表示在这一段时间范围之内线程如果没有获得锁则被阻塞住（与 std::mutex 的 try_lock() 不同，try_lock 如果被调用时没有获得锁则直接返回 false），如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。\n\ntry_lock_until 函数则接受一个时间点作为参数，在指定时间点未到来之前线程如果没有获得锁则被阻塞住，如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。\n\n下面的小例子说明了 std::time_mutex 的用法（[参考](http://www.cplusplus.com/reference/mutex/timed_mutex/try_lock_for/)）。\n\n```c++\n#include <iostream>       // std::cout\n#include <chrono>         // std::chrono::milliseconds\n#include <thread>         // std::thread\n#include <mutex>          // std::timed_mutex\n\nstd::timed_mutex mtx;\n\nvoid fireworks() {\n  // waiting to get a lock: each thread prints \"-\" every 200ms:\n  while (!mtx.try_lock_for(std::chrono::milliseconds(200))) {\n    std::cout << \"-\";\n  }\n  // got a lock! - wait for 1s, then this thread prints \"*\"\n  std::this_thread::sleep_for(std::chrono::milliseconds(1000));\n  std::cout << \"*\\n\";\n  mtx.unlock();\n}\n\nint main ()\n{\n  std::thread threads[10];\n  // spawn 10 threads:\n  for (int i=0; i<10; ++i)\n    threads[i] = std::thread(fireworks);\n\n  for (auto& th : threads) th.join();\n\n  return 0;\n}\n```\n\n输出结果：\n\n> 线程输出*表示该线程已经正常退出，并且释放该锁。否则将每200ms尝试获取mutex🔒，直到成功为止。\n\n## std::recursive_timed_mutex 介绍\n\n和 std:recursive_mutex 与 std::mutex 的关系一样，std::recursive_timed_mutex 的特性也可以从 std::timed_mutex 推导出来，感兴趣的同鞋可以自行查阅。 ;-)\n\n## std::lock_guard 介绍\n\n与 Mutex RAII 相关，方便线程对互斥量上锁。例子（[参考](http://www.cplusplus.com/reference/mutex/lock_guard/)）:\n\n* 1.std::lock_guard 在构造函数中进行加锁，析构函数中进行解锁。\n* 2.锁在多线程编程中，使用较多，因此c++11提供了lock_guard模板类；在实际编程中，我们也可以根据自己的场景编写`resource_guard` RAII类，避免忘掉释放资源。\n\n```c++\n#include <iostream>       // std::cout\n#include <thread>         // std::thread\n#include <mutex>          // std::mutex, std::lock_guard\n#include <stdexcept>      // std::logic_error\n\nstd::mutex mtx;\n\nvoid print_even (int x) {\n    if (x%2==0) std::cout << x << \" is even\\n\";\n    else throw (std::logic_error(\"not even\"));\n}\n\nvoid print_thread_id (int id) {\n    try {\n        // using a local lock_guard to lock mtx guarantees unlocking on destruction / exception:\n        std::lock_guard<std::mutex> lck (mtx);\n        print_even(id);\n    }\n    catch (std::logic_error&) {\n        std::cout << \"[exception caught]\\n\";\n    }\n}\n\nint main ()\n{\n    std::thread threads[10];\n    // spawn 10 threads:\n    for (int i=0; i<10; ++i)\n        threads[i] = std::thread(print_thread_id,i+1);\n\n    for (auto& th : threads) th.join();\n\n    return 0;\n}\n```\n\n输出结果：\n\n```c++\n$g++ -lpthread -o main *.cpp\n$main\n[exception caught]\n4 is even\n[exception caught]\n2 is even\n[exception caught]\n6 is even\n8 is even\n[exception caught]\n[exception caught]\n10 is even\n```\n\n## std::unique_lock 介绍\n\n与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。例子（[参考](http://www.cplusplus.com/reference/mutex/unique_lock/)）：\n\n* 1.类 unique_lock 是通用互斥包装器，允许`延迟锁定、锁定的有时限尝试、递归锁定、所有权转移和与条件变量一同使用`。\n* 2.unique_lock比lock_guard使用更加灵活，功能更加强大。\n  使用unique_lock需要付出更多的时间、性能成本。\n\n```c++\n#include <iostream>       // std::cout\n#include <thread>         // std::thread\n#include <mutex>          // std::mutex, std::unique_lock\n\nstd::mutex mtx;           // mutex for critical section\n\nvoid print_block (int n, char c) {\n    // critical section (exclusive access to std::cout signaled by lifetime of lck):\n    std::unique_lock<std::mutex> lck (mtx);\n    for (int i=0; i<n; ++i) {\n        std::cout << c;\n    }\n    std::cout << '\\n';\n}\n\nint main ()\n{\n    std::thread th1 (print_block,50,'*');\n    std::thread th2 (print_block,50,'$');\n\n    th1.join();\n    th2.join();\n\n    return 0;\n}\n```\n\n输出结果：\n\n```c++\n$g++ -lpthread -o main *.cpp\n$main\n**************************************************\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n```\n\n\n\n好了，本文暂时讲到这里，还剩下 std::try_lock，std::lock，std::call_once 三个函数没有讲到，留在下一篇博客中讲吧 ;-)","content":"<h2 id=\"Head\">Head<a href=\"post/Mutex介绍#Head\"></a></h2><p>Mutex 又称互斥量，C++ 11中与 Mutex 相关的类（包括锁类型）和函数都声明在 <mutex> 头文件中，所以如果你需要使用 std::mutex，就必须包含 <mutex> 头文件。</mutex></mutex></p>\n<h2 id=\"头文件介绍\"><mutex> 头文件介绍</mutex><a href=\"post/Mutex介绍#头文件介绍\"></a></h2><p>ewde2e    </p>\n<h3 id=\"Mutex-系列类-四种\">Mutex 系列类(四种)<a href=\"post/Mutex介绍#Mutex-系列类-四种\"></a></h3><ul>\n<li><p>std::mutex，最基本的 Mutex 类。</p>\n</li>\n<li><p>std::recursive_mutex，递归 Mutex 类。</p>\n</li>\n<li><p>std::time_mutex，定时 Mutex 类。</p>\n</li>\n<li><p>std::recursive_timed_mutex，定时递归 Mutex 类。</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Lock-类（两种）\">Lock 类（两种）<a href=\"post/Mutex介绍#Lock-类（两种）\"></a></h3><ul>\n<li>std::lock_guard，与 Mutex RAII 相关，方便线程对互斥量上锁。</li>\n<li>std::unique_lock，与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。</li>\n</ul>\n<h3 id=\"其他类型\">其他类型<a href=\"post/Mutex介绍#其他类型\"></a></h3><ul>\n<li>std::once_flag</li>\n<li>std::adopt_lock_t</li>\n<li>std::defer_lock_t</li>\n<li>std::try_to_lock_t</li>\n</ul>\n<h2 id=\"函数\">函数<a href=\"post/Mutex介绍#函数\"></a></h2><ul>\n<li>std::try_lock，尝试同时对多个互斥量上锁。</li>\n<li>std::lock，可以同时对多个互斥量上锁。</li>\n<li>std::call_once，如果多个线程需要同时调用某个函数，call_once 可以保证多个线程对该函数只调用一次。</li>\n</ul>\n<h3 id=\"std-mutex-介绍\">std::mutex 介绍<a href=\"post/Mutex介绍#std-mutex-介绍\"></a></h3><p>下面以 std::mutex 为例介绍 C++11 中的互斥量用法。</p>\n<p>std::mutex 是C++11 中最基本的互斥量，std::mutex 对象提供了独占所有权的特性——即不支持递归地对 std::mutex 对象上锁，而 std::recursive_lock 则可以递归地对互斥量对象上锁。</p>\n<h3 id=\"std-mutex-的成员函数\">std::mutex 的成员函数<a href=\"post/Mutex介绍#std-mutex-的成员函数\"></a></h3><ul>\n<li>构造函数，std::mutex不允许拷贝构造，也不允许 move 拷贝，最初产生的 mutex 对象是处于 unlocked 状态的。</li>\n<li>lock()，调用线程将锁住该互斥量。线程调用该函数会发生下面 3 种情况：(1). 如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁。(2). 如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。</li>\n<li>unlock()， 解锁，释放对互斥量的所有权。</li>\n<li>try_lock()，尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面 3 种情况，(1). 如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量。(2). 如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。</li>\n</ul>\n<p>下面给出一个与 std::mutex 的小例子（<a href=\"http://www.cplusplus.com/reference/mutex/mutex/try_lock/\" target=\"_blank\" rel=\"noopener\">参考</a>）</p>\n<figure class=\"highlight c++\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;       // std::cout</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt;         // std::thread</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;mutex&gt;          // std::mutex</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> <span class=\"title\">counter</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>; <span class=\"comment\">// non-atomic counter</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::mutex mtx;           <span class=\"comment\">// locks access to counter</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">attempt_10k_increases</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10000</span>; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mtx.try_lock()) &#123;   <span class=\"comment\">// only increase if currently not locked:</span></span><br><span class=\"line\">            ++counter;</span><br><span class=\"line\">            mtx.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::thread threads[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10</span>; ++i)</span><br><span class=\"line\">        threads[i] = <span class=\"built_in\">std</span>::thread(attempt_10k_increases);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; th : threads) th.join();</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; counter &lt;&lt; <span class=\"string\">\" successful increases of the counter.\\n\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight c++\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$g++ -lpthread -<span class=\"built_in\">std</span>=c++<span class=\"number\">11</span> -o main *.cpp</span><br><span class=\"line\">$main</span><br><span class=\"line\"><span class=\"number\">9012</span> successful increases of the counter.</span><br></pre></td></tr></table></div></figure>\n\n<blockquote>\n<p>可以看出有很多次mtx.try_lock()返回了false，并没有执行++counter操作。</p>\n<p>如果把mtx.try_lock()改成mtx.lock()，则必定会阻塞其他线程。</p>\n</blockquote>\n<p>输出结果2:</p>\n<figure class=\"highlight c++\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$g++ -lpthread -<span class=\"built_in\">std</span>=c++<span class=\"number\">11</span> -o main *.cpp</span><br><span class=\"line\">$main</span><br><span class=\"line\"><span class=\"number\">100000</span> successful increases of the counter.</span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"std-recursive-mutex-介绍\">std::recursive_mutex 介绍<a href=\"post/Mutex介绍#std-recursive-mutex-介绍\"></a></h2><p>std::recursive_mutex 与 std::mutex 一样，也是一种可以被上锁的对象，但是和 std::mutex 不同的是，std::recursive_mutex 允许同一个线程对互斥量多次上锁（即递归上锁），来获得对互斥量对象的多层所有权，std::recursive_mutex 释放互斥量时需要调用与该锁层次深度相同次数的 unlock()，可理解为 lock() 次数和 unlock() 次数相同，除此之外，std::recursive_mutex 的特性和 std::mutex 大致相同。</p>\n<figure class=\"highlight c++\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;       // std::cout</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt;         // std::thread</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;mutex&gt;          // std::mutex</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> <span class=\"title\">counter</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>; <span class=\"comment\">// non-atomic counter</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::recursive_mutex  rmtx;           <span class=\"comment\">// locks access to counter</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">attempt_1k_increases</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10000</span>; ++i) &#123;</span><br><span class=\"line\">        rmtx.lock();   </span><br><span class=\"line\">        ++counter; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10000</span>; ++i) &#123; </span><br><span class=\"line\">        counter-=<span class=\"number\">2</span>; </span><br><span class=\"line\">        rmtx.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> th = <span class=\"built_in\">std</span>::thread(attempt_1k_increases);</span><br><span class=\"line\">    th.join();</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; counter &lt;&lt; <span class=\"string\">\" successful increases of the counter.\\n\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight c++\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$g++ -lpthread -o main *.cpp</span><br><span class=\"line\">$main</span><br><span class=\"line\"><span class=\"number\">-10000</span> successful increases of the counter.</span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"std-time-mutex-介绍\">std::time_mutex 介绍<a href=\"post/Mutex介绍#std-time-mutex-介绍\"></a></h2><p>std::time_mutex 比 std::mutex 多了两个成员函数，try_lock_for()，try_lock_until()。</p>\n<p>try_lock_for 函数接受一个时间范围，表示在这一段时间范围之内线程如果没有获得锁则被阻塞住（与 std::mutex 的 try_lock() 不同，try_lock 如果被调用时没有获得锁则直接返回 false），如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。</p>\n<p>try_lock_until 函数则接受一个时间点作为参数，在指定时间点未到来之前线程如果没有获得锁则被阻塞住，如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。</p>\n<p>下面的小例子说明了 std::time_mutex 的用法（<a href=\"http://www.cplusplus.com/reference/mutex/timed_mutex/try_lock_for/\" target=\"_blank\" rel=\"noopener\">参考</a>）。</p>\n<figure class=\"highlight c++\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;       // std::cout</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;chrono&gt;         // std::chrono::milliseconds</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt;         // std::thread</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;mutex&gt;          // std::timed_mutex</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">std</span>::timed_mutex mtx;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fireworks</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// waiting to get a lock: each thread prints \"-\" every 200ms:</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!mtx.try_lock_for(<span class=\"built_in\">std</span>::chrono::milliseconds(<span class=\"number\">200</span>))) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"-\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// got a lock! - wait for 1s, then this thread prints \"*\"</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::this_thread::sleep_for(<span class=\"built_in\">std</span>::chrono::milliseconds(<span class=\"number\">1000</span>));</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"*\\n\"</span>;</span><br><span class=\"line\">  mtx.unlock();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::thread threads[<span class=\"number\">10</span>];</span><br><span class=\"line\">  <span class=\"comment\">// spawn 10 threads:</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10</span>; ++i)</span><br><span class=\"line\">    threads[i] = <span class=\"built_in\">std</span>::thread(fireworks);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; th : threads) th.join();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>输出结果：</p>\n<blockquote>\n<p>线程输出*表示该线程已经正常退出，并且释放该锁。否则将每200ms尝试获取mutex🔒，直到成功为止。</p>\n</blockquote>\n<h2 id=\"std-recursive-timed-mutex-介绍\">std::recursive_timed_mutex 介绍<a href=\"post/Mutex介绍#std-recursive-timed-mutex-介绍\"></a></h2><p>和 std:recursive_mutex 与 std::mutex 的关系一样，std::recursive_timed_mutex 的特性也可以从 std::timed_mutex 推导出来，感兴趣的同鞋可以自行查阅。 ;-)</p>\n<h2 id=\"std-lock-guard-介绍\">std::lock_guard 介绍<a href=\"post/Mutex介绍#std-lock-guard-介绍\"></a></h2><p>与 Mutex RAII 相关，方便线程对互斥量上锁。例子（<a href=\"http://www.cplusplus.com/reference/mutex/lock_guard/\" target=\"_blank\" rel=\"noopener\">参考</a>）:</p>\n<ul>\n<li>1.std::lock_guard 在构造函数中进行加锁，析构函数中进行解锁。</li>\n<li>2.锁在多线程编程中，使用较多，因此c++11提供了lock_guard模板类；在实际编程中，我们也可以根据自己的场景编写<code>resource_guard</code> RAII类，避免忘掉释放资源。</li>\n</ul>\n<figure class=\"highlight c++\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;       // std::cout</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt;         // std::thread</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;mutex&gt;          // std::mutex, std::lock_guard</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdexcept&gt;      // std::logic_error</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">std</span>::mutex mtx;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print_even</span> <span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x%<span class=\"number\">2</span>==<span class=\"number\">0</span>) <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; x &lt;&lt; <span class=\"string\">\" is even\\n\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">throw</span> (<span class=\"built_in\">std</span>::logic_error(<span class=\"string\">\"not even\"</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print_thread_id</span> <span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// using a local lock_guard to lock mtx guarantees unlocking on destruction / exception:</span></span><br><span class=\"line\">        <span class=\"built_in\">std</span>::lock_guard&lt;<span class=\"built_in\">std</span>::mutex&gt; lck (mtx);</span><br><span class=\"line\">        print_even(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (<span class=\"built_in\">std</span>::logic_error&amp;) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"[exception caught]\\n\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::thread threads[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"comment\">// spawn 10 threads:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10</span>; ++i)</span><br><span class=\"line\">        threads[i] = <span class=\"built_in\">std</span>::thread(print_thread_id,i+<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; th : threads) th.join();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight c++\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$g++ -lpthread -o main *.cpp</span><br><span class=\"line\">$main</span><br><span class=\"line\">[exception caught]</span><br><span class=\"line\"><span class=\"number\">4</span> is even</span><br><span class=\"line\">[exception caught]</span><br><span class=\"line\"><span class=\"number\">2</span> is even</span><br><span class=\"line\">[exception caught]</span><br><span class=\"line\"><span class=\"number\">6</span> is even</span><br><span class=\"line\"><span class=\"number\">8</span> is even</span><br><span class=\"line\">[exception caught]</span><br><span class=\"line\">[exception caught]</span><br><span class=\"line\"><span class=\"number\">10</span> is even</span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"std-unique-lock-介绍\">std::unique_lock 介绍<a href=\"post/Mutex介绍#std-unique-lock-介绍\"></a></h2><p>与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。例子（<a href=\"http://www.cplusplus.com/reference/mutex/unique_lock/\" target=\"_blank\" rel=\"noopener\">参考</a>）：</p>\n<ul>\n<li>1.类 unique_lock 是通用互斥包装器，允许<code>延迟锁定、锁定的有时限尝试、递归锁定、所有权转移和与条件变量一同使用</code>。</li>\n<li>2.unique_lock比lock_guard使用更加灵活，功能更加强大。<br>使用unique_lock需要付出更多的时间、性能成本。</li>\n</ul>\n<figure class=\"highlight c++\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;       // std::cout</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt;         // std::thread</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;mutex&gt;          // std::mutex, std::unique_lock</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">std</span>::mutex mtx;           <span class=\"comment\">// mutex for critical section</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print_block</span> <span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">char</span> c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// critical section (exclusive access to std::cout signaled by lifetime of lck):</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::unique_lock&lt;<span class=\"built_in\">std</span>::mutex&gt; lck (mtx);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n; ++i) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"function\">thread <span class=\"title\">th1</span> <span class=\"params\">(print_block,<span class=\"number\">50</span>,<span class=\"string\">'*'</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"function\">thread <span class=\"title\">th2</span> <span class=\"params\">(print_block,<span class=\"number\">50</span>,<span class=\"string\">'$'</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    th1.join();</span><br><span class=\"line\">    th2.join();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight c++\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$g++ -lpthread -o main *.cpp</span><br><span class=\"line\">$main</span><br><span class=\"line\">**************************************************</span><br><span class=\"line\">$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$</span><br></pre></td></tr></table></div></figure>\n\n<p>好了，本文暂时讲到这里，还剩下 std::try_lock，std::lock，std::call_once 三个函数没有讲到，留在下一篇博客中讲吧 ;-)</p>\n","slug":"Mutex介绍","updated":"2019-06-26T01:57:03.838Z","comments":true,"link":"post/Mutex介绍","permalink":"https://shuntan.github.io/posts/Mutex介绍/","excerpt":"HeadMutex 又称互斥量，C++ 11中与 Mutex 相关的类（包括锁类型）和函数都声明在 头文件中，所以如果你需要使用 std::mutex，就必须包含 头文件。 头文件介绍ewde2e Mutex 系列类(四种) std::mutex，最基本的 Mutex 类。 std::recursive_mutex，递归 Mutex 类。 std::time_mutex，定时 Mutex 类。 std::recursive_timed_mutex，定时递归 Mutex 类。","categories":[{"name":"C++","slug":"C","permalink":"https://shuntan.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://shuntan.github.io/tags/C/"},{"name":"Mutex","slug":"Mutex","permalink":"https://shuntan.github.io/tags/Mutex/"}]},{"title":"squid介绍及其简单配置","date":"2019-05-15T07:15:30.000Z","path":"posts/squid/","text":"squid的概念squid是一种用来缓存Internet数据的软件。接受来自人们需要下载的目标（object）的请求并适当的处理这些请求。也就是说，如果一个人想下载一web界面，他请求squid为他取得这个页面。squid随之连接到远程服务器并向这个页面发出请求。然后，squid显式地聚集数据到客户端机器，而且同时复制一份。当下一次有人需要同一页面时， squid可以简单的从磁盘中读到它，那样数据会立即传输到客户机上。 下载地址squid-cache 官网 http://www.squid-cache.org squid介绍及其简单配置 https://www.cnblogs.com/cherishry/p/5706736.html CentOS 7安装squid代理服务器 https://blog.csdn.net/ithomer/article/details/78136993 squid代理的作用 通过缓存的方式为用户提供Web访问加速 对用户的Web访问进行过滤控制 工作流程当代理服务器中有客户端需要的数据时： a.客户端向代理服务器发送数据请求； b.代理服务器检查自己的数据缓存； c.代理服务器在缓存中找到了用户想要的数据，取出数据； d.代理服务器将从缓存中取得的数据返回给客户端。 当代理服务器中没有客户端需要的数据时了： 1.客户端向代理服务器发送数据请求； 2.代理服务器检查自己的数据缓存； 3.代理服务器在缓存中没有找到用户想要的数据； 4.代理服务器向Internet 上的远端服务器发送数据请求； 5.远端服务器响应，返回相应的数据； 6.代理服务器取得远端服务器的数据，返回给客户端，并保留一份到自己的数据缓存中。 Squid代理服务器工作在TCP/IP应用层 Squid各种代理的定义正向代理标准的代理缓冲服务器一个标准的代理缓冲服务被用于缓存静态的网页到本地网络上的一台主机上（即代理服务器）。当被缓存的页面被第二次访问的时候，浏览器将直接从本地代理服务器那里获取请求数据而不再向原web站点请求数据。这样就节省了宝贵的网络带宽，而且提高了访问速度。但是，要想实现这种方式，必须在每一个内部主机的浏览器上明确指名代理服务器的IP地址和端口号。客户端上网时，每次都把请求发送给代理服务器处理,代理服务器根据请求确定是否连接到远程web服务器获取数据。如果在本地缓冲区有目标文件，则直接将文件传给用户即可。如果没有的话则先取回文件，先在本地保存一份缓冲，然后将文件发送给客户端浏览器。 透明代理缓冲服务器透明代理缓冲服务器和标准代理服务器的功能完全相同。但是，代理操作对客户端的浏览器是透明的（即不需指明代理服务器的IP和端口）。透明代理服务器阻断网络通信，并且过滤出访问外部的HTTP（80端口）流量。如果客户端的请求在本地有缓冲则将缓冲的数据直接发给用户，如果在本地没有缓冲则向远程web服务器发出请求，其余操作和标准的代理服务器完全相同。对于linux操作系统来说，透明代理使用Iptables或者Ipchains实现。因此不需要对浏览器作任何设置，所以，透明代理对于ISP（Internet服务器提供商）特别有用。 反向代理反向代理缓冲器反向代理是和前两种代理完全不同的一种代理服务。使用它可以降低原始WEB服务器的负载。反向代理服务器承担了对原始WEB服务器的静态页面的请求，防止原始服务器过载。它位于WEB服务器和Internet之间，处理所有对WEB服务器的请求，组织了WEB服务器和Internet的直接通信。如果互联网用户请求的页面在代理服务器上有缓冲的话，代理服务器直接将缓冲内容发送给用户。如果没有缓冲则先向WEB服务器发出请求，取回数据，本地缓存后再发给用户。这种方式通过降低了WEB服务器的请求数从而降低了WEB服务器的负载。 正向代理与反向代理的区别概念正向代理：对于原始服务器而言，就是客户端的代言人反向代理：对于客户端而言，就像是原始服务器 用途正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。反向代理还可以为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。另外，反向代理还可以启用高级URL策略和管理技术，从而使处于不同web服务器系统的web页面同时存在于同一个URL空间下。 安全性正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。 Squid主要组成部分服务名：squid主程序：/usr/sbin/squid配置目录：/etc/squid主配置文件：/etc/squid/squid.conf监听tcp端口号：3128默认访问日志文件：/var/log/squid/access.log squid常用配置选项/etc/squid/squid.conf 123456789101112131415http_port 3128 (还可以只监听一个IP http_port 192.168.0.1:3128)cache_mem 64MB #缓存占内存大小maximum_object_size 4096KB #最大缓存块reply_body_max_size 1024000 allow all #限定下载文件大小access_log /var/log/squid/access.log #访问日志存放的地方visible_hostname proxy.test.xom #可见的主机名cache_dir ufs /var/spool/squid 100 16 256 #ufs:缓存数据的存储格式#/var/spool/squid 缓存目录#100：缓存目录占磁盘空间大小（M）#16：缓存空间一级子目录个数#256：缓存空间二级子目录个数cache_mgr webmaster@test.com #定义管理员邮箱http_access deny all #访问控制 squid中的访问控制 使用访问控制特性，可以控制在访问时根据特定的时间间隔进行缓存、访问特定站点或一组站点等等。squid访问控制有两个要素：ACL元素和访问列表。访问列表可以允许或拒绝某些用户对此服务的访问。 ACL元素类型 src：源地址（即客户机IP地址） dst：目标地址（即服务器IP地址） srcdomain：源名称（即客户机名称） dstdomain：目标名称（即服务器名称） time：一天中的时刻和一周内的一天 url_regex：URL规则表达式匹配 urlpath_regex：URL-path规则表达式匹配，略去协议和主机名 proxy_auth：通过外部程序进行用户验证 maxconn：单一IP的最大连接数 ACL格式为了使用控制功能，必须先设置ACL规则并应用。ACL声明的格式如下：注： acl_element_name 可以是任一个在ACL中定义的名称 任何两个ACL元素不能用相同的名字 每个ACL由列表值组成。当进行匹配检测的时候，多个值由逻辑或运算连接；换言之，即任一ACL元素的值被匹配，则这个ACL元素即被匹配。 并不是所有ACL元素都能使用访问列表中的全部类型 不同的ACL元素写在不同行中，squid将把他们组合在一个列表中 访问条目我们可以使用许多不同的访问条目。下面是我们常用的几个： http_access:允许HTTP访问 no_cache:定义对缓存请求的响应。访问列表的规则由一些类似’allow’或‘deny’的关键字构成，用以允许或拒绝向特定或一组ACL元素提供服务。 一个访问列表可以由多条规则组成 如果没有任何规则与访问请求匹配，默认动作将与列表中最后一条规则对应。 一个访问条目中所有元素将用逻辑与运算连接http_access Action 声明1 AND 声明2 AND 声明 OR.http_access Action 声明3多个http_accesss声明间用或运算连接，但每个访问条目的元素间用与运算连接。 列表中的规则总是遵循由上而下的顺序 这些规则按照他们的排列顺序进行匹配检测，一旦检测到匹配的规则，匹配就立即结束。 Squid.conf配置文件详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#acl all src 0.0.0.0/0.0.0.0 and http_access allow all选项定义了一个访问控制列表。详细情况参见和Squid软件#携带的文档。这里的访问控制列表允许所有对代理服务的访问，因为这里该代理是加速web服务器。acl all src 0.0.0.0/0.0.0.0 #允许所有IP访问acl manager proto http #manager url协议为httpacl localhost src 127.0.0.1/255.255.255.255 #允午本机IPacl to_localhost dst 127.0.0.1 #允午目的地址为本机IPacl Safe_ports port 80 # 允许安全更新的端口为80acl CONNECT method CONNECT #请求方法以CONNECThttp_access allow all #允许所有人使用该代理.因为这里是代理加速web服务器http_reply_access allow all #允许所有客户端使用该代理acl OverConnLimit maxconn 16 #限制每个IP最大允许16个连接，防止攻击http_access deny OverConnLimiticp_access deny all #禁止从邻居服务器缓冲内发送和接收ICP请求.miss_access allow all #允许直接更新请求ident_lookup_access deny all #禁止lookup检查DNShttp_port 8080 transparent #指定Squid监听浏览器客户请求的端口号。hierarchy_stoplist cgi-bin ? #用来强制某些特定的对象不被缓存，主要是处于安全的目的。acl QUERY urlpath_regex cgi-bin \\?cache deny QUERYcache_mem 1 GB #这是一个优化选项，增加该内存值有利于缓存。应该注意的是： #一般来说如果系统有内存，设置该值为(n/)3M。现在是3G 所以这里1Gfqdncache_size 1024 #FQDN 高速缓存大小maximum_object_size_in_memory 2 MB #允许最大的文件载入内存memory_replacement_policy heap LFUDA #动态使用最小的，移出内存cachecache_replacement_policy heap LFUDA #动态使用最小的，移出硬盘cachecache_dir ufs /home/cache 5000 32 512 #高速缓存目录 ufs 类型 使用的缓冲值最大允午1000MB空间，#32个一级目录，512个二级目录max_open_disk_fds 0 #允许最大打开文件数量,0 无限制minimum_object_size 1 KB #允午最小文件请求体大小maximum_object_size 20 MB #允午最大文件请求体大小cache_swap_low 90 #最小允许使用swap 90%cache_swap_high 95 #最多允许使用swap 95%ipcache_size 2048 # IP 地址高速缓存大小 2Mipcache_low 90 #最小允许ipcache使用swap 90%ipcache_high 95 #最大允许ipcache使用swap 90%access_log /var/log/squid/access.log squid #定义日志存放记录cache_log /var/log/squid/cache.log squidcache_store_log none #禁止store日志emulate_httpd_log on #将使Squid仿照Web服务器的格式创建访问记录。如果希望使用 #Web访问记录分析程序，就需要设置这个参数。refresh_pattern . 0 20% 4320 override-expire override-lastmod reload-into-ims ignore-reload #更新cache规则acl buggy_server url_regex ^http://.... http:// #只允许http的请求broken_posts allow buggy_serveracl apache rep_header Server ^Apache #允许apache的编码broken_vary_encoding allow apacherequest_entities off #禁止非http的标分准请求，防止攻击header_access header allow all #允许所有的http报头relaxed_header_parser on #不严格分析http报头.client_lifetime 120 minute #最大客户连接时间 120分钟cache_mgr sky@test.com #指定当缓冲出现问题时向缓冲管理者发送告警信息的地址信息。cache_effective_user squid #这里以用户squid的身份Squid服务器cache_effective_group squidicp_port 0 #指定Squid从邻居服务器缓冲内发送和接收ICP请求的端口号。 #这里设置为0是因为这里配置Squid为内部Web服务器的加速器， #所以不需要使用邻居服务器的缓冲。0是禁用# cache_peer 设置允许更新缓存的主机，因是本机所以127.0.0.1cache_peer 127.0.0.1 parent 80 0 no-query default multicast-responder no-netdb-exchangecache_peer_domain 127.0.0.1 hostname_aliases 127.0.0.1error_directory /usr/share/squid/errors/Simplify_Chinese #定义错误路径always_direct allow all # cache丢失或不存在是允许所有请求直接转发到原始服务器ignore_unknown_nameservers on #开反DNS查询，当域名地址不相同时候，禁止访问coredump_dir /var/log/squid #定义dump的目录max_filedesc 2048 #最大打开的文件描述half_closed_clients off #使Squid在当read不再返回数据时立即关闭客户端的连接。 #有时read不再返回数据是由于某些客户关闭TCP的发送数据 #而仍然保持接收数据。而Squid分辨不出TCP半关闭和完全关闭。buffered_logs on #若打开选项“buffered_logs”可以稍稍提高加速某些对日志文件的写入，该选项主要是实现优化特性。#防止天涯盗链，转嫁给百度acl tianya referer_regex -i tianyahttp_access deny tianyadeny_info tianya#阻止baidu蜘蛛acl baidu req_header User-Agent Baiduspiderhttp_access deny baidu#限制同一IP客户端的最大连接数acl OverConnLimit maxconn 128http_access deny OverConnLimit#防止被人利用为HTTP代理，设置允许访问的IP地址acl myip dst 222.18.63.37http_access deny !myip#允许本地管理acl Manager proto cache_objectacl Localhost src 127.0.0.1 222.18.63.37http_access allow Manager Localhostcachemgr_passwd 53034338 allhttp_access deny Manager#仅仅允许80端口的代理acl all src 0.0.0.0/0.0.0.0acl Safe_ports port 80 # httphttp_access deny !Safe_portshttp_access allow all#Squid信息设置visible_hostname happy.swjtu.edu.cncache_mgr ooopic2008@qq.com#基本设置cache_effective_user squidcache_effective_group squidtcp_recv_bufsize 65535 bytes#2.6的反向代理加速配置cache_peer 127.0.0.1 parent 80 0 no-query originserver#错误文档error_directory /usr/local/squid/share/errors/Simplify_Chinese#单台使用，不使用该功能icp_port 0hierarchy_stoplist cgi-bin ?acl QUERY urlpath_regex cgi-bin \\? .php .cgi .avi .wmv .rm .ram .mpg .mpeg .zip .execache deny QUERYacl apache rep_header Server ^Apachebroken_vary_encoding allow apacherefresh_pattern ^ftp: 1440 20% 10080refresh_pattern ^gopher: 1440 0% 1440refresh_pattern . 0 20% 4320cache_store_log nonepid_filename /usr/local/squid/var/logs/squid.pidemulate_httpd_log on Squid常用命令 初始化在squid.conf里配置的cache目录squid -z如果有错误提示，请检查cache目录的权限，可以更改目录权限chown -R squid:squid /cache目录 对squid.conf排错，即验证squid.conf的语法和配置squid -k parse如果在squid.conf中有语法或配置错误，这里会返回提示，若无返回，尝试启动squid 前台启动squid，并输出启动过程/usr/local/squid/sbin/squid -N -d1如果有ready to server reques相关信息，说明squid启动成功然后ctrl+c ,停止squid,并以后台运行的方式启动它 启动squid在后台运行squid -s可以使用ps -ax | grep squid 来查看squid进程是否存在 停止squidsquid -k shutdown 重新引导修改过的squid.confsquid -k reconfigure -f /XXX/squid.conf当squid进行配置更改后，可以使用该命令进行squid配置重载 把squid添加到系统启动项vim /etc/rc.local/usr/local/squid/sbin/squid -s 修改cache缓存目录的权限chown -R squid.squid /cache目录cache缓存目录根据自己的配置更改，squid用户和组是squid，squid 修改squid日志目录的权限chown -R squid.squid 定义的日志文件所在目录这一步并不是适合每一个使用squid的用户，意为让squid有权限在该目录里进行写操作 查看你的日志文档more /usr/local/squid/var/logs/access.log | grep TCP_MEM_HIT该指令可以看到在squid运行过程中，有那些文件被squid缓存到内存中，并返回给访问用户。more /usr/local/squid/var/logs/access.log | grep TCP_HIT该指令可以看到在squid运行过程中，有那些文件被squid缓存到cache目录中，并返回给访问用户。more /usr/local/squid/var/logs/access.log | grep TCP_MISS该指令可以看到在squid运行过程中，有那些文件没有被squid缓存，而是从原始服务器获取并返回给访问用户。 Squid命中率分析12/usr/local/squid/bin/squidclient -p 80 mgr:info/usr/local/squid/bin/squidclient -p 80 mgr:5min 可以看到详细的性能情况,其中PORT是你的proxy的端口，5min可以是60min取得squid运行状态信息： 1squidclient -p 80 mgr:info 取得squid内存使用情况： 1squidclient -p 80 mgr:mem 取得squid已经缓存的列表： 1squidclient -p 80 mgr:bjects. use it carefully,it may crash 取得squid的磁盘使用情况： 1squidclient -p 80 mgr:diskd 强制更新某个url： 1squidclient -p 80 -m PURGE http://www.xxx.com/xxx.php 更多的请查看：squidclient-h 或者 squidclient -p 80 mgr:查命中率： 1squidclient -h IP(具体侦听IP) -p 80(具体侦听端口) mgr:info 定期清理swap.state内无效数据123/path/to/squid/sbin/squid -k rotate -f /path/to/squid/conf_filevi /etc/crontab0 0 * * * root /usr/local/sbin/squid -k rotate -f /usr/local/etc/squid/squid1.conf 当squid应用运行了一段时间之后，cache_dir对应的swap.state文件就会变得越来越大，里面的无效接口数据越来越多，这可能影响squid的响应时间，因此需要使用squid清理swap.state里面的无效数据，减少swap.state的大小。","raw":"---\ntitle: squid介绍及其简单配置\ncopyright: true\ntags:\n  - squid\n  - proxy\ncategories:\n  - Linux\nabbrlink: 55e3d16d\ndate: 2019-05-15 15:15:30\ntype:\nkeyword:\ntop:\ncomments:\npassword:\n---\n\n## squid的概念\n\nsquid是一种用来缓存Internet数据的软件。接受来自人们需要下载的目标（object）的请求并适当的处理这些请求。也就是说，如果一个人想下载一web界面，他请求squid为他取得这个页面。squid随之连接到远程服务器并向这个页面发出请求。然后，squid显式地聚集数据到客户端机器，而且同时复制一份。当下一次有人需要同一页面时， squid可以简单的从磁盘中读到它，那样数据会立即传输到客户机上。\n\n<!-- more -->\n\n## 下载地址\n\nsquid-cache 官网 http://www.squid-cache.org\n\nsquid介绍及其简单配置 https://www.cnblogs.com/cherishry/p/5706736.html\n\nCentOS 7安装squid代理服务器 https://blog.csdn.net/ithomer/article/details/78136993\n\n## squid代理的作用\n\n*   通过缓存的方式为用户提供Web访问加速\n*   对用户的Web访问进行过滤控制\n\n## 工作流程\n\n当代理服务器中有客户端需要的数据时：\n\na.客户端向代理服务器发送数据请求；\n\nb.代理服务器检查自己的数据缓存；\n\nc.代理服务器在缓存中找到了用户想要的数据，取出数据；\n\nd.代理服务器将从缓存中取得的数据返回给客户端。\n\n当代理服务器中没有客户端需要的数据时了：\n\n1.客户端向代理服务器发送数据请求；\n\n2.代理服务器检查自己的数据缓存；\n\n3.代理服务器在缓存中没有找到用户想要的数据；\n\n4.代理服务器向Internet 上的远端服务器发送数据请求；\n\n5.远端服务器响应，返回相应的数据；\n\n6.代理服务器取得远端服务器的数据，返回给客户端，并保留一份到自己的数据缓存中。\n\n![](https://images2015.cnblogs.com/blog/872781/201607/872781-20160726112850919-758636566.jpg)\n\nSquid代理服务器工作在TCP/IP应用层\n\n![](https://images2015.cnblogs.com/blog/872781/201607/872781-20160726112935653-887103660.jpg)\n\n## Squid各种代理的定义\n\n### 正向代理\n\n#### 标准的代理缓冲服务器\n\n一个标准的代理缓冲服务被用于缓存静态的网页到本地网络上的一台主机上（即代理服务器）。当被缓存的页面被第二次访问的时候，浏览器将直接从本地代理服务器那里获取请求数据而不再向原web站点请求数据。这样就节省了宝贵的网络带宽，而且提高了访问速度。但是，要想实现这种方式，必须在每一个内部主机的浏览器上明确指名代理服务器的IP地址和端口号。客户端上网时，每次都把请求发送给代理服务器处理,代理服务器根据请求确定是否连接到远程web服务器获取数据。如果在本地缓冲区有目标文件，则直接将文件传给用户即可。如果没有的话则先取回文件，先在本地保存一份缓冲，然后将文件发送给客户端浏览器。\n\n#### 透明代理缓冲服务器\n\n透明代理缓冲服务器和标准代理服务器的功能完全相同。但是，代理操作对客户端的浏览器是透明的（即不需指明代理服务器的IP和端口）。透明代理服务器阻断网络通信，并且过滤出访问外部的HTTP（80端口）流量。如果客户端的请求在本地有缓冲则将缓冲的数据直接发给用户，如果在本地没有缓冲则向远程web服务器发出请求，其余操作和标准的代理服务器完全相同。对于linux操作系统来说，透明代理使用Iptables或者Ipchains实现。因此不需要对浏览器作任何设置，所以，透明代理对于ISP（Internet服务器提供商）特别有用。\n\n### 反向代理\n\n#### 反向代理缓冲器\n\n反向代理是和前两种代理完全不同的一种代理服务。使用它可以降低原始WEB服务器的负载。反向代理服务器承担了对原始WEB服务器的静态页面的请求，防止原始服务器过载。它位于WEB服务器和Internet之间，处理所有对WEB服务器的请求，组织了WEB服务器和Internet的直接通信。如果互联网用户请求的页面在代理服务器上有缓冲的话，代理服务器直接将缓冲内容发送给用户。如果没有缓冲则先向WEB服务器发出请求，取回数据，本地缓存后再发给用户。这种方式通过降低了WEB服务器的请求数从而降低了WEB服务器的负载。\n\n### 正向代理与反向代理的区别\n\n### 概念\n\n正向代理：对于原始服务器而言，就是客户端的代言人\n反向代理：对于客户端而言，就像是原始服务器\n\n### 用途\n\n正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。\n反向代理还可以为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。另外，反向代理还可以启用高级URL策略和管理技术，从而使处于不同web服务器系统的web页面同时存在于同一个URL空间下。\n\n### 安全性\n\n正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。\n反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。\n\n## Squid主要组成部分\n\n服务名：`squid`\n主程序：`/usr/sbin/squid`\n配置目录：`/etc/squid`\n主配置文件：`/etc/squid/squid.conf`\n监听tcp端口号：`3128`\n默认访问日志文件：`/var/log/squid/access.log`\n\n## squid常用配置选项\n\n`/etc/squid/squid.conf`\n\n```\n\nhttp_port 3128  (还可以只监听一个IP http_port 192.168.0.1:3128)\ncache_mem 64MB  #缓存占内存大小\nmaximum_object_size 4096KB  #最大缓存块\nreply_body_max_size  1024000 allow all      #限定下载文件大小\naccess_log /var/log/squid/access.log    #访问日志存放的地方\nvisible_hostname    proxy.test.xom  #可见的主机名\ncache_dir ufs /var/spool/squid  100 16 256 \n#ufs:缓存数据的存储格式\n#/var/spool/squid    缓存目录\n#100：缓存目录占磁盘空间大小（M）\n#16：缓存空间一级子目录个数\n#256：缓存空间二级子目录个数\ncache_mgr webmaster@test.com    #定义管理员邮箱\nhttp_access deny all    #访问控制\n\n```\n## squid中的访问控制\n\n  使用访问控制特性，可以控制在访问时根据特定的时间间隔进行缓存、访问特定站点或一组站点等等。squid访问控制有两个要素：ACL元素和访问列表。访问列表可以允许或拒绝某些用户对此服务的访问。\n\n### ACL元素类型\n\n*   src：源地址（即客户机IP地址）\n*   dst：目标地址（即服务器IP地址）\n*   srcdomain：源名称（即客户机名称）\n*   dstdomain：目标名称（即服务器名称）\n*   time：一天中的时刻和一周内的一天\n*   url_regex：URL规则表达式匹配\n*   urlpath_regex：URL-path规则表达式匹配，略去协议和主机名\n*   proxy_auth：通过外部程序进行用户验证\n*   maxconn：单一IP的最大连接数\n\n### ACL格式\n\n\t为了使用控制功能，必须先设置ACL规则并应用。ACL声明的格式如下：\n\n注：\n\n*   acl_element_name 可以是任一个在ACL中定义的名称\n*   任何两个ACL元素不能用相同的名字\n*   每个ACL由列表值组成。当进行匹配检测的时候，多个值由逻辑或运算连接；换言之，即任一ACL元素的值被匹配，则这个ACL元素即被匹配。\n*   并不是所有ACL元素都能使用访问列表中的全部类型\n*   不同的ACL元素写在不同行中，squid将把他们组合在一个列表中\n\n### 访问条目\n\n我们可以使用许多不同的访问条目。下面是我们常用的几个：\n\n*   http_access:允许HTTP访问\n*   no_cache:定义对缓存请求的响应。\n    访问列表的规则由一些类似'allow'或‘deny’的关键字构成，用以允许或拒绝向特定或一组ACL元素提供服务。\n\n1.  一个访问列表可以由多条规则组成\n2.  如果没有任何规则与访问请求匹配，默认动作将与列表中最后一条规则对应。\n3.  一个访问条目中所有元素将用逻辑与运算连接\n    http_access Action 声明1 AND 声明2 AND 声明 OR.\n    http_access Action 声明3\n    多个http_accesss声明间用或运算连接，但每个访问条目的元素间用与运算连接。\n4.  列表中的规则总是遵循由上而下的顺序\n5.  这些规则按照他们的排列顺序进行匹配检测，一旦检测到匹配的规则，匹配就立即结束。\n\n## Squid.conf配置文件详解\n\n```\n#acl all src 0.0.0.0/0.0.0.0 and http_access allow all选项定义了一个访问控制列表。详细情况参见和Squid软件\n#携带的文档。这里的访问控制列表允许所有对代理服务的访问，因为这里该代理是加速web服务器。\nacl all src 0.0.0.0/0.0.0.0                 #允许所有IP访问\nacl manager proto http                 #manager url协议为http\nacl localhost src 127.0.0.1/255.255.255.255  #允午本机IP\nacl to_localhost dst 127.0.0.1                 #允午目的地址为本机IP\nacl Safe_ports port 80                # 允许安全更新的端口为80\nacl CONNECT method CONNECT        #请求方法以CONNECT\nhttp_access allow all                #允许所有人使用该代理.因为这里是代理加速web服务器\nhttp_reply_access allow all                #允许所有客户端使用该代理\n\nacl OverConnLimit maxconn 16        #限制每个IP最大允许16个连接，防止攻击\nhttp_access deny OverConnLimit\n\nicp_access deny all                        #禁止从邻居服务器缓冲内发送和接收ICP请求.\nmiss_access allow all                #允许直接更新请求\nident_lookup_access deny all                                #禁止lookup检查DNS\nhttp_port 8080 transparent                                #指定Squid监听浏览器客户请求的端口号。\n\nhierarchy_stoplist cgi-bin ?                #用来强制某些特定的对象不被缓存，主要是处于安全的目的。\nacl QUERY urlpath_regex cgi-bin \\?\ncache deny QUERY\n\ncache_mem 1 GB        #这是一个优化选项，增加该内存值有利于缓存。应该注意的是：\n                     #一般来说如果系统有内存，设置该值为(n/)3M。现在是3G 所以这里1G\nfqdncache_size 1024        #FQDN 高速缓存大小\nmaximum_object_size_in_memory 2 MB        #允许最大的文件载入内存\n\nmemory_replacement_policy heap LFUDA  #动态使用最小的，移出内存cache\ncache_replacement_policy heap LFUDA         #动态使用最小的，移出硬盘cache\n\ncache_dir ufs /home/cache 5000 32 512  #高速缓存目录 ufs 类型 使用的缓冲值最大允午1000MB空间，\n#32个一级目录，512个二级目录\n\nmax_open_disk_fds 0                                 #允许最大打开文件数量,0 无限制\nminimum_object_size 1 KB                         #允午最小文件请求体大小\nmaximum_object_size 20 MB                 #允午最大文件请求体大小\n\ncache_swap_low 90                            #最小允许使用swap 90%\ncache_swap_high 95                            #最多允许使用swap 95%\n\nipcache_size 2048                                # IP 地址高速缓存大小 2M\nipcache_low 90                                #最小允许ipcache使用swap 90%\nipcache_high 95                                  #最大允许ipcache使用swap 90%\n\n\naccess_log /var/log/squid/access.log squid        #定义日志存放记录\ncache_log /var/log/squid/cache.log squid\ncache_store_log none                        #禁止store日志\n\nemulate_httpd_log on        #将使Squid仿照Web服务器的格式创建访问记录。如果希望使用\n                                #Web访问记录分析程序，就需要设置这个参数。\n\nrefresh_pattern . 0 20% 4320 override-expire override-lastmod reload-into-ims ignore-reload   #更新cache规则\n\nacl buggy_server url_regex ^http://.... http://          #只允许http的请求\nbroken_posts allow buggy_server\n\nacl apache rep_header Server ^Apache                 #允许apache的编码\nbroken_vary_encoding allow apache\n\nrequest_entities off                                        #禁止非http的标分准请求，防止攻击\nheader_access header allow all                        #允许所有的http报头\nrelaxed_header_parser on                                #不严格分析http报头.\nclient_lifetime 120 minute                                #最大客户连接时间 120分钟\n\ncache_mgr sky@test.com                        #指定当缓冲出现问题时向缓冲管理者发送告警信息的地址信息。\n\ncache_effective_user squid                        #这里以用户squid的身份Squid服务器\ncache_effective_group squid\n\nicp_port 0                       #指定Squid从邻居服务器缓冲内发送和接收ICP请求的端口号。\n                     #这里设置为0是因为这里配置Squid为内部Web服务器的加速器，\n                     #所以不需要使用邻居服务器的缓冲。0是禁用\n\n# cache_peer 设置允许更新缓存的主机，因是本机所以127.0.0.1\ncache_peer 127.0.0.1 parent 80 0 no-query default multicast-responder no-netdb-exchange\ncache_peer_domain 127.0.0.1                                 \nhostname_aliases 127.0.0.1\n\nerror_directory /usr/share/squid/errors/Simplify_Chinese        #定义错误路径\n\nalways_direct allow all                # cache丢失或不存在是允许所有请求直接转发到原始服务器\nignore_unknown_nameservers on        #开反DNS查询，当域名地址不相同时候，禁止访问\ncoredump_dir  /var/log/squid                 #定义dump的目录\n\nmax_filedesc 2048                #最大打开的文件描述\n\nhalf_closed_clients off        #使Squid在当read不再返回数据时立即关闭客户端的连接。\n                                #有时read不再返回数据是由于某些客户关闭TCP的发送数据\n                                #而仍然保持接收数据。而Squid分辨不出TCP半关闭和完全关闭。\n\nbuffered_logs on #若打开选项“buffered_logs”可以稍稍提高加速某些对日志文件的写入，该选项主要是实现优化特性。\n\n#防止天涯盗链，转嫁给百度\nacl tianya referer_regex -i tianya\nhttp_access deny tianya\ndeny_info  tianya\n#阻止baidu蜘蛛\nacl baidu req_header User-Agent Baiduspider\nhttp_access deny baidu\n#限制同一IP客户端的最大连接数\nacl OverConnLimit maxconn 128\nhttp_access deny OverConnLimit\n\n#防止被人利用为HTTP代理，设置允许访问的IP地址\nacl myip dst 222.18.63.37\nhttp_access deny !myip\n\n#允许本地管理\nacl Manager proto cache_object\nacl Localhost src 127.0.0.1 222.18.63.37\nhttp_access allow Manager Localhost\ncachemgr_passwd 53034338 all\nhttp_access deny Manager\n\n#仅仅允许80端口的代理\nacl all src 0.0.0.0/0.0.0.0\nacl Safe_ports port 80 # http\nhttp_access deny !Safe_ports\nhttp_access allow all\n\n#Squid信息设置\nvisible_hostname happy.swjtu.edu.cn\ncache_mgr  ooopic2008@qq.com\n\n#基本设置\ncache_effective_user squid\ncache_effective_group squid\ntcp_recv_bufsize 65535 bytes\n\n#2.6的反向代理加速配置\ncache_peer 127.0.0.1 parent 80 0 no-query originserver\n\n#错误文档\nerror_directory /usr/local/squid/share/errors/Simplify_Chinese\n\n#单台使用，不使用该功能\nicp_port 0\n\nhierarchy_stoplist cgi-bin ?\n\nacl QUERY urlpath_regex cgi-bin \\? .php .cgi .avi .wmv .rm .ram .mpg .mpeg .zip .exe\ncache deny QUERY\n\nacl apache rep_header Server ^Apache\nbroken_vary_encoding allow apache\n\n\nrefresh_pattern ^ftp:           1440 20%     10080\nrefresh_pattern ^gopher:        1440 0%    1440\nrefresh_pattern .             0    20%     4320\n\ncache_store_log none\npid_filename /usr/local/squid/var/logs/squid.pid\nemulate_httpd_log on\n```\n\n## Squid常用命令\n\n1.  初始化在squid.conf里配置的cache目录\n    squid -z\n    如果有错误提示，请检查cache目录的权限，可以更改目录权限\n    chown -R squid:squid /cache目录\n2.  对squid.conf排错，即验证squid.conf的语法和配置\n    squid -k parse\n    如果在squid.conf中有语法或配置错误，这里会返回提示，若无返回，尝试启动squid\n3.  前台启动squid，并输出启动过程\n    /usr/local/squid/sbin/squid -N -d1\n    如果有ready to server reques相关信息，说明squid启动成功\n    然后ctrl+c ,停止squid,并以后台运行的方式启动它\n4.  启动squid在后台运行\n    squid -s\n    可以使用ps -ax | grep squid 来查看squid进程是否存在\n5.  停止squid\n    squid -k shutdown\n6.  重新引导修改过的squid.conf\n    squid -k reconfigure -f /XXX/squid.conf\n    当squid进行配置更改后，可以使用该命令进行squid配置重载\n7.  把squid添加到系统启动项\n    vim /etc/rc.local\n    /usr/local/squid/sbin/squid -s\n8.  修改cache缓存目录的权限\n    chown -R squid.squid /cache目录\n    cache缓存目录根据自己的配置更改，squid用户和组是squid，squid\n9.  修改squid日志目录的权限\n    chown -R squid.squid 定义的日志文件所在目录\n    这一步并不是适合每一个使用squid的用户，意为让squid有权限在该目录里进行写操作\n10.  查看你的日志文档\n    more /usr/local/squid/var/logs/access.log | grep TCP_MEM_HIT\n    该指令可以看到在squid运行过程中，有那些文件被squid缓存到内存中，并返回给访问用户。\n    more /usr/local/squid/var/logs/access.log | grep TCP_HIT\n    该指令可以看到在squid运行过程中，有那些文件被squid缓存到cache目录中，并返回给访问用户。\n    more /usr/local/squid/var/logs/access.log | grep TCP_MISS\n    该指令可以看到在squid运行过程中，有那些文件没有被squid缓存，而是从原始服务器获取并返回给访问用户。\n\n## Squid命中率分析\n\n```\n/usr/local/squid/bin/squidclient -p 80 mgr:info\n/usr/local/squid/bin/squidclient -p 80 mgr:5min\n```\n可以看到详细的性能情况,其中PORT是你的proxy的端口，5min可以是60min\n取得squid运行状态信息：\n\n```\n squidclient -p 80 mgr:info\n```\n\n取得squid内存使用情况：\n\n```\nsquidclient -p 80 mgr:mem\n```\n\n取得squid已经缓存的列表：\n\n```\nsquidclient -p 80 mgr:bjects. use it carefully,it may crash\n```\n\n取得squid的磁盘使用情况：\n\n```\nsquidclient -p 80 mgr:diskd\n```\n\n强制更新某个url：\n\n```\nsquidclient -p 80 -m PURGE http://www.xxx.com/xxx.php\n```\n\n更多的请查看：squidclient-h 或者 squidclient -p 80 mgr:\n查命中率：\n\n```\nsquidclient -h IP(具体侦听IP) -p 80(具体侦听端口) mgr:info\n```\n\n## 定期清理swap.state内无效数据\n\n```\n/path/to/squid/sbin/squid -k rotate -f /path/to/squid/conf_file\nvi /etc/crontab\n0        0       *       *       *       root    /usr/local/sbin/squid -k rotate -f /usr/local/etc/squid/squid1.conf\n```\n\n当squid应用运行了一段时间之后，cache_dir对应的swap.state文件就会变得越来越大，里面的无效接口数据越来越多，这可能影响squid的响应时间，因此需要使用squid清理swap.state里面的无效数据，减少swap.state的大小。\n","content":"<h2 id=\"squid的概念\">squid的概念<a href=\"post/squid#squid的概念\"></a></h2><p>squid是一种用来缓存Internet数据的软件。接受来自人们需要下载的目标（object）的请求并适当的处理这些请求。也就是说，如果一个人想下载一web界面，他请求squid为他取得这个页面。squid随之连接到远程服务器并向这个页面发出请求。然后，squid显式地聚集数据到客户端机器，而且同时复制一份。当下一次有人需要同一页面时， squid可以简单的从磁盘中读到它，那样数据会立即传输到客户机上。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"下载地址\">下载地址<a href=\"post/squid#下载地址\"></a></h2><p>squid-cache 官网 <a href=\"http://www.squid-cache.org\" target=\"_blank\" rel=\"noopener\">http://www.squid-cache.org</a></p>\n<p>squid介绍及其简单配置 <a href=\"https://www.cnblogs.com/cherishry/p/5706736.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/cherishry/p/5706736.html</a></p>\n<p>CentOS 7安装squid代理服务器 <a href=\"https://blog.csdn.net/ithomer/article/details/78136993\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/ithomer/article/details/78136993</a></p>\n<h2 id=\"squid代理的作用\">squid代理的作用<a href=\"post/squid#squid代理的作用\"></a></h2><ul>\n<li>通过缓存的方式为用户提供Web访问加速</li>\n<li>对用户的Web访问进行过滤控制</li>\n</ul>\n<h2 id=\"工作流程\">工作流程<a href=\"post/squid#工作流程\"></a></h2><p>当代理服务器中有客户端需要的数据时：</p>\n<p>a.客户端向代理服务器发送数据请求；</p>\n<p>b.代理服务器检查自己的数据缓存；</p>\n<p>c.代理服务器在缓存中找到了用户想要的数据，取出数据；</p>\n<p>d.代理服务器将从缓存中取得的数据返回给客户端。</p>\n<p>当代理服务器中没有客户端需要的数据时了：</p>\n<p>1.客户端向代理服务器发送数据请求；</p>\n<p>2.代理服务器检查自己的数据缓存；</p>\n<p>3.代理服务器在缓存中没有找到用户想要的数据；</p>\n<p>4.代理服务器向Internet 上的远端服务器发送数据请求；</p>\n<p>5.远端服务器响应，返回相应的数据；</p>\n<p>6.代理服务器取得远端服务器的数据，返回给客户端，并保留一份到自己的数据缓存中。</p>\n<div class=\"article-img\"><p><img src=\"https://images2015.cnblogs.com/blog/872781/201607/872781-20160726112850919-758636566.jpg\" alt=\"\" data-zoomable=\"\"></p></div>\n<p>Squid代理服务器工作在TCP/IP应用层</p>\n<div class=\"article-img\"><p><img src=\"https://images2015.cnblogs.com/blog/872781/201607/872781-20160726112935653-887103660.jpg\" alt=\"\" data-zoomable=\"\"></p></div>\n<h2 id=\"Squid各种代理的定义\">Squid各种代理的定义<a href=\"post/squid#Squid各种代理的定义\"></a></h2><h3 id=\"正向代理\">正向代理<a href=\"post/squid#正向代理\"></a></h3><h4 id=\"标准的代理缓冲服务器\">标准的代理缓冲服务器<a href=\"post/squid#标准的代理缓冲服务器\"></a></h4><p>一个标准的代理缓冲服务被用于缓存静态的网页到本地网络上的一台主机上（即代理服务器）。当被缓存的页面被第二次访问的时候，浏览器将直接从本地代理服务器那里获取请求数据而不再向原web站点请求数据。这样就节省了宝贵的网络带宽，而且提高了访问速度。但是，要想实现这种方式，必须在每一个内部主机的浏览器上明确指名代理服务器的IP地址和端口号。客户端上网时，每次都把请求发送给代理服务器处理,代理服务器根据请求确定是否连接到远程web服务器获取数据。如果在本地缓冲区有目标文件，则直接将文件传给用户即可。如果没有的话则先取回文件，先在本地保存一份缓冲，然后将文件发送给客户端浏览器。</p>\n<h4 id=\"透明代理缓冲服务器\">透明代理缓冲服务器<a href=\"post/squid#透明代理缓冲服务器\"></a></h4><p>透明代理缓冲服务器和标准代理服务器的功能完全相同。但是，代理操作对客户端的浏览器是透明的（即不需指明代理服务器的IP和端口）。透明代理服务器阻断网络通信，并且过滤出访问外部的HTTP（80端口）流量。如果客户端的请求在本地有缓冲则将缓冲的数据直接发给用户，如果在本地没有缓冲则向远程web服务器发出请求，其余操作和标准的代理服务器完全相同。对于linux操作系统来说，透明代理使用Iptables或者Ipchains实现。因此不需要对浏览器作任何设置，所以，透明代理对于ISP（Internet服务器提供商）特别有用。</p>\n<h3 id=\"反向代理\">反向代理<a href=\"post/squid#反向代理\"></a></h3><h4 id=\"反向代理缓冲器\">反向代理缓冲器<a href=\"post/squid#反向代理缓冲器\"></a></h4><p>反向代理是和前两种代理完全不同的一种代理服务。使用它可以降低原始WEB服务器的负载。反向代理服务器承担了对原始WEB服务器的静态页面的请求，防止原始服务器过载。它位于WEB服务器和Internet之间，处理所有对WEB服务器的请求，组织了WEB服务器和Internet的直接通信。如果互联网用户请求的页面在代理服务器上有缓冲的话，代理服务器直接将缓冲内容发送给用户。如果没有缓冲则先向WEB服务器发出请求，取回数据，本地缓存后再发给用户。这种方式通过降低了WEB服务器的请求数从而降低了WEB服务器的负载。</p>\n<h3 id=\"正向代理与反向代理的区别\">正向代理与反向代理的区别<a href=\"post/squid#正向代理与反向代理的区别\"></a></h3><h3 id=\"概念\">概念<a href=\"post/squid#概念\"></a></h3><p>正向代理：对于原始服务器而言，就是客户端的代言人<br>反向代理：对于客户端而言，就像是原始服务器</p>\n<h3 id=\"用途\">用途<a href=\"post/squid#用途\"></a></h3><p>正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。<br>反向代理还可以为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。另外，反向代理还可以启用高级URL策略和管理技术，从而使处于不同web服务器系统的web页面同时存在于同一个URL空间下。</p>\n<h3 id=\"安全性\">安全性<a href=\"post/squid#安全性\"></a></h3><p>正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。<br>反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。</p>\n<h2 id=\"Squid主要组成部分\">Squid主要组成部分<a href=\"post/squid#Squid主要组成部分\"></a></h2><p>服务名：<code>squid</code><br>主程序：<code>/usr/sbin/squid</code><br>配置目录：<code>/etc/squid</code><br>主配置文件：<code>/etc/squid/squid.conf</code><br>监听tcp端口号：<code>3128</code><br>默认访问日志文件：<code>/var/log/squid/access.log</code></p>\n<h2 id=\"squid常用配置选项\">squid常用配置选项<a href=\"post/squid#squid常用配置选项\"></a></h2><p><code>/etc/squid/squid.conf</code></p>\n<figure class=\"highlight glsl\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">http_port <span class=\"number\">3128</span>  (还可以只监听一个IP http_port <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">3128</span>)</span><br><span class=\"line\">cache_mem <span class=\"number\">64</span>MB  <span class=\"meta\">#缓存占内存大小</span></span><br><span class=\"line\">maximum_object_size <span class=\"number\">4096</span>KB  <span class=\"meta\">#最大缓存块</span></span><br><span class=\"line\">reply_body_max_size  <span class=\"number\">1024000</span> allow <span class=\"built_in\">all</span>      <span class=\"meta\">#限定下载文件大小</span></span><br><span class=\"line\">access_log /var/<span class=\"built_in\">log</span>/squid/access.<span class=\"built_in\">log</span>    <span class=\"meta\">#访问日志存放的地方</span></span><br><span class=\"line\">visible_hostname    proxy.test.xom  <span class=\"meta\">#可见的主机名</span></span><br><span class=\"line\">cache_dir ufs /var/spool/squid  <span class=\"number\">100</span> <span class=\"number\">16</span> <span class=\"number\">256</span> </span><br><span class=\"line\"><span class=\"meta\">#ufs:缓存数据的存储格式</span></span><br><span class=\"line\"><span class=\"meta\">#/var/spool/squid    缓存目录</span></span><br><span class=\"line\"><span class=\"meta\">#100：缓存目录占磁盘空间大小（M）</span></span><br><span class=\"line\"><span class=\"meta\">#16：缓存空间一级子目录个数</span></span><br><span class=\"line\"><span class=\"meta\">#256：缓存空间二级子目录个数</span></span><br><span class=\"line\">cache_mgr webmaster@test.com    <span class=\"meta\">#定义管理员邮箱</span></span><br><span class=\"line\">http_access deny <span class=\"built_in\">all</span>    <span class=\"meta\">#访问控制</span></span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"squid中的访问控制\">squid中的访问控制<a href=\"post/squid#squid中的访问控制\"></a></h2><p>  使用访问控制特性，可以控制在访问时根据特定的时间间隔进行缓存、访问特定站点或一组站点等等。squid访问控制有两个要素：ACL元素和访问列表。访问列表可以允许或拒绝某些用户对此服务的访问。</p>\n<h3 id=\"ACL元素类型\">ACL元素类型<a href=\"post/squid#ACL元素类型\"></a></h3><ul>\n<li>src：源地址（即客户机IP地址）</li>\n<li>dst：目标地址（即服务器IP地址）</li>\n<li>srcdomain：源名称（即客户机名称）</li>\n<li>dstdomain：目标名称（即服务器名称）</li>\n<li>time：一天中的时刻和一周内的一天</li>\n<li>url_regex：URL规则表达式匹配</li>\n<li>urlpath_regex：URL-path规则表达式匹配，略去协议和主机名</li>\n<li>proxy_auth：通过外部程序进行用户验证</li>\n<li>maxconn：单一IP的最大连接数</li>\n</ul>\n<h3 id=\"ACL格式\">ACL格式<a href=\"post/squid#ACL格式\"></a></h3><pre><code>为了使用控制功能，必须先设置ACL规则并应用。ACL声明的格式如下：</code></pre><p>注：</p>\n<ul>\n<li>acl_element_name 可以是任一个在ACL中定义的名称</li>\n<li>任何两个ACL元素不能用相同的名字</li>\n<li>每个ACL由列表值组成。当进行匹配检测的时候，多个值由逻辑或运算连接；换言之，即任一ACL元素的值被匹配，则这个ACL元素即被匹配。</li>\n<li>并不是所有ACL元素都能使用访问列表中的全部类型</li>\n<li>不同的ACL元素写在不同行中，squid将把他们组合在一个列表中</li>\n</ul>\n<h3 id=\"访问条目\">访问条目<a href=\"post/squid#访问条目\"></a></h3><p>我们可以使用许多不同的访问条目。下面是我们常用的几个：</p>\n<ul>\n<li>http_access:允许HTTP访问</li>\n<li>no_cache:定义对缓存请求的响应。<br>访问列表的规则由一些类似’allow’或‘deny’的关键字构成，用以允许或拒绝向特定或一组ACL元素提供服务。</li>\n</ul>\n<ol>\n<li>一个访问列表可以由多条规则组成</li>\n<li>如果没有任何规则与访问请求匹配，默认动作将与列表中最后一条规则对应。</li>\n<li>一个访问条目中所有元素将用逻辑与运算连接<br>http_access Action 声明1 AND 声明2 AND 声明 OR.<br>http_access Action 声明3<br>多个http_accesss声明间用或运算连接，但每个访问条目的元素间用与运算连接。</li>\n<li>列表中的规则总是遵循由上而下的顺序</li>\n<li>这些规则按照他们的排列顺序进行匹配检测，一旦检测到匹配的规则，匹配就立即结束。</li>\n</ol>\n<h2 id=\"Squid-conf配置文件详解\">Squid.conf配置文件详解<a href=\"post/squid#Squid-conf配置文件详解\"></a></h2><figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#acl all src 0.0.0.0/0.0.0.0 and http_access allow all选项定义了一个访问控制列表。详细情况参见和Squid软件</span></span><br><span class=\"line\"><span class=\"comment\">#携带的文档。这里的访问控制列表允许所有对代理服务的访问，因为这里该代理是加速web服务器。</span></span><br><span class=\"line\">acl all src 0.0.0.0/0.0.0.0                 <span class=\"comment\">#允许所有IP访问</span></span><br><span class=\"line\">acl manager proto http                 <span class=\"comment\">#manager url协议为http</span></span><br><span class=\"line\">acl localhost src 127.0.0.1/255.255.255.255  <span class=\"comment\">#允午本机IP</span></span><br><span class=\"line\">acl to_localhost dst 127.0.0.1                 <span class=\"comment\">#允午目的地址为本机IP</span></span><br><span class=\"line\">acl Safe_ports port 80                <span class=\"comment\"># 允许安全更新的端口为80</span></span><br><span class=\"line\">acl CONNECT method CONNECT        <span class=\"comment\">#请求方法以CONNECT</span></span><br><span class=\"line\">http_access allow all                <span class=\"comment\">#允许所有人使用该代理.因为这里是代理加速web服务器</span></span><br><span class=\"line\">http_reply_access allow all                <span class=\"comment\">#允许所有客户端使用该代理</span></span><br><span class=\"line\"></span><br><span class=\"line\">acl OverConnLimit maxconn 16        <span class=\"comment\">#限制每个IP最大允许16个连接，防止攻击</span></span><br><span class=\"line\">http_access deny OverConnLimit</span><br><span class=\"line\"></span><br><span class=\"line\">icp_access deny all                        <span class=\"comment\">#禁止从邻居服务器缓冲内发送和接收ICP请求.</span></span><br><span class=\"line\">miss_access allow all                <span class=\"comment\">#允许直接更新请求</span></span><br><span class=\"line\">ident_lookup_access deny all                                <span class=\"comment\">#禁止lookup检查DNS</span></span><br><span class=\"line\">http_port 8080 transparent                                <span class=\"comment\">#指定Squid监听浏览器客户请求的端口号。</span></span><br><span class=\"line\"></span><br><span class=\"line\">hierarchy_stoplist cgi-bin ?                <span class=\"comment\">#用来强制某些特定的对象不被缓存，主要是处于安全的目的。</span></span><br><span class=\"line\">acl QUERY urlpath_regex cgi-bin \\?</span><br><span class=\"line\"><span class=\"keyword\">cache</span> deny <span class=\"keyword\">QUERY</span></span><br><span class=\"line\"></span><br><span class=\"line\">cache_mem <span class=\"number\">1</span> GB        <span class=\"comment\">#这是一个优化选项，增加该内存值有利于缓存。应该注意的是：</span></span><br><span class=\"line\">                     <span class=\"comment\">#一般来说如果系统有内存，设置该值为(n/)3M。现在是3G 所以这里1G</span></span><br><span class=\"line\">fqdncache_size <span class=\"number\">1024</span>        <span class=\"comment\">#FQDN 高速缓存大小</span></span><br><span class=\"line\">maximum_object_size_in_memory <span class=\"number\">2</span> MB        <span class=\"comment\">#允许最大的文件载入内存</span></span><br><span class=\"line\"></span><br><span class=\"line\">memory_replacement_policy <span class=\"keyword\">heap</span> LFUDA  <span class=\"comment\">#动态使用最小的，移出内存cache</span></span><br><span class=\"line\">cache_replacement_policy <span class=\"keyword\">heap</span> LFUDA         <span class=\"comment\">#动态使用最小的，移出硬盘cache</span></span><br><span class=\"line\"></span><br><span class=\"line\">cache_dir ufs /home/<span class=\"keyword\">cache</span> <span class=\"number\">5000</span> <span class=\"number\">32</span> <span class=\"number\">512</span>  <span class=\"comment\">#高速缓存目录 ufs 类型 使用的缓冲值最大允午1000MB空间，</span></span><br><span class=\"line\"><span class=\"comment\">#32个一级目录，512个二级目录</span></span><br><span class=\"line\"></span><br><span class=\"line\">max_open_disk_fds <span class=\"number\">0</span>                                 <span class=\"comment\">#允许最大打开文件数量,0 无限制</span></span><br><span class=\"line\">minimum_object_size <span class=\"number\">1</span> KB                         <span class=\"comment\">#允午最小文件请求体大小</span></span><br><span class=\"line\">maximum_object_size <span class=\"number\">20</span> MB                 <span class=\"comment\">#允午最大文件请求体大小</span></span><br><span class=\"line\"></span><br><span class=\"line\">cache_swap_low <span class=\"number\">90</span>                            <span class=\"comment\">#最小允许使用swap 90%</span></span><br><span class=\"line\">cache_swap_high <span class=\"number\">95</span>                            <span class=\"comment\">#最多允许使用swap 95%</span></span><br><span class=\"line\"></span><br><span class=\"line\">ipcache_size <span class=\"number\">2048</span>                                <span class=\"comment\"># IP 地址高速缓存大小 2M</span></span><br><span class=\"line\">ipcache_low <span class=\"number\">90</span>                                <span class=\"comment\">#最小允许ipcache使用swap 90%</span></span><br><span class=\"line\">ipcache_high <span class=\"number\">95</span>                                  <span class=\"comment\">#最大允许ipcache使用swap 90%</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">access_log /<span class=\"keyword\">var</span>/<span class=\"keyword\">log</span>/squid/access.log squid        <span class=\"comment\">#定义日志存放记录</span></span><br><span class=\"line\">cache_log /<span class=\"keyword\">var</span>/<span class=\"keyword\">log</span>/squid/cache.log squid</span><br><span class=\"line\">cache_store_log <span class=\"keyword\">none</span>                        <span class=\"comment\">#禁止store日志</span></span><br><span class=\"line\"></span><br><span class=\"line\">emulate_httpd_log <span class=\"keyword\">on</span>        <span class=\"comment\">#将使Squid仿照Web服务器的格式创建访问记录。如果希望使用</span></span><br><span class=\"line\">                                <span class=\"comment\">#Web访问记录分析程序，就需要设置这个参数。</span></span><br><span class=\"line\"></span><br><span class=\"line\">refresh_pattern . <span class=\"number\">0</span> <span class=\"number\">20</span>% <span class=\"number\">4320</span> override-<span class=\"keyword\">expire</span> override-lastmod reload-<span class=\"keyword\">into</span>-ims <span class=\"keyword\">ignore</span>-reload   <span class=\"comment\">#更新cache规则</span></span><br><span class=\"line\"></span><br><span class=\"line\">acl buggy_server url_regex ^<span class=\"keyword\">http</span>://.... <span class=\"keyword\">http</span>://          <span class=\"comment\">#只允许http的请求</span></span><br><span class=\"line\">broken_posts <span class=\"keyword\">allow</span> buggy_server</span><br><span class=\"line\"></span><br><span class=\"line\">acl apache rep_header <span class=\"keyword\">Server</span> ^Apache                 <span class=\"comment\">#允许apache的编码</span></span><br><span class=\"line\">broken_vary_encoding <span class=\"keyword\">allow</span> apache</span><br><span class=\"line\"></span><br><span class=\"line\">request_entities <span class=\"keyword\">off</span>                                        <span class=\"comment\">#禁止非http的标分准请求，防止攻击</span></span><br><span class=\"line\">header_access header <span class=\"keyword\">allow</span> all                        <span class=\"comment\">#允许所有的http报头</span></span><br><span class=\"line\">relaxed_header_parser <span class=\"keyword\">on</span>                                <span class=\"comment\">#不严格分析http报头.</span></span><br><span class=\"line\">client_lifetime <span class=\"number\">120</span> <span class=\"keyword\">minute</span>                                <span class=\"comment\">#最大客户连接时间 120分钟</span></span><br><span class=\"line\"></span><br><span class=\"line\">cache_mgr sky@test.com                        <span class=\"comment\">#指定当缓冲出现问题时向缓冲管理者发送告警信息的地址信息。</span></span><br><span class=\"line\"></span><br><span class=\"line\">cache_effective_user squid                        <span class=\"comment\">#这里以用户squid的身份Squid服务器</span></span><br><span class=\"line\">cache_effective_group squid</span><br><span class=\"line\"></span><br><span class=\"line\">icp_port <span class=\"number\">0</span>                       <span class=\"comment\">#指定Squid从邻居服务器缓冲内发送和接收ICP请求的端口号。</span></span><br><span class=\"line\">                     <span class=\"comment\">#这里设置为0是因为这里配置Squid为内部Web服务器的加速器，</span></span><br><span class=\"line\">                     <span class=\"comment\">#所以不需要使用邻居服务器的缓冲。0是禁用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># cache_peer 设置允许更新缓存的主机，因是本机所以127.0.0.1</span></span><br><span class=\"line\">cache_peer <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span> <span class=\"keyword\">parent</span> <span class=\"number\">80</span> <span class=\"number\">0</span> <span class=\"keyword\">no</span>-<span class=\"keyword\">query</span> <span class=\"keyword\">default</span> multicast-responder <span class=\"keyword\">no</span>-netdb-<span class=\"keyword\">exchange</span></span><br><span class=\"line\">cache_peer_domain <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>                                 </span><br><span class=\"line\">hostname_aliases <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span></span><br><span class=\"line\"></span><br><span class=\"line\">error_directory /usr/<span class=\"keyword\">share</span>/squid/<span class=\"keyword\">errors</span>/Simplify_Chinese        <span class=\"comment\">#定义错误路径</span></span><br><span class=\"line\"></span><br><span class=\"line\">always_direct <span class=\"keyword\">allow</span> all                <span class=\"comment\"># cache丢失或不存在是允许所有请求直接转发到原始服务器</span></span><br><span class=\"line\">ignore_unknown_nameservers <span class=\"keyword\">on</span>        <span class=\"comment\">#开反DNS查询，当域名地址不相同时候，禁止访问</span></span><br><span class=\"line\">coredump_dir  /<span class=\"keyword\">var</span>/<span class=\"keyword\">log</span>/squid                 <span class=\"comment\">#定义dump的目录</span></span><br><span class=\"line\"></span><br><span class=\"line\">max_filedesc <span class=\"number\">2048</span>                <span class=\"comment\">#最大打开的文件描述</span></span><br><span class=\"line\"></span><br><span class=\"line\">half_closed_clients <span class=\"keyword\">off</span>        <span class=\"comment\">#使Squid在当read不再返回数据时立即关闭客户端的连接。</span></span><br><span class=\"line\">                                <span class=\"comment\">#有时read不再返回数据是由于某些客户关闭TCP的发送数据</span></span><br><span class=\"line\">                                <span class=\"comment\">#而仍然保持接收数据。而Squid分辨不出TCP半关闭和完全关闭。</span></span><br><span class=\"line\"></span><br><span class=\"line\">buffered_logs <span class=\"keyword\">on</span> <span class=\"comment\">#若打开选项“buffered_logs”可以稍稍提高加速某些对日志文件的写入，该选项主要是实现优化特性。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#防止天涯盗链，转嫁给百度</span></span><br><span class=\"line\">acl tianya referer_regex -i tianya</span><br><span class=\"line\">http_access deny tianya</span><br><span class=\"line\">deny_info  tianya</span><br><span class=\"line\"><span class=\"comment\">#阻止baidu蜘蛛</span></span><br><span class=\"line\">acl baidu req_header <span class=\"keyword\">User</span>-<span class=\"keyword\">Agent</span> Baiduspider</span><br><span class=\"line\">http_access deny baidu</span><br><span class=\"line\"><span class=\"comment\">#限制同一IP客户端的最大连接数</span></span><br><span class=\"line\">acl OverConnLimit maxconn <span class=\"number\">128</span></span><br><span class=\"line\">http_access deny OverConnLimit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#防止被人利用为HTTP代理，设置允许访问的IP地址</span></span><br><span class=\"line\">acl myip dst <span class=\"number\">222.18</span><span class=\"number\">.63</span><span class=\"number\">.37</span></span><br><span class=\"line\">http_access deny !myip</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#允许本地管理</span></span><br><span class=\"line\">acl Manager proto cache_object</span><br><span class=\"line\">acl Localhost src <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span> <span class=\"number\">222.18</span><span class=\"number\">.63</span><span class=\"number\">.37</span></span><br><span class=\"line\">http_access <span class=\"keyword\">allow</span> Manager Localhost</span><br><span class=\"line\">cachemgr_passwd <span class=\"number\">53034338</span> all</span><br><span class=\"line\">http_access deny Manager</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#仅仅允许80端口的代理</span></span><br><span class=\"line\">acl all src <span class=\"number\">0.0</span><span class=\"number\">.0</span><span class=\"number\">.0</span>/<span class=\"number\">0.0</span><span class=\"number\">.0</span><span class=\"number\">.0</span></span><br><span class=\"line\">acl Safe_ports port <span class=\"number\">80</span> <span class=\"comment\"># http</span></span><br><span class=\"line\">http_access deny !Safe_ports</span><br><span class=\"line\">http_access <span class=\"keyword\">allow</span> all</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Squid信息设置</span></span><br><span class=\"line\">visible_hostname happy.swjtu.edu.cn</span><br><span class=\"line\">cache_mgr  ooopic2008@qq.com</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#基本设置</span></span><br><span class=\"line\">cache_effective_user squid</span><br><span class=\"line\">cache_effective_group squid</span><br><span class=\"line\">tcp_recv_bufsize <span class=\"number\">65535</span> <span class=\"keyword\">bytes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#2.6的反向代理加速配置</span></span><br><span class=\"line\">cache_peer <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span> <span class=\"keyword\">parent</span> <span class=\"number\">80</span> <span class=\"number\">0</span> <span class=\"keyword\">no</span>-<span class=\"keyword\">query</span> originserver</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#错误文档</span></span><br><span class=\"line\">error_directory /usr/<span class=\"keyword\">local</span>/squid/<span class=\"keyword\">share</span>/<span class=\"keyword\">errors</span>/Simplify_Chinese</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#单台使用，不使用该功能</span></span><br><span class=\"line\">icp_port <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">hierarchy_stoplist cgi-<span class=\"keyword\">bin</span> ?</span><br><span class=\"line\"></span><br><span class=\"line\">acl <span class=\"keyword\">QUERY</span> urlpath_regex cgi-<span class=\"keyword\">bin</span> \\? .php .cgi .avi .wmv .rm .ram .mpg .mpeg .zip .exe</span><br><span class=\"line\"><span class=\"keyword\">cache</span> deny <span class=\"keyword\">QUERY</span></span><br><span class=\"line\"></span><br><span class=\"line\">acl apache rep_header <span class=\"keyword\">Server</span> ^Apache</span><br><span class=\"line\">broken_vary_encoding <span class=\"keyword\">allow</span> apache</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">refresh_pattern ^<span class=\"keyword\">ftp</span>:           <span class=\"number\">1440</span> <span class=\"number\">20</span>%     <span class=\"number\">10080</span></span><br><span class=\"line\">refresh_pattern ^gopher:        <span class=\"number\">1440</span> <span class=\"number\">0</span>%    <span class=\"number\">1440</span></span><br><span class=\"line\">refresh_pattern .             <span class=\"number\">0</span>    <span class=\"number\">20</span>%     <span class=\"number\">4320</span></span><br><span class=\"line\"></span><br><span class=\"line\">cache_store_log <span class=\"keyword\">none</span></span><br><span class=\"line\">pid_filename /usr/<span class=\"keyword\">local</span>/squid/<span class=\"keyword\">var</span>/<span class=\"keyword\">logs</span>/squid.pid</span><br><span class=\"line\">emulate_httpd_log <span class=\"keyword\">on</span></span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"Squid常用命令\">Squid常用命令<a href=\"post/squid#Squid常用命令\"></a></h2><ol>\n<li>初始化在squid.conf里配置的cache目录<br>squid -z<br>如果有错误提示，请检查cache目录的权限，可以更改目录权限<br>chown -R squid:squid /cache目录</li>\n<li>对squid.conf排错，即验证squid.conf的语法和配置<br>squid -k parse<br>如果在squid.conf中有语法或配置错误，这里会返回提示，若无返回，尝试启动squid</li>\n<li>前台启动squid，并输出启动过程<br>/usr/local/squid/sbin/squid -N -d1<br>如果有ready to server reques相关信息，说明squid启动成功<br>然后ctrl+c ,停止squid,并以后台运行的方式启动它</li>\n<li>启动squid在后台运行<br>squid -s<br>可以使用ps -ax | grep squid 来查看squid进程是否存在</li>\n<li>停止squid<br>squid -k shutdown</li>\n<li>重新引导修改过的squid.conf<br>squid -k reconfigure -f /XXX/squid.conf<br>当squid进行配置更改后，可以使用该命令进行squid配置重载</li>\n<li>把squid添加到系统启动项<br>vim /etc/rc.local<br>/usr/local/squid/sbin/squid -s</li>\n<li>修改cache缓存目录的权限<br>chown -R squid.squid /cache目录<br>cache缓存目录根据自己的配置更改，squid用户和组是squid，squid</li>\n<li>修改squid日志目录的权限<br>chown -R squid.squid 定义的日志文件所在目录<br>这一步并不是适合每一个使用squid的用户，意为让squid有权限在该目录里进行写操作</li>\n<li>查看你的日志文档<br>more /usr/local/squid/var/logs/access.log | grep TCP_MEM_HIT<br>该指令可以看到在squid运行过程中，有那些文件被squid缓存到内存中，并返回给访问用户。<br>more /usr/local/squid/var/logs/access.log | grep TCP_HIT<br>该指令可以看到在squid运行过程中，有那些文件被squid缓存到cache目录中，并返回给访问用户。<br>more /usr/local/squid/var/logs/access.log | grep TCP_MISS<br>该指令可以看到在squid运行过程中，有那些文件没有被squid缓存，而是从原始服务器获取并返回给访问用户。</li>\n</ol>\n<h2 id=\"Squid命中率分析\">Squid命中率分析<a href=\"post/squid#Squid命中率分析\"></a></h2><figure class=\"highlight groovy\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">/usr/</span>local<span class=\"regexp\">/squid/</span>bin/squidclient -p <span class=\"number\">80</span> <span class=\"string\">mgr:</span>info</span><br><span class=\"line\"><span class=\"regexp\">/usr/</span>local<span class=\"regexp\">/squid/</span>bin/squidclient -p <span class=\"number\">80</span> <span class=\"string\">mgr:</span><span class=\"number\">5</span>min</span><br></pre></td></tr></table></div></figure>\n\n<p>可以看到详细的性能情况,其中PORT是你的proxy的端口，5min可以是60min<br>取得squid运行状态信息：</p>\n<figure class=\"highlight nginx\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">squidclient</span> -p <span class=\"number\">80</span> mgr:<span class=\"literal\">info</span></span><br></pre></td></tr></table></div></figure>\n\n<p>取得squid内存使用情况：</p>\n<figure class=\"highlight stylus\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">squidclient -<span class=\"selector-tag\">p</span> <span class=\"number\">80</span> mgr:mem</span><br></pre></td></tr></table></div></figure>\n\n<p>取得squid已经缓存的列表：</p>\n<figure class=\"highlight armasm\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">squidclient</span> -p <span class=\"number\">80</span> mgr:<span class=\"keyword\">bjects. </span>use <span class=\"keyword\">it </span>carefully,<span class=\"keyword\">it </span>may crash</span><br></pre></td></tr></table></div></figure>\n\n<p>取得squid的磁盘使用情况：</p>\n<figure class=\"highlight stylus\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">squidclient -<span class=\"selector-tag\">p</span> <span class=\"number\">80</span> mgr:diskd</span><br></pre></td></tr></table></div></figure>\n\n<p>强制更新某个url：</p>\n<figure class=\"highlight stylus\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">squidclient -<span class=\"selector-tag\">p</span> <span class=\"number\">80</span> -m PURGE http:<span class=\"comment\">//www.xxx.com/xxx.php</span></span><br></pre></td></tr></table></div></figure>\n\n<p>更多的请查看：squidclient-h 或者 squidclient -p 80 mgr:<br>查命中率：</p>\n<figure class=\"highlight armasm\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">squidclient</span> -h <span class=\"built_in\">IP</span>(具体侦听<span class=\"built_in\">IP</span>) -p <span class=\"number\">80</span>(具体侦听端口) mgr:<span class=\"meta\">info</span></span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"定期清理swap-state内无效数据\">定期清理swap.state内无效数据<a href=\"post/squid#定期清理swap-state内无效数据\"></a></h2><figure class=\"highlight dts\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta-keyword\">/path/</span>to<span class=\"meta-keyword\">/squid/</span>sbin/squid -k rotate -f <span class=\"meta-keyword\">/path/</span>to<span class=\"meta-keyword\">/squid/</span>conf_file</span><br><span class=\"line\">vi <span class=\"meta-keyword\">/etc/</span>crontab</span><br><span class=\"line\"><span class=\"number\">0</span>        <span class=\"number\">0</span>       *       *       *       root    <span class=\"meta-keyword\">/usr/</span>local<span class=\"meta-keyword\">/sbin/</span>squid -k rotate -f <span class=\"meta-keyword\">/usr/</span>local<span class=\"meta-keyword\">/etc/</span>squid/squid1.conf</span><br></pre></td></tr></table></div></figure>\n\n<p>当squid应用运行了一段时间之后，cache_dir对应的swap.state文件就会变得越来越大，里面的无效接口数据越来越多，这可能影响squid的响应时间，因此需要使用squid清理swap.state里面的无效数据，减少swap.state的大小。</p>\n","slug":"squid","updated":"2019-06-26T02:42:28.427Z","comments":true,"link":"post/squid","permalink":"https://shuntan.github.io/posts/squid/","excerpt":"squid的概念squid是一种用来缓存Internet数据的软件。接受来自人们需要下载的目标（object）的请求并适当的处理这些请求。也就是说，如果一个人想下载一web界面，他请求squid为他取得这个页面。squid随之连接到远程服务器并向这个页面发出请求。然后，squid显式地聚集数据到客户端机器，而且同时复制一份。当下一次有人需要同一页面时， squid可以简单的从磁盘中读到它，那样数据会立即传输到客户机上。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://shuntan.github.io/categories/Linux/"}],"tags":[{"name":"squid","slug":"squid","permalink":"https://shuntan.github.io/tags/squid/"},{"name":"proxy","slug":"proxy","permalink":"https://shuntan.github.io/tags/proxy/"}]}]}