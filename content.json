{"meta":{"title":"Shawntan's Blog","subtitle":"Segmentfault","description":"shawntan@tencent.com","author":"Shawntan","url":"https://shuntan.github.io"},"pages":[{},{},{},{},{}],"posts":[{"title":"C++中的万能引用和完美转发","date":"2019-05-29T02:05:19.000Z","path":"posts/dc484a2e/","text":"C++中的万能引用和完美转发阅读这篇博文需要了解C++中的左值（lvalue）和右值（rvalue）的概念，详情参见我的另外一篇博文：C++移动语义及拷贝优化万能引用和完美转发多涉及到模板的使用，如若不是自己写模板，则可不用关心万能引用（Universal Reference）首先，我们来看一个例子：1234567891011121314151617#include &lt;iostream&gt;using std::cout;using std::endl;template&lt;typename T&gt;void func(T&amp; param) &#123; cout &lt;&lt; param &lt;&lt; endl;&#125;int main() &#123; int num = 2019; func(num); return 0;&#125;这样例子的编译输出都没有什么问题，但是如果我们修改成下面的调用方式呢？1234int main() &#123; func(2019); return 0;&#125;则会得到一个大大的编译错误。因为上面的模板函数只能接受左值或者左值引用（左值一般是有名字的变量，可以取到地址的），我们当然可以重载一个接受右值的模板函数，如下也可以达到效果。1234567891011121314151617template&lt;typename T&gt;void func(T&amp; param) &#123; cout &lt;&lt; &quot;传入的是左值&quot; &lt;&lt; endl;&#125;template&lt;typename T&gt;void func(T&amp;&amp; param) &#123; cout &lt;&lt; &quot;传入的是右值&quot; &lt;&lt; endl;&#125;int main() &#123; int num = 2019; func(num); func(2019); return 0;&#125;输出结果：12传入的是左值传入的是右值第一次函数调用的是左值得版本，第二次函数调用的是右值版本。但是，有没有办法只写一个模板函数即可以接收左值又可以接收右值呢？C++ 11中有万能引用（Universal Reference）的概念：使用T&amp;&amp;类型的形参既能绑定右值，又能绑定左值。但是注意了：只有发生类型推导的时候，T&amp;&amp;才表示万能引用； 否则，表示右值引用。所以，上面的案例我们可以修改为：123456789101112template&lt;typename T&gt;void func(T&amp;&amp; param) &#123; cout &lt;&lt; param &lt;&lt; endl;&#125;int main() &#123; int num = 2019; func(num); func(2019); return 0;&#125;引用折叠（Universal Collapse）万能引用说完了，接着来聊引用折叠（Univers Collapse），因为完美转发（Perfect Forwarding）的概念涉及引用折叠。一个模板函数，根据定义的形参和传入的实参的类型，我们可以有下面四中组合：左值-左值 T&amp; &amp; # 函数定义的形参类型是左值引用，传入的实参是左值引用左值-右值 T&amp; &amp;&amp; # 函数定义的形参类型是左值引用，传入的实参是右值引用右值-左值 T&amp;&amp; &amp; # 函数定义的形参类型是右值引用，传入的实参是左值引用右值-右值 T&amp;&amp; &amp;&amp; # 函数定义的形参类型是右值引用，传入的实参是右值引用但是C++中不允许对引用再进行引用，对于上述情况的处理有如下的规则：所有的折叠引用最终都代表一个引用，要么是左值引用，要么是右值引用。规则是：如果任一引用为左值引用，则结果为左值引用。否则（即两个都是右值引用），结果为右值引用。即就是前面三种情况代表的都是左值引用，而第四种代表的右值引用。完美转发（Perfect Forwarding）下面接着说完美转发（Perfect Forwarding），首先，看一个例子：为了方便观察调用过程，我们在std::forward函数copy出来，增加输出一条内容，改为test::forward，其他保持不变。1#include &lt;iostream&gt; #include &lt;bits/move.h&gt; // add print content namespace test&#123; template&lt;typename _Tp&gt; constexpr _Tp&amp;&amp; forward(typename std::remove_reference&lt;_Tp&gt;::type&amp; __t) noexcept &#123; std::cout &lt;&lt; &quot;Forward an l-value.&quot; &lt;&lt; std::endl; return static_cast&lt;_Tp&amp;&amp;&gt;(__t); &#125; template&lt;typename _Tp&gt; constexpr _Tp&amp;&amp; forward(typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp; __t) noexcept &#123; std::cout &lt;&lt; &quot;Forward an r-value.&quot; &lt;&lt; std::endl; static_assert(!std::is_lvalue_reference&lt;_Tp&gt;::value, &quot;template argument&quot; &quot; substituting _Tp is an lvalue reference type&quot;); return static_cast&lt;_Tp&amp;&amp;&gt;(__t); &#125; &#125; // my template functions template&lt;typename T&gt; void func(T&amp; param) &#123; std::cout &lt;&lt; &quot;传入的是左值&quot; &lt;&lt; std::endl; &#125; template&lt;typename T&gt; void func(T&amp;&amp; param) &#123; std::cout &lt;&lt; &quot;传入的是右值&quot; &lt;&lt; std::endl; &#125; template&lt;typename T&gt; void warp(T&amp;&amp; param) &#123; func(param); &#125; extern &quot;C&quot; &#123; int main(int argc, char* argv[]) &#123; int num = 2019; warp(num); warp(2019); return 0; &#125;&#125;输出结果为：12传入的是左值传入的是左值是不是和我们预期的不一样，下面我们来分析一下原因：warp()函数本身的形参是一个万能引用，即可以接受左值又可以接受右值；第一个warp()函数调用实参是左值，所以，warp()函数中调用func()中传入的参数也应该是左值；第二个warp()函数调用实参是右值，根据上面所说的引用折叠规则，warp()函数接收的参数类型是右值引用，那么为什么却调用了调用func()的左值版本了呢？这是因为在warp()函数内部，右值引用类型变为了左值，因为参数有了名称，我们也通过变量名取得变量地址。结论：无论传入wrap()的参数是左值还是右值，到了函数内部都变成了左值。那么问题来了，怎么保持函数调用过程中，变量类型的不变呢？这就是我们所谓的“完美转发”技术，在C++11中通过std::forward()函数来实现。我们修改我们的warp()函数如下：1template&lt;typename T&gt; void warp(T&amp;&amp; param) &#123; func(test::forward&lt;T&gt;(param)); &#125;输出结果为：1234Forward an l-value.传入的是左值Forward an l-value.传入的是右值现在跟我们的预期一致了，但是原理是什么呢？观察forward()函数内部不难发现，传入的参数做了移除引用的操作，使其都为&amp;&amp; 或 &amp;，所以有2个函数版本，重点在于模版返回的时候return static_cast&lt;_Tp&amp;&amp;&gt;(__t);强制将实参转换成T原有的引用类型，根据引用折叠原则，T&amp;&amp; &amp;还是&amp;，T&amp;&amp; &amp;&amp;还是&amp;&amp;。所以实现了“完美转发”。如果将wrap()函数改为这样呢？1template&lt;typename T&gt; void warp(T&amp;&amp; param) &#123; func(test::forward&lt;T&gt;(std::move(param))); &#125;编译结果：12Error：static_assert(template argument substituting _Tp is an lvalue reference type&quot;);可以发现成功走到了第二个forward()函数版本。将static_assert&lt;&gt;注释掉，编译通过。输出结果为：1234Forward an r-value.传入的是左值Forward an r-value.传入的是右值对比std::move()的返回值就可以发现，它的返回值是return static_cast&lt;typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(__t);不难看出，必是右值引用。而std::forward()函数则将其按T的引用类型保持不变原样返回。","raw":"---\ntitle: C++中的万能引用和完美转发\ndate: 2019-05-29 10:05:19\ncopyright:\ntags: c++\ntype:\ncategories: c++\nkeyword:\ntop:\ncomments:\npassword:\ndescription:\n---\n\n## C++中的万能引用和完美转发\n* 阅读这篇博文需要了解C++中的左值（lvalue）和右值（rvalue）的概念，详情参见我的另外一篇博文：C++移动语义及拷贝优化\n\n* 万能引用和完美转发多涉及到模板的使用，如若不是自己写模板，则可不用关心\n\n### 万能引用（Universal Reference）\n首先，我们来看一个例子：\n\n```\n#include <iostream>\n\nusing std::cout;\nusing std::endl;\n\n\ntemplate<typename T>\nvoid func(T& param) {\n    cout << param << endl;\n}\n\n\nint main() {\n    int num = 2019;\n    func(num);\n    return 0;\n}\n```\n\n这样例子的编译输出都没有什么问题，但是如果我们修改成下面的调用方式呢？\n\n```\nint main() {\n    func(2019);\n    return 0;\n}\n```\n\n则会得到一个大大的编译错误。因为上面的模板函数只能接受左值或者左值引用（左值一般是有名字的变量，可以取到地址的），我们当然可以重载一个接受右值的模板函数，如下也可以达到效果。\n\n```\ntemplate<typename T>\nvoid func(T& param) {\n    cout << \"传入的是左值\" << endl;\n}\ntemplate<typename T>\nvoid func(T&& param) {\n    cout << \"传入的是右值\" << endl;\n}\n\n\n\nint main() {\n    int num = 2019;\n    func(num);\n    func(2019);\n    return 0;\n}\n```\n\n输出结果：\n\n```\n传入的是左值\n传入的是右值\n```\n\n第一次函数调用的是左值得版本，第二次函数调用的是右值版本。但是，有没有办法只写一个模板函数即可以接收左值又可以接收右值呢？\n\nC++ 11中有万能引用（Universal Reference）的概念：使用T&&类型的形参既能绑定右值，又能绑定左值。\n\n但是注意了：*只有发生类型推导的时候，T&&才表示万能引用；* 否则，表示右值引用。\n\n所以，上面的案例我们可以修改为：\n\n```\ntemplate<typename T>\nvoid func(T&& param) {\n    cout << param << endl;\n}\n\n\nint main() {\n    int num = 2019;\n    func(num);\n    func(2019);\n    return 0;\n}\n```\n\n## 引用折叠（Universal Collapse）\n万能引用说完了，接着来聊引用折叠（Univers Collapse），因为完美转发（Perfect Forwarding）的概念涉及引用折叠。一个模板函数，根据定义的形参和传入的实参的类型，我们可以有下面四中组合：\n\n* 左值-左值 T& &        # 函数定义的形参类型是左值引用，传入的实参是左值引用\n* 左值-右值 T& &&      # 函数定义的形参类型是左值引用，传入的实参是右值引用\n* 右值-左值 T&& &      # 函数定义的形参类型是右值引用，传入的实参是左值引用\n* 右值-右值 T&& &&    # 函数定义的形参类型是右值引用，传入的实参是右值引用\n\n但是C++中不允许对引用再进行引用，对于上述情况的处理有如下的规则：\n\n所有的折叠引用最终都代表一个引用，要么是左值引用，要么是右值引用。规则是：如果任一引用为左值引用，则结果为左值引用。否则（即两个都是右值引用），结果为右值引用。\n\n即就是前面三种情况代表的都是左值引用，而第四种代表的右值引用。\n\n## 完美转发（Perfect Forwarding）\n\n下面接着说完美转发（Perfect Forwarding），首先，看一个例子：\n\n为了方便观察调用过程，我们在std::forward函数copy出来，增加输出一条内容，改为test::forward，其他保持不变。\n\n```\n#include <iostream>\r#include <bits/move.h>\r\r// add print content\rnamespace test{\rtemplate<typename _Tp>\r  constexpr _Tp&&\r  forward(typename std::remove_reference<_Tp>::type& __t) noexcept {\r    std::cout << \"Forward an l-value.\" << std::endl;\r    return static_cast<_Tp&&>(__t);\r  }\r\rtemplate<typename _Tp>\r  constexpr _Tp&&\r  forward(typename std::remove_reference<_Tp>::type&& __t) noexcept {\r    std::cout << \"Forward an r-value.\" << std::endl;\r    static_assert(!std::is_lvalue_reference<_Tp>::value, \"template argument\"\r          \" substituting _Tp is an lvalue reference type\");\r    return static_cast<_Tp&&>(__t);\r  }\r}\r\r// my template functions\rtemplate<typename T>\rvoid func(T& param) {\r    std::cout << \"传入的是左值\" << std::endl;\r}\r\rtemplate<typename T>\rvoid func(T&& param) {\r    std::cout << \"传入的是右值\" << std::endl;\r}\r\rtemplate<typename T>\rvoid warp(T&& param) {\r    func(param);\r}\r\rextern \"C\" {\rint main(int argc, char* argv[]) {\r    int num = 2019;\r    warp(num);\r    warp(2019);\r    return 0;\r}}\n```\n\n输出结果为：\n\n```\n传入的是左值\n传入的是左值\n```\n\n是不是和我们预期的不一样，下面我们来分析一下原因：\n\n<strong>warp()</strong>函数本身的形参是一个万能引用，即可以接受左值又可以接受右值；第一个warp()函数调用实参是左值，所以，<strong>warp()</strong>函数中调用<strong>func()</strong>中传入的参数也应该是左值；第二个warp()函数调用实参是右值，根据上面所说的引用折叠规则，<strong>warp()函数接收的参数类型是右值引用，那么为什么却调用了调用func()的左值版本了呢？</strong>这是因为在warp()函数内部，右值引用类型变为了左值，因为参数有了名称，我们也通过变量名取得变量地址。\n\n结论：无论传入wrap()的参数是左值还是右值，到了函数内部都变成了左值。\n\n那么问题来了，怎么保持函数调用过程中，变量类型的不变呢？这就是我们所谓的“完美转发”技术，在C++11中通过std::forward()函数来实现。我们修改我们的warp()函数如下：\n\n```\ntemplate<typename T>\rvoid warp(T&& param) {\r    func(test::forward<T>(param));\r}\n```\n输出结果为：\n\n```\nForward an l-value.\n传入的是左值\nForward an l-value.\n传入的是右值\n```\n\n现在跟我们的预期一致了，但是原理是什么呢？观察forward()函数内部不难发现，传入的参数做了<strong>移除引用</strong>的操作，使其都为&& 或 &，所以有2个函数版本，重点在于模版返回的时候<strong>return static_cast<_Tp&&>(__t);</strong>强制将实参转换成T原有的引用类型，根据<strong>引用折叠</strong>原则，T&& &还是&，T&& &&还是&&。所以实现了“完美转发”。\n\n如果将wrap()函数改为这样呢？\n\n```\ntemplate<typename T>\rvoid warp(T&& param) {\r    func(test::forward<T>(std::move(param)));\r}\n```\n\n编译结果：\n\n```\nError：\nstatic_assert(template argument substituting _Tp is an lvalue reference type\");\n```\n\n可以发现成功走到了第二个forward()函数版本。将<strong>static_assert<></strong>注释掉，编译通过。输出结果为：\n\n```\nForward an r-value.\n传入的是左值\nForward an r-value.\n传入的是右值\n```\n\n对比std::move()的返回值就可以发现，它的返回值是<strong>return static_cast<typename  std::remove_reference<_Tp>::type&&>(__t);</strong>不难看出，必是右值引用。而std::forward()函数则将其按T的引用类型保持不变原样返回。","content":"<h2 id=\"C-中的万能引用和完美转发\"><a href=\"#C-中的万能引用和完美转发\" class=\"headerlink\" title=\"C++中的万能引用和完美转发\"></a>C++中的万能引用和完美转发</h2><ul><li><p>阅读这篇博文需要了解C++中的左值（lvalue）和右值（rvalue）的概念，详情参见我的另外一篇博文：C++移动语义及拷贝优化</p></li><li><p>万能引用和完美转发多涉及到模板的使用，如若不是自己写模板，则可不用关心</p></li></ul><h3 id=\"万能引用（Universal-Reference）\"><a href=\"#万能引用（Universal-Reference）\" class=\"headerlink\" title=\"万能引用（Universal Reference）\"></a>万能引用（Universal Reference）</h3><p>首先，我们来看一个例子：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">using std::cout;</span><br><span class=\"line\">using std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">void func(T&amp; param) &#123;</span><br><span class=\"line\">    cout &lt;&lt; param &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    int num = 2019;</span><br><span class=\"line\">    func(num);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这样例子的编译输出都没有什么问题，但是如果我们修改成下面的调用方式呢？</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    func(2019);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>则会得到一个大大的编译错误。因为上面的模板函数只能接受左值或者左值引用（左值一般是有名字的变量，可以取到地址的），我们当然可以重载一个接受右值的模板函数，如下也可以达到效果。</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">void func(T&amp; param) &#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;传入的是左值&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">void func(T&amp;&amp; param) &#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;传入的是右值&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    int num = 2019;</span><br><span class=\"line\">    func(num);</span><br><span class=\"line\">    func(2019);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">传入的是左值</span><br><span class=\"line\">传入的是右值</span><br></pre></td></tr></table></figure><p>第一次函数调用的是左值得版本，第二次函数调用的是右值版本。但是，有没有办法只写一个模板函数即可以接收左值又可以接收右值呢？</p><p>C++ 11中有万能引用（Universal Reference）的概念：使用T&amp;&amp;类型的形参既能绑定右值，又能绑定左值。</p><p>但是注意了：<em>只有发生类型推导的时候，T&amp;&amp;才表示万能引用；</em> 否则，表示右值引用。</p><p>所以，上面的案例我们可以修改为：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">void func(T&amp;&amp; param) &#123;</span><br><span class=\"line\">    cout &lt;&lt; param &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    int num = 2019;</span><br><span class=\"line\">    func(num);</span><br><span class=\"line\">    func(2019);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"引用折叠（Universal-Collapse）\"><a href=\"#引用折叠（Universal-Collapse）\" class=\"headerlink\" title=\"引用折叠（Universal Collapse）\"></a>引用折叠（Universal Collapse）</h2><p>万能引用说完了，接着来聊引用折叠（Univers Collapse），因为完美转发（Perfect Forwarding）的概念涉及引用折叠。一个模板函数，根据定义的形参和传入的实参的类型，我们可以有下面四中组合：</p><ul><li>左值-左值 T&amp; &amp; # 函数定义的形参类型是左值引用，传入的实参是左值引用</li><li>左值-右值 T&amp; &amp;&amp; # 函数定义的形参类型是左值引用，传入的实参是右值引用</li><li>右值-左值 T&amp;&amp; &amp; # 函数定义的形参类型是右值引用，传入的实参是左值引用</li><li>右值-右值 T&amp;&amp; &amp;&amp; # 函数定义的形参类型是右值引用，传入的实参是右值引用</li></ul><p>但是C++中不允许对引用再进行引用，对于上述情况的处理有如下的规则：</p><p>所有的折叠引用最终都代表一个引用，要么是左值引用，要么是右值引用。规则是：如果任一引用为左值引用，则结果为左值引用。否则（即两个都是右值引用），结果为右值引用。</p><p>即就是前面三种情况代表的都是左值引用，而第四种代表的右值引用。</p><h2 id=\"完美转发（Perfect-Forwarding）\"><a href=\"#完美转发（Perfect-Forwarding）\" class=\"headerlink\" title=\"完美转发（Perfect Forwarding）\"></a>完美转发（Perfect Forwarding）</h2><p>下面接着说完美转发（Perfect Forwarding），首先，看一个例子：</p><p>为了方便观察调用过程，我们在std::forward函数copy出来，增加输出一条内容，改为test::forward，其他保持不变。</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;\r#include &lt;bits/move.h&gt;\r\r// add print content\rnamespace test&#123;\rtemplate&lt;typename _Tp&gt;\r  constexpr _Tp&amp;&amp;\r  forward(typename std::remove_reference&lt;_Tp&gt;::type&amp; __t) noexcept &#123;\r    std::cout &lt;&lt; &quot;Forward an l-value.&quot; &lt;&lt; std::endl;\r    return static_cast&lt;_Tp&amp;&amp;&gt;(__t);\r  &#125;\r\rtemplate&lt;typename _Tp&gt;\r  constexpr _Tp&amp;&amp;\r  forward(typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp; __t) noexcept &#123;\r    std::cout &lt;&lt; &quot;Forward an r-value.&quot; &lt;&lt; std::endl;\r    static_assert(!std::is_lvalue_reference&lt;_Tp&gt;::value, &quot;template argument&quot;\r          &quot; substituting _Tp is an lvalue reference type&quot;);\r    return static_cast&lt;_Tp&amp;&amp;&gt;(__t);\r  &#125;\r&#125;\r\r// my template functions\rtemplate&lt;typename T&gt;\rvoid func(T&amp; param) &#123;\r    std::cout &lt;&lt; &quot;传入的是左值&quot; &lt;&lt; std::endl;\r&#125;\r\rtemplate&lt;typename T&gt;\rvoid func(T&amp;&amp; param) &#123;\r    std::cout &lt;&lt; &quot;传入的是右值&quot; &lt;&lt; std::endl;\r&#125;\r\rtemplate&lt;typename T&gt;\rvoid warp(T&amp;&amp; param) &#123;\r    func(param);\r&#125;\r\rextern &quot;C&quot; &#123;\rint main(int argc, char* argv[]) &#123;\r    int num = 2019;\r    warp(num);\r    warp(2019);\r    return 0;\r&#125;&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">传入的是左值</span><br><span class=\"line\">传入的是左值</span><br></pre></td></tr></table></figure><p>是不是和我们预期的不一样，下面我们来分析一下原因：</p><p><strong>warp()</strong>函数本身的形参是一个万能引用，即可以接受左值又可以接受右值；第一个warp()函数调用实参是左值，所以，<strong>warp()</strong>函数中调用<strong>func()</strong>中传入的参数也应该是左值；第二个warp()函数调用实参是右值，根据上面所说的引用折叠规则，<strong>warp()函数接收的参数类型是右值引用，那么为什么却调用了调用func()的左值版本了呢？</strong>这是因为在warp()函数内部，右值引用类型变为了左值，因为参数有了名称，我们也通过变量名取得变量地址。</p><p>结论：无论传入wrap()的参数是左值还是右值，到了函数内部都变成了左值。</p><p>那么问题来了，怎么保持函数调用过程中，变量类型的不变呢？这就是我们所谓的“完美转发”技术，在C++11中通过std::forward()函数来实现。我们修改我们的warp()函数如下：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T&gt;\rvoid warp(T&amp;&amp; param) &#123;\r    func(test::forward&lt;T&gt;(param));\r&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Forward an l-value.</span><br><span class=\"line\">传入的是左值</span><br><span class=\"line\">Forward an l-value.</span><br><span class=\"line\">传入的是右值</span><br></pre></td></tr></table></figure><p>现在跟我们的预期一致了，但是原理是什么呢？观察forward()函数内部不难发现，传入的参数做了<strong>移除引用</strong>的操作，使其都为&amp;&amp; 或 &amp;，所以有2个函数版本，重点在于模版返回的时候<strong>return static_cast&lt;_Tp&amp;&amp;&gt;(__t);</strong>强制将实参转换成T原有的引用类型，根据<strong>引用折叠</strong>原则，T&amp;&amp; &amp;还是&amp;，T&amp;&amp; &amp;&amp;还是&amp;&amp;。所以实现了“完美转发”。</p><p>如果将wrap()函数改为这样呢？</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T&gt;\rvoid warp(T&amp;&amp; param) &#123;\r    func(test::forward&lt;T&gt;(std::move(param)));\r&#125;</span><br></pre></td></tr></table></figure><p>编译结果：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error：</span><br><span class=\"line\">static_assert(template argument substituting _Tp is an lvalue reference type&quot;);</span><br></pre></td></tr></table></figure><p>可以发现成功走到了第二个forward()函数版本。将<strong>static_assert&lt;&gt;</strong>注释掉，编译通过。输出结果为：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Forward an r-value.</span><br><span class=\"line\">传入的是左值</span><br><span class=\"line\">Forward an r-value.</span><br><span class=\"line\">传入的是右值</span><br></pre></td></tr></table></figure><p>对比std::move()的返回值就可以发现，它的返回值是<strong>return static_cast&lt;typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(__t);</strong>不难看出，必是右值引用。而std::forward()函数则将其按T的引用类型保持不变原样返回。</p>","slug":"完美转发","updated":"2019-05-29T02:51:03.145Z","comments":true,"link":"","permalink":"https://shuntan.github.io/posts/dc484a2e/","excerpt":"","categories":[{"name":"c++","slug":"c","permalink":"https://shuntan.github.io/categories/c/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://shuntan.github.io/tags/c/"}]},{"title":"从4行代码看右值引用","date":"2019-05-23T06:50:40.000Z","path":"posts/9d2f4ec8/","text":"概述 右值引用的概念有些读者可能会感到陌生，其实他和C++98/03中的左值引用有些类似，例如，c++98/03中的左值引用是这样的：12int i = 0;int&amp; j = i; 这里的int&amp;是对左值进行绑定（但是int&amp;却不能绑定右值），相应的，对右值进行绑定的引用就是右值引用，他的语法是这样的A&amp;&amp;，通过双引号来表示绑定类型为A的右值。通过&amp;&amp;我们就可以很方便的绑定右值了，比如我们可以这样绑定一个右值： 1int&amp;&amp; i = 0; 这里我们绑定了一个右值0，关于右值的概念会在后面介绍。右值引用是C++11中新增加的一个很重要的特性，他主是要用来解决C++98/03中遇到的两个问题，第一个问题就是临时对象非必要的昂贵的拷贝操作，第二个问题是在模板函数中如何按照参数的实际类型进行转发。通过引入右值引用，很好的解决了这两个问题，改进了程序性能，后面将会详细介绍右值引用是如何解决这两个问题的。 和右值引用相关的概念比较多，比如：右值、纯右值、将亡值、universal references、引用折叠、移动语义、move语义和完美转发等等。很多都是新概念，对于刚学习C++11右值引用的初学者来说，可能会觉得右值引用过于复杂，概念之间的关系难以理清。右值引用实际上并没有那么复杂，其实是关于4行代码的故事，通过简单的4行代码我们就能清晰的理解右值引用相关的概念了。本文希望带领读者通过4行代码来理解右值引用相关的概念，理清他们之间的关系，并最终能透彻地掌握C++11的新特性–右值引用。四行代码的故事第1行代码的故事1int i = getVar(); 上面的这行代码很简单，从getVar()函数获取一个整形值，然而，这行代码会产生几种类型的值呢？答案是会产生两种类型的值，一种是左值i，一种是函数getVar()返回的临时值，这个临时值在表达式结束后就销毁了，而左值i在表达式结束后仍然存在，这个临时值就是右值，具体来说是一个纯右值，右值是不具名的。区分左值和右值的一个简单办法是：看能不能对表达式取地址，如果能，则为左值，否则为右值。 所有的具名变量或对象都是左值，而匿名变量则是右值，比如，简单的赋值语句：1int i = 0; 在这条语句中，i 是左值，0 是字面量，就是右值。在上面的代码中，i 可以被引用，0 就不可以了。具体来说上面的表达式中等号右边的0是纯右值（prvalue），在C++11中所有的值必属于左值、将亡值、纯右值三者之一。比如，非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和lambda表达式等都是纯右值。而将亡值是C++11新增的、与右值引用相关的表达式，比如，将要被移动的对象、T&amp;&amp;函数返回值、std::move返回值和转换为T&amp;&amp;的类型的转换函数的返回值等。关于将亡值我们会在后面介绍，先看下面的代码：123int j = 5;auto f = []&#123;return 5;&#125;; 上面的代码中5是一个原始字面量， []{return 5;}是一个lambda表达式，都是属于纯右值，他们的特点是在表达式结束之后就销毁了。 通过地行代码我们对右值有了一个初步的认识，知道了什么是右值，接下来再来看看第二行代码。第2行代码的故事1T&amp;&amp; k = getVar(); 第二行代码和第一行代码很像，只是相比第一行代码多了“&amp;&amp;”，他就是右值引用，我们知道左值引用是对左值的引用，那么，对应的，对右值的引用就是右值引用，而且右值是匿名变量，我们也只能通过引用的方式来获取右值。虽然第二行代码和第一行代码看起来差别不大，但是实际上语义的差别很大，这里，getVar()产生的临时值不会像第一行代码那样，在表达式结束之后就销毁了，而是会被“续命”，他的生命周期将会通过右值引用得以延续，和变量k的声明周期一样长。右值引用的第一个特点 通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去。让我们通过一个简单的例子来看看右值的生命周期。如代码清单1-1所示。代码清单1-112345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;int g_constructCount=0;int g_copyConstructCount=0;int g_destructCount=0;struct A&#123; A()&#123; cout&lt;&lt;&quot;construct: &quot;&lt;&lt;++g_constructCount&lt;&lt;endl; &#125; A(const A&amp; a) &#123; cout&lt;&lt;&quot;copy construct: &quot;&lt;&lt;++g_copyConstructCount &lt;&lt;endl; &#125; ~A() &#123; cout&lt;&lt;&quot;destruct: &quot;&lt;&lt;++g_destructCount&lt;&lt;endl; &#125;&#125;;A GetA()&#123; return A();&#125;int main() &#123; A a = GetA(); return 0;&#125; 为了清楚的观察临时值，在编译时设置编译选项-fno-elide-constructors用来关闭返回值优化效果。 输出结果：123456construct: 1copy construct: 1destruct: 1copy construct: 2destruct: 2destruct: 3 从上面的例子中可以看到，在没有返回值优化的情况下，拷贝构造函数调用了两次，一次是GetA()函数内部创建的对象返回出来构造一个临时对象产生的，另一次是在main函数中构造a对象产生的。第二次的destruct是因为临时对象在构造a对象之后就销毁了。如果开启返回值优化的话，输出结果将是：construct: 1destruct: 1 可以看到返回值优化将会把临时对象优化掉，但这不是c++标准，是各编译器的优化规则。我们在回到之前提到的可以通过右值引用来延长临时右值的生命周期，如果上面的代码中我们通过右值引用来绑定函数返回值的话，结果又会是什么样的呢？在编译时设置编译选项-fno-elide-constructors。123456789int main() &#123; A&amp;&amp; a = GetA(); return 0;&#125;输出结果：construct: 1copy construct: 1destruct: 1destruct: 2 通过右值引用，比之前少了一次拷贝构造和一次析构，原因在于右值引用绑定了右值，让临时右值的生命周期延长了。我们可以利用这个特点做一些性能优化，即避免临时对象的拷贝构造和析构，事实上，在c++98/03中，通过常量左值引用也经常用来做性能优化。上面的代码改成： const A&amp; a = GetA(); 输出的结果和右值引用一样，因为常量左值引用是一个“万能”的引用类型，可以接受左值、右值、常量左值和常量右值。需要注意的是普通的左值引用不能接受右值，比如这样的写法是不对的： A&amp; a = GetA(); 上面的代码会报一个编译错误，因为非常量左值引用只能接受左值。右值引用的第二个特点 右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值。比如下面的例子：1int&amp;&amp; var1 = 1; var1类型为右值引用，但var1本身是左值，因为具名变量都是左值。 关于右值引用一个有意思的问题是：T&amp;&amp;是什么，一定是右值吗？让我们来看看下面的例子：12345template&lt;typename T&gt;void f(T&amp;&amp; t)&#123;&#125;f(10); //t是右值int x = 10;f(x); //t是左值 从上面的代码中可以看到，T&amp;&amp;表示的值类型不确定，可能是左值又可能是右值，这一点看起来有点奇怪，这就是右值引用的一个特点。右值引用的第三个特点 T&amp;&amp; t在发生自动类型推断的时候，它是未定的引用类型（universal references），如果被一个左值初始化，它就是一个左值；如果它被一个右值初始化，它就是一个右值，它是左值还是右值取决于它的初始化。我们再回过头看上面的代码，对于函数templatevoid f(T&amp;&amp; t)，当参数为右值10的时候，根据universal references的特点，t被一个右值初始化，那么t就是右值；当参数为左值x时，t被一个左值引用初始化，那么t就是一个左值。需要注意的是，仅仅是当发生自动类型推导（如函数模板的类型自动推导，或auto关键字）的时候，T&amp;&amp;才是universal references。再看看下面的例子：1234567template&lt;typename T&gt;void f(T&amp;&amp; param); template&lt;typename T&gt;class Test &#123; Test(Test&amp;&amp; rhs); &#125;; 上面的例子中，param是universal reference，rhs是Test&amp;&amp;右值引用，因为模版函数f发生了类型推断，而Test&amp;&amp;并没有发生类型推导，因为Test&amp;&amp;是确定的类型了。 正是因为右值引用可能是左值也可能是右值，依赖于初始化，并不是一下子就确定的特点，我们可以利用这一点做很多文章，比如后面要介绍的移动语义和完美转发。 这里再提一下引用折叠，正是因为引入了右值引用，所以可能存在左值引用与右值引用和右值引用与右值引用的折叠，C++11确定了引用折叠的规则，规则是这样的：所有的右值引用叠加到右值引用上仍然还是一个右值引用；所有的其他引用类型之间的叠加都将变成左值引用。第3行代码的故事1T(T&amp;&amp; a) : m_val(val)&#123; a.m_val=nullptr; &#125; 这行代码实际上来自于一个类的构造函数，构造函数的一个参数是一个右值引用，为什么将右值引用作为构造函数的参数呢？在解答这个问题之前我们先看一个例子。如代码清单1-2所示。代码清单1-21234567891011121314151617181920class A&#123;public: A():m_ptr(new int(0))&#123;cout &lt;&lt; &quot;construct&quot; &lt;&lt; endl;&#125; A(const A&amp; a):m_ptr(new int(*a.m_ptr)) //深拷贝的拷贝构造函数 &#123; cout &lt;&lt; &quot;copy construct&quot; &lt;&lt; endl; &#125; ~A()&#123; delete m_ptr;&#125;private: int* m_ptr;&#125;;int main() &#123; A a = GetA(); return 0;&#125; 输出：constructcopy constructcopy construct 这个例子很简单，一个带有堆内存的类，必须提供一个深拷贝拷贝构造函数，因为默认的拷贝构造函数是浅拷贝，会发生“指针悬挂”的问题。如果不提供深拷贝的拷贝构造函数，上面的测试代码将会发生错误（编译选项-fno-elide-constructors），内部的m_ptr将会被删除两次，一次是临时右值析构的时候删除一次，第二次外面构造的a对象释放时删除一次，而这两个对象的m_ptr是同一个指针，这就是所谓的指针悬挂问题。提供深拷贝的拷贝构造函数虽然可以保证正确，但是在有些时候会造成额外的性能损耗，因为有时候这种深拷贝是不必要的。比如下面的代码： 上面代码中的GetA函数会返回临时变量，然后通过这个临时变量拷贝构造了一个新的对象a，临时变量在拷贝构造完成之后就销毁了，如果堆内存很大的话，那么，这个拷贝构造的代价会很大，带来了额外的性能损失。每次都会产生临时变量并造成额外的性能损失，有没有办法避免临时变量造成的性能损失呢？答案是肯定的，C++11已经有了解决方法，看看下面的代码。如代码清单1-3所示。代码清单1-3123456789101112131415161718192021222324class A&#123;public: A() :m_ptr(new int(0))&#123;&#125; A(const A&amp; a):m_ptr(new int(*a.m_ptr)) //深拷贝的拷贝构造函数 &#123; cout &lt;&lt; &quot;copy construct&quot; &lt;&lt; endl; &#125; A(A&amp;&amp; a) :m_ptr(a.m_ptr) &#123; a.m_ptr = nullptr; cout &lt;&lt; &quot;move construct&quot; &lt;&lt; endl; &#125; ~A()&#123; delete m_ptr;&#125;private: int* m_ptr;&#125;;int main()&#123; A a = Get(false); &#125; 输出：constructmove constructmove construct 代码清单1-3和1-2相比只多了一个构造函数，输出结果表明，并没有调用拷贝构造函数，只调用了move construct函数，让我们来看看这个move construct函数：12345A(A&amp;&amp; a) :m_ptr(a.m_ptr)&#123; a.m_ptr = nullptr; cout &lt;&lt; &quot;move construct&quot; &lt;&lt; endl;&#125; 这个构造函数并没有做深拷贝，仅仅是将指针的所有者转移到了另外一个对象，同时，将参数对象a的指针置为空，这里仅仅是做了浅拷贝，因此，这个构造函数避免了临时变量的深拷贝问题。 上面这个函数其实就是移动构造函数，他的参数是一个右值引用类型，这里的A&amp;&amp;表示右值，为什么？前面已经提到，这里没有发生类型推断，是确定的右值引用类型。为什么会匹配到这个构造函数？因为这个构造函数只能接受右值参数，而函数返回值是右值，所以就会匹配到这个构造函数。这里的A&amp;&amp;可以看作是临时值的标识，对于临时值我们仅仅需要做浅拷贝即可，无需再做深拷贝，从而解决了前面提到的临时变量拷贝构造产生的性能损失的问题。这就是所谓的移动语义，右值引用的一个重要作用是用来支持移动语义的。 需要注意的一个细节是，我们提供移动构造函数的同时也会提供一个拷贝构造函数，以防止移动不成功的时候还能拷贝构造，使我们的代码更安全。 我们知道移动语义是通过右值引用来匹配临时值的，那么，普通的左值是否也能借助移动语义来优化性能呢，那该怎么做呢？事实上C++11为了解决这个问题，提供了std::move方法来将左值转换为右值，从而方便应用移动语义。move是将对象资源的所有权从一个对象转移到另一个对象，只是转移，没有内存的拷贝，这就是所谓的move语义。如图1-1所示是深拷贝和move的区别。图1-1 深拷贝和move的区别 再看看下面的例子：1234567&#123; std::list&lt; std::string&gt; tokens; //省略初始化... std::list&lt; std::string&gt; t = tokens; //这里存在拷贝 &#125;std::list&lt; std::string&gt; tokens;std::list&lt; std::string&gt; t = std::move(tokens); //这里没有拷贝 如果不用std::move，拷贝的代价很大，性能较低。使用move几乎没有任何代价，只是转换了资源的所有权。他实际上将左值变成右值引用，然后应用移动语义，调用移动构造函数，就避免了拷贝，提高了程序性能。如果一个对象内部有较大的对内存或者动态数组时，很有必要写move语义的拷贝构造函数和赋值函数，避免无谓的深拷贝，以提高性能。事实上，C++11中所有的容器都实现了移动语义，方便我们做性能优化。 这里也要注意对move语义的误解，move实际上它并不能移动任何东西，它唯一的功能是将一个左值强制转换为一个右值引用。如果是一些基本类型比如int和char[10]定长数组等类型，使用move的话仍然会发生拷贝（因为没有对应的移动构造函数）。所以，move对于含资源（堆内存或句柄）的对象来说更有意义。第4行代码故事1template &lt;typename T&gt;void f(T&amp;&amp; val)&#123; foo(std::forward&lt;T&gt;(val)); &#125; C++11之前调用模板函数时，存在一个比较头疼的问题，如何正确的传递参数。比如：12345678910template &lt;typename T&gt;void forwardValue(T&amp; val)&#123; processValue(val); //右值参数会变成左值 &#125;template &lt;typename T&gt;void forwardValue(const T&amp; val)&#123; processValue(val); //参数都变成常量左值引用了 &#125;都不能按照参数的本来的类型进行转发。 C++11引入了完美转发：在函数模板中，完全依照模板的参数的类型（即保持参数的左值、右值特征），将参数传递给函数模板中调用的另外一个函数。C++11中的std::forward正是做这个事情的，他会按照参数的实际类型进行转发。看下面的例子：12345678910111213141516void processValue(int&amp; a)&#123; cout &lt;&lt; &quot;lvalue&quot; &lt;&lt; endl; &#125;void processValue(int&amp;&amp; a)&#123; cout &lt;&lt; &quot;rvalue&quot; &lt;&lt; endl; &#125;template &lt;typename T&gt;void forwardValue(T&amp;&amp; val)&#123; processValue(std::forward&lt;T&gt;(val)); //照参数本来的类型进行转发。&#125;void Testdelcl()&#123; int i = 0; forwardValue(i); //传入左值 forwardValue(0);//传入右值 &#125;输出：lvaue rvalue 右值引用T&amp;&amp;是一个universal references，可以接受左值或者右值，正是这个特性让他适合作为一个参数的路由，然后再通过std::forward按照参数的实际类型去匹配对应的重载函数，最终实现完美转发。 我们可以结合完美转发和移动语义来实现一个泛型的工厂函数，这个工厂函数可以创建所有类型的对象。具体实现如下：12345template&lt;typename… Args&gt;T* Instance(Args&amp;&amp;… args)&#123; return new T(std::forward&lt;Args &gt;(args)…);&#125; 这个工厂函数的参数是右值引用类型，内部使用std::forward按照参数的实际类型进行转发，如果参数的实际类型是右值，那么创建的时候会自动匹配移动构造，如果是左值则会匹配拷贝构造。总结 通过4行代码我们知道了什么是右值和右值引用，以及右值引用的一些特点，利用这些特点我们才方便实现移动语义和完美转发。C++11正是通过引入右值引用来优化性能，具体来说是通过移动语义来避免无谓拷贝的问题，通过move语义来将临时生成的左值中的资源无代价的转移到另外一个对象中去，通过完美转发来解决不能按照参数实际类型来转发的问题（同时，完美转发获得的一个好处是可以实现移动语义）。本文曾发表于《程序员》2015年1月刊。转载请注明出处。后记：本文的内容主要来自于我在公司内部培训的一次课程，因为很多人对C++11右值引用搞不清或者理解得不深入，所以我觉得有必要拿出来分享一下，让更多的人看到，就整理了一下发到程序员杂志了，我相信读者看完之后对右值引用会有全面深入的了解。一点梦想：尽自己一份力，让c++的世界变得更美好！","raw":"---\ntitle: 从4行代码看右值引用\ntags: C++\ncategories: C++\nabbrlink: 9d2f4ec8\ndate: 2019-05-23 14:50:40\ncopyright:\ntype:\nkeyword:\ntop:\ncomments:\npassword:\ndescription:\n---\n\n## 概述\n　　右值引用的概念有些读者可能会感到陌生，其实他和C++98/03中的左值引用有些类似，例如，c++98/03中的左值引用是这样的：\n\n```\nint i = 0;\nint& j = i;\n```\n\n　　这里的int&是对左值进行绑定（但是int&却不能绑定右值），相应的，对右值进行绑定的引用就是右值引用，他的语法是这样的A&&，通过双引号来表示绑定类型为A的右值。通过&&我们就可以很方便的绑定右值了，比如我们可以这样绑定一个右值：\n　　\n<!-- more -->　　\n\n```\nint&& i = 0;\n```\n\n　　这里我们绑定了一个右值0，关于右值的概念会在后面介绍。右值引用是C++11中新增加的一个很重要的特性，他主是要用来解决C++98/03中遇到的两个问题，第一个问题就是临时对象非必要的昂贵的拷贝操作，第二个问题是在模板函数中如何按照参数的实际类型进行转发。通过引入右值引用，很好的解决了这两个问题，改进了程序性能，后面将会详细介绍右值引用是如何解决这两个问题的。\n\n　　和右值引用相关的概念比较多，比如：右值、纯右值、将亡值、universal references、引用折叠、移动语义、move语义和完美转发等等。很多都是新概念，对于刚学习C++11右值引用的初学者来说，可能会觉得右值引用过于复杂，概念之间的关系难以理清。\n\n右值引用实际上并没有那么复杂，其实是关于4行代码的故事，通过简单的4行代码我们就能清晰的理解右值引用相关的概念了。本文希望带领读者通过4行代码来理解右值引用相关的概念，理清他们之间的关系，并最终能透彻地掌握C++11的新特性--右值引用。\n\n## 四行代码的故事\n### 第1行代码的故事\n```\nint i = getVar();\n```\n　　上面的这行代码很简单，从getVar()函数获取一个整形值，然而，这行代码会产生几种类型的值呢？答案是会产生两种类型的值，一种是左值i，一种是函数getVar()返回的临时值，这个临时值在表达式结束后就销毁了，而左值i在表达式结束后仍然存在，这个临时值就是右值，具体来说是一个纯右值，右值是不具名的。区分左值和右值的一个简单办法是：看能不能对表达式取地址，如果能，则为左值，否则为右值。\n\n　　所有的具名变量或对象都是左值，而匿名变量则是右值，比如，简单的赋值语句：\n\n```\nint i = 0;\n```\n\n　　在这条语句中，i 是左值，0 是字面量，就是右值。在上面的代码中，i 可以被引用，0 就不可以了。具体来说上面的表达式中等号右边的0是纯右值（prvalue），在C++11中所有的值必属于左值、将亡值、纯右值三者之一。比如，非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和lambda表达式等都是纯右值。而将亡值是C++11新增的、与右值引用相关的表达式，比如，将要被移动的对象、T&&函数返回值、std::move返回值和转换为T&&的类型的转换函数的返回值等。关于将亡值我们会在后面介绍，先看下面的代码：\n\n```\nint j = 5;\n\nauto f = []{return 5;};\n```\n\n　　上面的代码中5是一个原始字面量， []{return 5;}是一个lambda表达式，都是属于纯右值，他们的特点是在表达式结束之后就销毁了。\n\n　　通过地行代码我们对右值有了一个初步的认识，知道了什么是右值，接下来再来看看第二行代码。\n\n### 第2行代码的故事\n```\nT&& k = getVar();\n```\n　　第二行代码和第一行代码很像，只是相比第一行代码多了“&&”，他就是右值引用，我们知道左值引用是对左值的引用，那么，对应的，对右值的引用就是右值引用，而且右值是匿名变量，我们也只能通过引用的方式来获取右值。虽然第二行代码和第一行代码看起来差别不大，但是实际上语义的差别很大，这里，getVar()产生的临时值不会像第一行代码那样，在表达式结束之后就销毁了，而是会被“续命”，他的生命周期将会通过右值引用得以延续，和变量k的声明周期一样长。\n\n右值引用的第一个特点\n　　通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去。让我们通过一个简单的例子来看看右值的生命周期。如代码清单1-1所示。\n\n代码清单1-1 \n\n```\n#include <iostream>\nusing namespace std;\n\nint g_constructCount=0;\nint g_copyConstructCount=0;\nint g_destructCount=0;\nstruct A\n{\n    A(){\n        cout<<\"construct: \"<<++g_constructCount<<endl;    \n    }\n    \n    A(const A& a)\n    {\n        cout<<\"copy construct: \"<<++g_copyConstructCount <<endl;\n    }\n    ~A()\n    {\n        cout<<\"destruct: \"<<++g_destructCount<<endl;\n    }\n};\n\nA GetA()\n{\n    return A();\n}\n\nint main() {\n    A a = GetA();\n    return 0;\n}\n```\n\n　　为了清楚的观察临时值，在编译时设置编译选项-fno-elide-constructors用来关闭返回值优化效果。\n\n　　输出结果：\n\n```\nconstruct: 1\ncopy construct: 1\ndestruct: 1\ncopy construct: 2\ndestruct: 2\ndestruct: 3\n```\n　　从上面的例子中可以看到，在没有返回值优化的情况下，拷贝构造函数调用了两次，一次是GetA()函数内部创建的对象返回出来构造一个临时对象产生的，另一次是在main函数中构造a对象产生的。第二次的destruct是因为临时对象在构造a对象之后就销毁了。如果开启返回值优化的话，输出结果将是：\n\nconstruct: 1\n\ndestruct: 1\n\n　　可以看到返回值优化将会把临时对象优化掉，但这不是c++标准，是各编译器的优化规则。我们在回到之前提到的可以通过右值引用来延长临时右值的生命周期，如果上面的代码中我们通过右值引用来绑定函数返回值的话，结果又会是什么样的呢？在编译时设置编译选项-fno-elide-constructors。\n\n```\nint main() {\n    A&& a = GetA();\n    return 0;\n}\n输出结果：\nconstruct: 1\ncopy construct: 1\ndestruct: 1\ndestruct: 2\n```\n　　通过右值引用，比之前少了一次拷贝构造和一次析构，原因在于右值引用绑定了右值，让临时右值的生命周期延长了。我们可以利用这个特点做一些性能优化，即避免临时对象的拷贝构造和析构，事实上，在c++98/03中，通过常量左值引用也经常用来做性能优化。上面的代码改成：\n\n　　const A& a = GetA();\n\n　　输出的结果和右值引用一样，因为常量左值引用是一个“万能”的引用类型，可以接受左值、右值、常量左值和常量右值。需要注意的是普通的左值引用不能接受右值，比如这样的写法是不对的：\n\n　　A& a = GetA();\n\n　　上面的代码会报一个编译错误，因为非常量左值引用只能接受左值。\n\n右值引用的第二个特点\n　　右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值。比如下面的例子：\n\n```\nint&& var1 = 1; \n```\n\n　　var1类型为右值引用，但var1本身是左值，因为具名变量都是左值。\n\n　　关于右值引用一个有意思的问题是：T&&是什么，一定是右值吗？让我们来看看下面的例子：\n\n```\ntemplate<typename T>\nvoid f(T&& t){}\nf(10); //t是右值\nint x = 10;\nf(x); //t是左值\n```\n\n　　从上面的代码中可以看到，T&&表示的值类型不确定，可能是左值又可能是右值，这一点看起来有点奇怪，这就是右值引用的一个特点。\n\n右值引用的第三个特点\n　　T&& t在发生自动类型推断的时候，它是未定的引用类型（universal references），如果被一个左值初始化，它就是一个左值；如果它被一个右值初始化，它就是一个右值，它是左值还是右值取决于它的初始化。\n\n我们再回过头看上面的代码，对于函数template<typename T>void f(T&& t)，当参数为右值10的时候，根据universal references的特点，t被一个右值初始化，那么t就是右值；当参数为左值x时，t被一个左值引用初始化，那么t就是一个左值。需要注意的是，仅仅是当发生自动类型推导（如函数模板的类型自动推导，或auto关键字）的时候，T&&才是universal references。再看看下面的例子：\n\n```\ntemplate<typename T>\nvoid f(T&& param); \n\ntemplate<typename T>\nclass Test {\n    Test(Test&& rhs); \n};\n```\n　　上面的例子中，param是universal reference，rhs是Test&&右值引用，因为模版函数f发生了类型推断，而Test&&并没有发生类型推导，因为Test&&是确定的类型了。\n\n　　正是因为右值引用可能是左值也可能是右值，依赖于初始化，并不是一下子就确定的特点，我们可以利用这一点做很多文章，比如后面要介绍的移动语义和完美转发。\n\n　　这里再提一下引用折叠，正是因为引入了右值引用，所以可能存在左值引用与右值引用和右值引用与右值引用的折叠，C++11确定了引用折叠的规则，规则是这样的：\n\n*   所有的右值引用叠加到右值引用上仍然还是一个右值引用；\n*   所有的其他引用类型之间的叠加都将变成左值引用。\n\n### 第3行代码的故事\n```\nT(T&& a) : m_val(val){ a.m_val=nullptr; }\n```\n　　这行代码实际上来自于一个类的构造函数，构造函数的一个参数是一个右值引用，为什么将右值引用作为构造函数的参数呢？在解答这个问题之前我们先看一个例子。如代码清单1-2所示。\n\n代码清单1-2\n\n```\nclass A\n{\npublic:\n    A():m_ptr(new int(0)){cout << \"construct\" << endl;}\n    A(const A& a):m_ptr(new int(*a.m_ptr)) //深拷贝的拷贝构造函数\n    {\n        cout << \"copy construct\" << endl;\n    }\n    ~A(){ delete m_ptr;}\nprivate:\n    int* m_ptr;\n};\nint main() {\n    A a = GetA();\n    return 0;\n}\n    输出：\nconstruct\ncopy construct\ncopy construct\n```\n　　这个例子很简单，一个带有堆内存的类，必须提供一个深拷贝拷贝构造函数，因为默认的拷贝构造函数是浅拷贝，会发生“指针悬挂”的问题。如果不提供深拷贝的拷贝构造函数，上面的测试代码将会发生错误（编译选项-fno-elide-constructors），内部的m_ptr将会被删除两次，一次是临时右值析构的时候删除一次，第二次外面构造的a对象释放时删除一次，而这两个对象的m_ptr是同一个指针，这就是所谓的指针悬挂问题。提供深拷贝的拷贝构造函数虽然可以保证正确，但是在有些时候会造成额外的性能损耗，因为有时候这种深拷贝是不必要的。比如下面的代码：\n\n\n\n　　上面代码中的GetA函数会返回临时变量，然后通过这个临时变量拷贝构造了一个新的对象a，临时变量在拷贝构造完成之后就销毁了，如果堆内存很大的话，那么，这个拷贝构造的代价会很大，带来了额外的性能损失。每次都会产生临时变量并造成额外的性能损失，有没有办法避免临时变量造成的性能损失呢？答案是肯定的，C++11已经有了解决方法，看看下面的代码。如代码清单1-3所示。\n\n代码清单1-3\n\n```\nclass A\n{\npublic:\n    A() :m_ptr(new int(0)){}\n    A(const A& a):m_ptr(new int(*a.m_ptr)) //深拷贝的拷贝构造函数\n    {\n        cout << \"copy construct\" << endl;\n    }\n    A(A&& a) :m_ptr(a.m_ptr)\n    {\n        a.m_ptr = nullptr;\n        cout << \"move construct\" << endl;\n    }\n    ~A(){ delete m_ptr;}\nprivate:\n    int* m_ptr;\n};\nint main(){\n    A a = Get(false); \n} \n输出：\nconstruct\nmove construct\nmove construct\n```\n　　代码清单1-3和1-2相比只多了一个构造函数，输出结果表明，并没有调用拷贝构造函数，只调用了move construct函数，让我们来看看这个move construct函数：\n\n```\nA(A&& a) :m_ptr(a.m_ptr)\n{\n    a.m_ptr = nullptr;\n    cout << \"move construct\" << endl;\n}\n```\n\n　　这个构造函数并没有做深拷贝，仅仅是将指针的所有者转移到了另外一个对象，同时，将参数对象a的指针置为空，这里仅仅是做了浅拷贝，因此，这个构造函数避免了临时变量的深拷贝问题。\n\n　　上面这个函数其实就是移动构造函数，他的参数是一个右值引用类型，这里的A&&表示右值，为什么？前面已经提到，这里没有发生类型推断，是确定的右值引用类型。为什么会匹配到这个构造函数？因为这个构造函数只能接受右值参数，而函数返回值是右值，所以就会匹配到这个构造函数。这里的A&&可以看作是临时值的标识，对于临时值我们仅仅需要做浅拷贝即可，无需再做深拷贝，从而解决了前面提到的临时变量拷贝构造产生的性能损失的问题。这就是所谓的移动语义，右值引用的一个重要作用是用来支持移动语义的。\n\n　　需要注意的一个细节是，我们提供移动构造函数的同时也会提供一个拷贝构造函数，以防止移动不成功的时候还能拷贝构造，使我们的代码更安全。\n\n　　我们知道移动语义是通过右值引用来匹配临时值的，那么，普通的左值是否也能借助移动语义来优化性能呢，那该怎么做呢？事实上C++11为了解决这个问题，提供了std::move方法来将左值转换为右值，从而方便应用移动语义。move是将对象资源的所有权从一个对象转移到另一个对象，只是转移，没有内存的拷贝，这就是所谓的move语义。如图1-1所示是深拷贝和move的区别。\n\n\n\n图1-1 深拷贝和move的区别\n\n　　再看看下面的例子：\n\n```\n{\n    std::list< std::string> tokens;\n    //省略初始化...\n    std::list< std::string> t = tokens; //这里存在拷贝 \n}\nstd::list< std::string> tokens;\nstd::list< std::string> t = std::move(tokens);  //这里没有拷贝 \n```\n　　如果不用std::move，拷贝的代价很大，性能较低。使用move几乎没有任何代价，只是转换了资源的所有权。他实际上将左值变成右值引用，然后应用移动语义，调用移动构造函数，就避免了拷贝，提高了程序性能。如果一个对象内部有较大的对内存或者动态数组时，很有必要写move语义的拷贝构造函数和赋值函数，避免无谓的深拷贝，以提高性能。事实上，C++11中所有的容器都实现了移动语义，方便我们做性能优化。\n\n　　这里也要注意对move语义的误解，move实际上它并不能移动任何东西，它唯一的功能是将一个左值强制转换为一个右值引用。如果是一些基本类型比如int和char[10]定长数组等类型，使用move的话仍然会发生拷贝（因为没有对应的移动构造函数）。所以，move对于含资源（堆内存或句柄）的对象来说更有意义。\n\n### 第4行代码故事\n```\ntemplate <typename T>void f(T&& val){ foo(std::forward<T>(val)); }\n```\n　　C++11之前调用模板函数时，存在一个比较头疼的问题，如何正确的传递参数。比如： \n\n```\ntemplate <typename T>\nvoid forwardValue(T& val)\n{\n    processValue(val); //右值参数会变成左值 \n}\ntemplate <typename T>\nvoid forwardValue(const T& val)\n{\n    processValue(val); //参数都变成常量左值引用了 \n}\n```\n都不能按照参数的本来的类型进行转发。\n\n　　C++11引入了完美转发：在函数模板中，完全依照模板的参数的类型（即保持参数的左值、右值特征），将参数传递给函数模板中调用的另外一个函数。C++11中的std::forward正是做这个事情的，他会按照参数的实际类型进行转发。看下面的例子：\n\n```\nvoid processValue(int& a){ cout << \"lvalue\" << endl; }\nvoid processValue(int&& a){ cout << \"rvalue\" << endl; }\ntemplate <typename T>\nvoid forwardValue(T&& val)\n{\n    processValue(std::forward<T>(val)); //照参数本来的类型进行转发。\n}\nvoid Testdelcl()\n{\n    int i = 0;\n    forwardValue(i); //传入左值 \n    forwardValue(0);//传入右值 \n}\n输出：\nlvaue \nrvalue\n```\n　　右值引用T&&是一个universal references，可以接受左值或者右值，正是这个特性让他适合作为一个参数的路由，然后再通过std::forward按照参数的实际类型去匹配对应的重载函数，最终实现完美转发。\n\n　　我们可以结合完美转发和移动语义来实现一个泛型的工厂函数，这个工厂函数可以创建所有类型的对象。具体实现如下：\n\n```\ntemplate<typename…  Args>\nT* Instance(Args&&… args)\n{\n    return new T(std::forward<Args >(args)…);\n}\n```\n　　这个工厂函数的参数是右值引用类型，内部使用std::forward按照参数的实际类型进行转发，如果参数的实际类型是右值，那么创建的时候会自动匹配移动构造，如果是左值则会匹配拷贝构造。\n\n## 总结\n　　通过4行代码我们知道了什么是右值和右值引用，以及右值引用的一些特点，利用这些特点我们才方便实现移动语义和完美转发。C++11正是通过引入右值引用来优化性能，具体来说是通过移动语义来避免无谓拷贝的问题，通过move语义来将临时生成的左值中的资源无代价的转移到另外一个对象中去，通过完美转发来解决不能按照参数实际类型来转发的问题（同时，完美转发获得的一个好处是可以实现移动语义）。\n\n*本文曾发表于《程序员》2015年1月刊。转载请注明出处。*\n\n*后记：*本文的内容主要来自于我在公司内部培训的一次课程，因为很多人对C++11右值引用搞不清或者理解得不深入，所以我觉得有必要拿出来分享一下，让更多的人看到，就整理了一下发到程序员杂志了，我相信读者看完之后对右值引用会有全面深入的了解。\n\n \n\n一点梦想：尽自己一份力，让c++的世界变得更美好！","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>　　右值引用的概念有些读者可能会感到陌生，其实他和C++98/03中的左值引用有些类似，例如，c++98/03中的左值引用是这样的：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int i = 0;</span><br><span class=\"line\">int&amp; j = i;</span><br></pre></td></tr></table></figure><p>　　这里的int&amp;是对左值进行绑定（但是int&amp;却不能绑定右值），相应的，对右值进行绑定的引用就是右值引用，他的语法是这样的A&amp;&amp;，通过双引号来表示绑定类型为A的右值。通过&amp;&amp;我们就可以很方便的绑定右值了，比如我们可以这样绑定一个右值：<br>　　<br><a id=\"more\"></a>　　</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int&amp;&amp; i = 0;</span><br></pre></td></tr></table></figure><p>　　这里我们绑定了一个右值0，关于右值的概念会在后面介绍。右值引用是C++11中新增加的一个很重要的特性，他主是要用来解决C++98/03中遇到的两个问题，第一个问题就是临时对象非必要的昂贵的拷贝操作，第二个问题是在模板函数中如何按照参数的实际类型进行转发。通过引入右值引用，很好的解决了这两个问题，改进了程序性能，后面将会详细介绍右值引用是如何解决这两个问题的。</p><p>　　和右值引用相关的概念比较多，比如：右值、纯右值、将亡值、universal references、引用折叠、移动语义、move语义和完美转发等等。很多都是新概念，对于刚学习C++11右值引用的初学者来说，可能会觉得右值引用过于复杂，概念之间的关系难以理清。</p><p>右值引用实际上并没有那么复杂，其实是关于4行代码的故事，通过简单的4行代码我们就能清晰的理解右值引用相关的概念了。本文希望带领读者通过4行代码来理解右值引用相关的概念，理清他们之间的关系，并最终能透彻地掌握C++11的新特性–右值引用。</p><h2 id=\"四行代码的故事\"><a href=\"#四行代码的故事\" class=\"headerlink\" title=\"四行代码的故事\"></a>四行代码的故事</h2><h3 id=\"第1行代码的故事\"><a href=\"#第1行代码的故事\" class=\"headerlink\" title=\"第1行代码的故事\"></a>第1行代码的故事</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int i = getVar();</span><br></pre></td></tr></table></figure><p>　　上面的这行代码很简单，从getVar()函数获取一个整形值，然而，这行代码会产生几种类型的值呢？答案是会产生两种类型的值，一种是左值i，一种是函数getVar()返回的临时值，这个临时值在表达式结束后就销毁了，而左值i在表达式结束后仍然存在，这个临时值就是右值，具体来说是一个纯右值，右值是不具名的。区分左值和右值的一个简单办法是：看能不能对表达式取地址，如果能，则为左值，否则为右值。</p><p>　　所有的具名变量或对象都是左值，而匿名变量则是右值，比如，简单的赋值语句：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int i = 0;</span><br></pre></td></tr></table></figure><p>　　在这条语句中，i 是左值，0 是字面量，就是右值。在上面的代码中，i 可以被引用，0 就不可以了。具体来说上面的表达式中等号右边的0是纯右值（prvalue），在C++11中所有的值必属于左值、将亡值、纯右值三者之一。比如，非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和lambda表达式等都是纯右值。而将亡值是C++11新增的、与右值引用相关的表达式，比如，将要被移动的对象、T&amp;&amp;函数返回值、std::move返回值和转换为T&amp;&amp;的类型的转换函数的返回值等。关于将亡值我们会在后面介绍，先看下面的代码：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int j = 5;</span><br><span class=\"line\"></span><br><span class=\"line\">auto f = []&#123;return 5;&#125;;</span><br></pre></td></tr></table></figure><p>　　上面的代码中5是一个原始字面量， []{return 5;}是一个lambda表达式，都是属于纯右值，他们的特点是在表达式结束之后就销毁了。</p><p>　　通过地行代码我们对右值有了一个初步的认识，知道了什么是右值，接下来再来看看第二行代码。</p><h3 id=\"第2行代码的故事\"><a href=\"#第2行代码的故事\" class=\"headerlink\" title=\"第2行代码的故事\"></a>第2行代码的故事</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T&amp;&amp; k = getVar();</span><br></pre></td></tr></table></figure><p>　　第二行代码和第一行代码很像，只是相比第一行代码多了“&amp;&amp;”，他就是右值引用，我们知道左值引用是对左值的引用，那么，对应的，对右值的引用就是右值引用，而且右值是匿名变量，我们也只能通过引用的方式来获取右值。虽然第二行代码和第一行代码看起来差别不大，但是实际上语义的差别很大，这里，getVar()产生的临时值不会像第一行代码那样，在表达式结束之后就销毁了，而是会被“续命”，他的生命周期将会通过右值引用得以延续，和变量k的声明周期一样长。</p><p>右值引用的第一个特点<br>　　通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去。让我们通过一个简单的例子来看看右值的生命周期。如代码清单1-1所示。</p><p>代码清单1-1</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int g_constructCount=0;</span><br><span class=\"line\">int g_copyConstructCount=0;</span><br><span class=\"line\">int g_destructCount=0;</span><br><span class=\"line\">struct A</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    A()&#123;</span><br><span class=\"line\">        cout&lt;&lt;&quot;construct: &quot;&lt;&lt;++g_constructCount&lt;&lt;endl;    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    A(const A&amp; a)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;&quot;copy construct: &quot;&lt;&lt;++g_copyConstructCount &lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~A()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;&quot;destruct: &quot;&lt;&lt;++g_destructCount&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">A GetA()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return A();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    A a = GetA();</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>　　为了清楚的观察临时值，在编译时设置编译选项-fno-elide-constructors用来关闭返回值优化效果。</p><p>　　输出结果：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">construct: 1</span><br><span class=\"line\">copy construct: 1</span><br><span class=\"line\">destruct: 1</span><br><span class=\"line\">copy construct: 2</span><br><span class=\"line\">destruct: 2</span><br><span class=\"line\">destruct: 3</span><br></pre></td></tr></table></figure><p>　　从上面的例子中可以看到，在没有返回值优化的情况下，拷贝构造函数调用了两次，一次是GetA()函数内部创建的对象返回出来构造一个临时对象产生的，另一次是在main函数中构造a对象产生的。第二次的destruct是因为临时对象在构造a对象之后就销毁了。如果开启返回值优化的话，输出结果将是：</p><p>construct: 1</p><p>destruct: 1</p><p>　　可以看到返回值优化将会把临时对象优化掉，但这不是c++标准，是各编译器的优化规则。我们在回到之前提到的可以通过右值引用来延长临时右值的生命周期，如果上面的代码中我们通过右值引用来绑定函数返回值的话，结果又会是什么样的呢？在编译时设置编译选项-fno-elide-constructors。</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    A&amp;&amp; a = GetA();</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">输出结果：</span><br><span class=\"line\">construct: 1</span><br><span class=\"line\">copy construct: 1</span><br><span class=\"line\">destruct: 1</span><br><span class=\"line\">destruct: 2</span><br></pre></td></tr></table></figure><p>　　通过右值引用，比之前少了一次拷贝构造和一次析构，原因在于右值引用绑定了右值，让临时右值的生命周期延长了。我们可以利用这个特点做一些性能优化，即避免临时对象的拷贝构造和析构，事实上，在c++98/03中，通过常量左值引用也经常用来做性能优化。上面的代码改成：</p><p>　　const A&amp; a = GetA();</p><p>　　输出的结果和右值引用一样，因为常量左值引用是一个“万能”的引用类型，可以接受左值、右值、常量左值和常量右值。需要注意的是普通的左值引用不能接受右值，比如这样的写法是不对的：</p><p>　　A&amp; a = GetA();</p><p>　　上面的代码会报一个编译错误，因为非常量左值引用只能接受左值。</p><p>右值引用的第二个特点<br>　　右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值。比如下面的例子：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int&amp;&amp; var1 = 1;</span><br></pre></td></tr></table></figure><p>　　var1类型为右值引用，但var1本身是左值，因为具名变量都是左值。</p><p>　　关于右值引用一个有意思的问题是：T&amp;&amp;是什么，一定是右值吗？让我们来看看下面的例子：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">void f(T&amp;&amp; t)&#123;&#125;</span><br><span class=\"line\">f(10); //t是右值</span><br><span class=\"line\">int x = 10;</span><br><span class=\"line\">f(x); //t是左值</span><br></pre></td></tr></table></figure><p>　　从上面的代码中可以看到，T&amp;&amp;表示的值类型不确定，可能是左值又可能是右值，这一点看起来有点奇怪，这就是右值引用的一个特点。</p><p>右值引用的第三个特点<br>　　T&amp;&amp; t在发生自动类型推断的时候，它是未定的引用类型（universal references），如果被一个左值初始化，它就是一个左值；如果它被一个右值初始化，它就是一个右值，它是左值还是右值取决于它的初始化。</p><p>我们再回过头看上面的代码，对于函数template<typename t=\"\">void f(T&amp;&amp; t)，当参数为右值10的时候，根据universal references的特点，t被一个右值初始化，那么t就是右值；当参数为左值x时，t被一个左值引用初始化，那么t就是一个左值。需要注意的是，仅仅是当发生自动类型推导（如函数模板的类型自动推导，或auto关键字）的时候，T&amp;&amp;才是universal references。再看看下面的例子：</typename></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">void f(T&amp;&amp; param); </span><br><span class=\"line\"></span><br><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">class Test &#123;</span><br><span class=\"line\">    Test(Test&amp;&amp; rhs); </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p>　　上面的例子中，param是universal reference，rhs是Test&amp;&amp;右值引用，因为模版函数f发生了类型推断，而Test&amp;&amp;并没有发生类型推导，因为Test&amp;&amp;是确定的类型了。</p><p>　　正是因为右值引用可能是左值也可能是右值，依赖于初始化，并不是一下子就确定的特点，我们可以利用这一点做很多文章，比如后面要介绍的移动语义和完美转发。</p><p>　　这里再提一下引用折叠，正是因为引入了右值引用，所以可能存在左值引用与右值引用和右值引用与右值引用的折叠，C++11确定了引用折叠的规则，规则是这样的：</p><ul><li>所有的右值引用叠加到右值引用上仍然还是一个右值引用；</li><li>所有的其他引用类型之间的叠加都将变成左值引用。</li></ul><h3 id=\"第3行代码的故事\"><a href=\"#第3行代码的故事\" class=\"headerlink\" title=\"第3行代码的故事\"></a>第3行代码的故事</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T(T&amp;&amp; a) : m_val(val)&#123; a.m_val=nullptr; &#125;</span><br></pre></td></tr></table></figure><p>　　这行代码实际上来自于一个类的构造函数，构造函数的一个参数是一个右值引用，为什么将右值引用作为构造函数的参数呢？在解答这个问题之前我们先看一个例子。如代码清单1-2所示。</p><p>代码清单1-2</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class A</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    A():m_ptr(new int(0))&#123;cout &lt;&lt; &quot;construct&quot; &lt;&lt; endl;&#125;</span><br><span class=\"line\">    A(const A&amp; a):m_ptr(new int(*a.m_ptr)) //深拷贝的拷贝构造函数</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;copy construct&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~A()&#123; delete m_ptr;&#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    int* m_ptr;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    A a = GetA();</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    输出：</span><br><span class=\"line\">construct</span><br><span class=\"line\">copy construct</span><br><span class=\"line\">copy construct</span><br></pre></td></tr></table></figure><p>　　这个例子很简单，一个带有堆内存的类，必须提供一个深拷贝拷贝构造函数，因为默认的拷贝构造函数是浅拷贝，会发生“指针悬挂”的问题。如果不提供深拷贝的拷贝构造函数，上面的测试代码将会发生错误（编译选项-fno-elide-constructors），内部的m_ptr将会被删除两次，一次是临时右值析构的时候删除一次，第二次外面构造的a对象释放时删除一次，而这两个对象的m_ptr是同一个指针，这就是所谓的指针悬挂问题。提供深拷贝的拷贝构造函数虽然可以保证正确，但是在有些时候会造成额外的性能损耗，因为有时候这种深拷贝是不必要的。比如下面的代码：</p><p>　　上面代码中的GetA函数会返回临时变量，然后通过这个临时变量拷贝构造了一个新的对象a，临时变量在拷贝构造完成之后就销毁了，如果堆内存很大的话，那么，这个拷贝构造的代价会很大，带来了额外的性能损失。每次都会产生临时变量并造成额外的性能损失，有没有办法避免临时变量造成的性能损失呢？答案是肯定的，C++11已经有了解决方法，看看下面的代码。如代码清单1-3所示。</p><p>代码清单1-3</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class A</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    A() :m_ptr(new int(0))&#123;&#125;</span><br><span class=\"line\">    A(const A&amp; a):m_ptr(new int(*a.m_ptr)) //深拷贝的拷贝构造函数</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;copy construct&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    A(A&amp;&amp; a) :m_ptr(a.m_ptr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        a.m_ptr = nullptr;</span><br><span class=\"line\">        cout &lt;&lt; &quot;move construct&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~A()&#123; delete m_ptr;&#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    int* m_ptr;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    A a = Get(false); </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">输出：</span><br><span class=\"line\">construct</span><br><span class=\"line\">move construct</span><br><span class=\"line\">move construct</span><br></pre></td></tr></table></figure><p>　　代码清单1-3和1-2相比只多了一个构造函数，输出结果表明，并没有调用拷贝构造函数，只调用了move construct函数，让我们来看看这个move construct函数：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A(A&amp;&amp; a) :m_ptr(a.m_ptr)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    a.m_ptr = nullptr;</span><br><span class=\"line\">    cout &lt;&lt; &quot;move construct&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>　　这个构造函数并没有做深拷贝，仅仅是将指针的所有者转移到了另外一个对象，同时，将参数对象a的指针置为空，这里仅仅是做了浅拷贝，因此，这个构造函数避免了临时变量的深拷贝问题。</p><p>　　上面这个函数其实就是移动构造函数，他的参数是一个右值引用类型，这里的A&amp;&amp;表示右值，为什么？前面已经提到，这里没有发生类型推断，是确定的右值引用类型。为什么会匹配到这个构造函数？因为这个构造函数只能接受右值参数，而函数返回值是右值，所以就会匹配到这个构造函数。这里的A&amp;&amp;可以看作是临时值的标识，对于临时值我们仅仅需要做浅拷贝即可，无需再做深拷贝，从而解决了前面提到的临时变量拷贝构造产生的性能损失的问题。这就是所谓的移动语义，右值引用的一个重要作用是用来支持移动语义的。</p><p>　　需要注意的一个细节是，我们提供移动构造函数的同时也会提供一个拷贝构造函数，以防止移动不成功的时候还能拷贝构造，使我们的代码更安全。</p><p>　　我们知道移动语义是通过右值引用来匹配临时值的，那么，普通的左值是否也能借助移动语义来优化性能呢，那该怎么做呢？事实上C++11为了解决这个问题，提供了std::move方法来将左值转换为右值，从而方便应用移动语义。move是将对象资源的所有权从一个对象转移到另一个对象，只是转移，没有内存的拷贝，这就是所谓的move语义。如图1-1所示是深拷贝和move的区别。</p><p>图1-1 深拷贝和move的区别</p><p>　　再看看下面的例子：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    std::list&lt; std::string&gt; tokens;</span><br><span class=\"line\">    //省略初始化...</span><br><span class=\"line\">    std::list&lt; std::string&gt; t = tokens; //这里存在拷贝 </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">std::list&lt; std::string&gt; tokens;</span><br><span class=\"line\">std::list&lt; std::string&gt; t = std::move(tokens);  //这里没有拷贝</span><br></pre></td></tr></table></figure><p>　　如果不用std::move，拷贝的代价很大，性能较低。使用move几乎没有任何代价，只是转换了资源的所有权。他实际上将左值变成右值引用，然后应用移动语义，调用移动构造函数，就避免了拷贝，提高了程序性能。如果一个对象内部有较大的对内存或者动态数组时，很有必要写move语义的拷贝构造函数和赋值函数，避免无谓的深拷贝，以提高性能。事实上，C++11中所有的容器都实现了移动语义，方便我们做性能优化。</p><p>　　这里也要注意对move语义的误解，move实际上它并不能移动任何东西，它唯一的功能是将一个左值强制转换为一个右值引用。如果是一些基本类型比如int和char[10]定长数组等类型，使用move的话仍然会发生拷贝（因为没有对应的移动构造函数）。所以，move对于含资源（堆内存或句柄）的对象来说更有意义。</p><h3 id=\"第4行代码故事\"><a href=\"#第4行代码故事\" class=\"headerlink\" title=\"第4行代码故事\"></a>第4行代码故事</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;void f(T&amp;&amp; val)&#123; foo(std::forward&lt;T&gt;(val)); &#125;</span><br></pre></td></tr></table></figure><p>　　C++11之前调用模板函数时，存在一个比较头疼的问题，如何正确的传递参数。比如：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void forwardValue(T&amp; val)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    processValue(val); //右值参数会变成左值 </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void forwardValue(const T&amp; val)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    processValue(val); //参数都变成常量左值引用了 </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>都不能按照参数的本来的类型进行转发。</p><p>　　C++11引入了完美转发：在函数模板中，完全依照模板的参数的类型（即保持参数的左值、右值特征），将参数传递给函数模板中调用的另外一个函数。C++11中的std::forward正是做这个事情的，他会按照参数的实际类型进行转发。看下面的例子：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void processValue(int&amp; a)&#123; cout &lt;&lt; &quot;lvalue&quot; &lt;&lt; endl; &#125;</span><br><span class=\"line\">void processValue(int&amp;&amp; a)&#123; cout &lt;&lt; &quot;rvalue&quot; &lt;&lt; endl; &#125;</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void forwardValue(T&amp;&amp; val)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    processValue(std::forward&lt;T&gt;(val)); //照参数本来的类型进行转发。</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void Testdelcl()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int i = 0;</span><br><span class=\"line\">    forwardValue(i); //传入左值 </span><br><span class=\"line\">    forwardValue(0);//传入右值 </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">输出：</span><br><span class=\"line\">lvaue </span><br><span class=\"line\">rvalue</span><br></pre></td></tr></table></figure><p>　　右值引用T&amp;&amp;是一个universal references，可以接受左值或者右值，正是这个特性让他适合作为一个参数的路由，然后再通过std::forward按照参数的实际类型去匹配对应的重载函数，最终实现完美转发。</p><p>　　我们可以结合完美转发和移动语义来实现一个泛型的工厂函数，这个工厂函数可以创建所有类型的对象。具体实现如下：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename…  Args&gt;</span><br><span class=\"line\">T* Instance(Args&amp;&amp;… args)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return new T(std::forward&lt;Args &gt;(args)…);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>　　这个工厂函数的参数是右值引用类型，内部使用std::forward按照参数的实际类型进行转发，如果参数的实际类型是右值，那么创建的时候会自动匹配移动构造，如果是左值则会匹配拷贝构造。</p><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>　　通过4行代码我们知道了什么是右值和右值引用，以及右值引用的一些特点，利用这些特点我们才方便实现移动语义和完美转发。C++11正是通过引入右值引用来优化性能，具体来说是通过移动语义来避免无谓拷贝的问题，通过move语义来将临时生成的左值中的资源无代价的转移到另外一个对象中去，通过完美转发来解决不能按照参数实际类型来转发的问题（同时，完美转发获得的一个好处是可以实现移动语义）。</p><p><em>本文曾发表于《程序员》2015年1月刊。转载请注明出处。</em></p><p><em>后记：</em>本文的内容主要来自于我在公司内部培训的一次课程，因为很多人对C++11右值引用搞不清或者理解得不深入，所以我觉得有必要拿出来分享一下，让更多的人看到，就整理了一下发到程序员杂志了，我相信读者看完之后对右值引用会有全面深入的了解。</p><p>一点梦想：尽自己一份力，让c++的世界变得更美好！</p>","slug":"右值引用","updated":"2019-05-23T12:33:08.394Z","comments":true,"link":"","permalink":"https://shuntan.github.io/posts/9d2f4ec8/","excerpt":"概述 右值引用的概念有些读者可能会感到陌生，其实他和C++98/03中的左值引用有些类似，例如，c++98/03中的左值引用是这样的：12int i = 0;int&amp; j = i; 这里的int&amp;是对左值进行绑定（但是int&amp;却不能绑定右值），相应的，对右值进行绑定的引用就是右值引用，他的语法是这样的A&amp;&amp;，通过双引号来表示绑定类型为A的右值。通过&amp;&amp;我们就可以很方便的绑定右值了，比如我们可以这样绑定一个右值：","categories":[{"name":"C++","slug":"C","permalink":"https://shuntan.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://shuntan.github.io/tags/C/"}]},{"title":"squid介绍及其简单配置","date":"2019-05-15T07:15:30.000Z","path":"posts/55e3d16d/","text":"squid的概念squid是一种用来缓存Internet数据的软件。接受来自人们需要下载的目标（object）的请求并适当的处理这些请求。也就是说，如果一个人想下载一web界面，他请求squid为他取得这个页面。squid随之连接到远程服务器并向这个页面发出请求。然后，squid显式地聚集数据到客户端机器，而且同时复制一份。当下一次有人需要同一页面时， squid可以简单的从磁盘中读到它，那样数据会立即传输到客户机上。下载地址squid-cache 官网 http://www.squid-cache.orgsquid介绍及其简单配置 https://www.cnblogs.com/cherishry/p/5706736.htmlCentOS 7安装squid代理服务器 https://blog.csdn.net/ithomer/article/details/78136993squid代理的作用通过缓存的方式为用户提供Web访问加速对用户的Web访问进行过滤控制工作流程当代理服务器中有客户端需要的数据时：a.客户端向代理服务器发送数据请求；b.代理服务器检查自己的数据缓存；c.代理服务器在缓存中找到了用户想要的数据，取出数据；d.代理服务器将从缓存中取得的数据返回给客户端。当代理服务器中没有客户端需要的数据时了：1.客户端向代理服务器发送数据请求；2.代理服务器检查自己的数据缓存；3.代理服务器在缓存中没有找到用户想要的数据；4.代理服务器向Internet 上的远端服务器发送数据请求；5.远端服务器响应，返回相应的数据；6.代理服务器取得远端服务器的数据，返回给客户端，并保留一份到自己的数据缓存中。Squid代理服务器工作在TCP/IP应用层Squid各种代理的定义正向代理标准的代理缓冲服务器一个标准的代理缓冲服务被用于缓存静态的网页到本地网络上的一台主机上（即代理服务器）。当被缓存的页面被第二次访问的时候，浏览器将直接从本地代理服务器那里获取请求数据而不再向原web站点请求数据。这样就节省了宝贵的网络带宽，而且提高了访问速度。但是，要想实现这种方式，必须在每一个内部主机的浏览器上明确指名代理服务器的IP地址和端口号。客户端上网时，每次都把请求发送给代理服务器处理,代理服务器根据请求确定是否连接到远程web服务器获取数据。如果在本地缓冲区有目标文件，则直接将文件传给用户即可。如果没有的话则先取回文件，先在本地保存一份缓冲，然后将文件发送给客户端浏览器。透明代理缓冲服务器透明代理缓冲服务器和标准代理服务器的功能完全相同。但是，代理操作对客户端的浏览器是透明的（即不需指明代理服务器的IP和端口）。透明代理服务器阻断网络通信，并且过滤出访问外部的HTTP（80端口）流量。如果客户端的请求在本地有缓冲则将缓冲的数据直接发给用户，如果在本地没有缓冲则向远程web服务器发出请求，其余操作和标准的代理服务器完全相同。对于linux操作系统来说，透明代理使用Iptables或者Ipchains实现。因此不需要对浏览器作任何设置，所以，透明代理对于ISP（Internet服务器提供商）特别有用。反向代理反向代理缓冲器反向代理是和前两种代理完全不同的一种代理服务。使用它可以降低原始WEB服务器的负载。反向代理服务器承担了对原始WEB服务器的静态页面的请求，防止原始服务器过载。它位于WEB服务器和Internet之间，处理所有对WEB服务器的请求，组织了WEB服务器和Internet的直接通信。如果互联网用户请求的页面在代理服务器上有缓冲的话，代理服务器直接将缓冲内容发送给用户。如果没有缓冲则先向WEB服务器发出请求，取回数据，本地缓存后再发给用户。这种方式通过降低了WEB服务器的请求数从而降低了WEB服务器的负载。正向代理与反向代理的区别概念正向代理：对于原始服务器而言，就是客户端的代言人反向代理：对于客户端而言，就像是原始服务器用途正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。反向代理还可以为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。另外，反向代理还可以启用高级URL策略和管理技术，从而使处于不同web服务器系统的web页面同时存在于同一个URL空间下。安全性正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。Squid主要组成部分服务名：squid主程序：/usr/sbin/squid配置目录：/etc/squid主配置文件：/etc/squid/squid.conf监听tcp端口号：3128默认访问日志文件：/var/log/squid/access.logsquid常用配置选项/etc/squid/squid.conf123456789101112131415http_port 3128 (还可以只监听一个IP http_port 192.168.0.1:3128)cache_mem 64MB #缓存占内存大小maximum_object_size 4096KB #最大缓存块reply_body_max_size 1024000 allow all #限定下载文件大小access_log /var/log/squid/access.log #访问日志存放的地方visible_hostname proxy.test.xom #可见的主机名cache_dir ufs /var/spool/squid 100 16 256 #ufs:缓存数据的存储格式#/var/spool/squid 缓存目录#100：缓存目录占磁盘空间大小（M）#16：缓存空间一级子目录个数#256：缓存空间二级子目录个数cache_mgr webmaster@test.com #定义管理员邮箱http_access deny all #访问控制squid中的访问控制使用访问控制特性，可以控制在访问时根据特定的时间间隔进行缓存、访问特定站点或一组站点等等。squid访问控制有两个要素：ACL元素和访问列表。访问列表可以允许或拒绝某些用户对此服务的访问。ACL元素类型src：源地址（即客户机IP地址）dst：目标地址（即服务器IP地址）srcdomain：源名称（即客户机名称）dstdomain：目标名称（即服务器名称）time：一天中的时刻和一周内的一天url_regex：URL规则表达式匹配urlpath_regex：URL-path规则表达式匹配，略去协议和主机名proxy_auth：通过外部程序进行用户验证maxconn：单一IP的最大连接数ACL格式为了使用控制功能，必须先设置ACL规则并应用。ACL声明的格式如下： 注：acl_element_name 可以是任一个在ACL中定义的名称任何两个ACL元素不能用相同的名字每个ACL由列表值组成。当进行匹配检测的时候，多个值由逻辑或运算连接；换言之，即任一ACL元素的值被匹配，则这个ACL元素即被匹配。并不是所有ACL元素都能使用访问列表中的全部类型不同的ACL元素写在不同行中，squid将把他们组合在一个列表中访问条目我们可以使用许多不同的访问条目。下面是我们常用的几个：http_access:允许HTTP访问no_cache:定义对缓存请求的响应。访问列表的规则由一些类似’allow’或‘deny’的关键字构成，用以允许或拒绝向特定或一组ACL元素提供服务。一个访问列表可以由多条规则组成如果没有任何规则与访问请求匹配，默认动作将与列表中最后一条规则对应。一个访问条目中所有元素将用逻辑与运算连接http_access Action 声明1 AND 声明2 AND 声明 OR.http_access Action 声明3多个http_accesss声明间用或运算连接，但每个访问条目的元素间用与运算连接。列表中的规则总是遵循由上而下的顺序这些规则按照他们的排列顺序进行匹配检测，一旦检测到匹配的规则，匹配就立即结束。Squid.conf配置文件详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#acl all src 0.0.0.0/0.0.0.0 and http_access allow all选项定义了一个访问控制列表。详细情况参见和Squid软件#携带的文档。这里的访问控制列表允许所有对代理服务的访问，因为这里该代理是加速web服务器。acl all src 0.0.0.0/0.0.0.0 #允许所有IP访问acl manager proto http #manager url协议为httpacl localhost src 127.0.0.1/255.255.255.255 #允午本机IPacl to_localhost dst 127.0.0.1 #允午目的地址为本机IPacl Safe_ports port 80 # 允许安全更新的端口为80acl CONNECT method CONNECT #请求方法以CONNECThttp_access allow all #允许所有人使用该代理.因为这里是代理加速web服务器http_reply_access allow all #允许所有客户端使用该代理acl OverConnLimit maxconn 16 #限制每个IP最大允许16个连接，防止攻击http_access deny OverConnLimiticp_access deny all #禁止从邻居服务器缓冲内发送和接收ICP请求.miss_access allow all #允许直接更新请求ident_lookup_access deny all #禁止lookup检查DNShttp_port 8080 transparent #指定Squid监听浏览器客户请求的端口号。hierarchy_stoplist cgi-bin ? #用来强制某些特定的对象不被缓存，主要是处于安全的目的。acl QUERY urlpath_regex cgi-bin \\?cache deny QUERYcache_mem 1 GB #这是一个优化选项，增加该内存值有利于缓存。应该注意的是： #一般来说如果系统有内存，设置该值为(n/)3M。现在是3G 所以这里1Gfqdncache_size 1024 #FQDN 高速缓存大小maximum_object_size_in_memory 2 MB #允许最大的文件载入内存memory_replacement_policy heap LFUDA #动态使用最小的，移出内存cachecache_replacement_policy heap LFUDA #动态使用最小的，移出硬盘cachecache_dir ufs /home/cache 5000 32 512 #高速缓存目录 ufs 类型 使用的缓冲值最大允午1000MB空间，#32个一级目录，512个二级目录max_open_disk_fds 0 #允许最大打开文件数量,0 无限制minimum_object_size 1 KB #允午最小文件请求体大小maximum_object_size 20 MB #允午最大文件请求体大小cache_swap_low 90 #最小允许使用swap 90%cache_swap_high 95 #最多允许使用swap 95%ipcache_size 2048 # IP 地址高速缓存大小 2Mipcache_low 90 #最小允许ipcache使用swap 90%ipcache_high 95 #最大允许ipcache使用swap 90%access_log /var/log/squid/access.log squid #定义日志存放记录cache_log /var/log/squid/cache.log squidcache_store_log none #禁止store日志emulate_httpd_log on #将使Squid仿照Web服务器的格式创建访问记录。如果希望使用 #Web访问记录分析程序，就需要设置这个参数。refresh_pattern . 0 20% 4320 override-expire override-lastmod reload-into-ims ignore-reload #更新cache规则acl buggy_server url_regex ^http://.... http:// #只允许http的请求broken_posts allow buggy_serveracl apache rep_header Server ^Apache #允许apache的编码broken_vary_encoding allow apacherequest_entities off #禁止非http的标分准请求，防止攻击header_access header allow all #允许所有的http报头relaxed_header_parser on #不严格分析http报头.client_lifetime 120 minute #最大客户连接时间 120分钟cache_mgr sky@test.com #指定当缓冲出现问题时向缓冲管理者发送告警信息的地址信息。cache_effective_user squid #这里以用户squid的身份Squid服务器cache_effective_group squidicp_port 0 #指定Squid从邻居服务器缓冲内发送和接收ICP请求的端口号。 #这里设置为0是因为这里配置Squid为内部Web服务器的加速器， #所以不需要使用邻居服务器的缓冲。0是禁用# cache_peer 设置允许更新缓存的主机，因是本机所以127.0.0.1cache_peer 127.0.0.1 parent 80 0 no-query default multicast-responder no-netdb-exchangecache_peer_domain 127.0.0.1 hostname_aliases 127.0.0.1error_directory /usr/share/squid/errors/Simplify_Chinese #定义错误路径always_direct allow all # cache丢失或不存在是允许所有请求直接转发到原始服务器ignore_unknown_nameservers on #开反DNS查询，当域名地址不相同时候，禁止访问coredump_dir /var/log/squid #定义dump的目录max_filedesc 2048 #最大打开的文件描述half_closed_clients off #使Squid在当read不再返回数据时立即关闭客户端的连接。 #有时read不再返回数据是由于某些客户关闭TCP的发送数据 #而仍然保持接收数据。而Squid分辨不出TCP半关闭和完全关闭。buffered_logs on #若打开选项“buffered_logs”可以稍稍提高加速某些对日志文件的写入，该选项主要是实现优化特性。#防止天涯盗链，转嫁给百度acl tianya referer_regex -i tianyahttp_access deny tianyadeny_info tianya#阻止baidu蜘蛛acl baidu req_header User-Agent Baiduspiderhttp_access deny baidu#限制同一IP客户端的最大连接数acl OverConnLimit maxconn 128http_access deny OverConnLimit#防止被人利用为HTTP代理，设置允许访问的IP地址acl myip dst 222.18.63.37http_access deny !myip#允许本地管理acl Manager proto cache_objectacl Localhost src 127.0.0.1 222.18.63.37http_access allow Manager Localhostcachemgr_passwd 53034338 allhttp_access deny Manager#仅仅允许80端口的代理acl all src 0.0.0.0/0.0.0.0acl Safe_ports port 80 # httphttp_access deny !Safe_portshttp_access allow all#Squid信息设置visible_hostname happy.swjtu.edu.cncache_mgr ooopic2008@qq.com#基本设置cache_effective_user squidcache_effective_group squidtcp_recv_bufsize 65535 bytes#2.6的反向代理加速配置cache_peer 127.0.0.1 parent 80 0 no-query originserver#错误文档error_directory /usr/local/squid/share/errors/Simplify_Chinese#单台使用，不使用该功能icp_port 0hierarchy_stoplist cgi-bin ?acl QUERY urlpath_regex cgi-bin \\? .php .cgi .avi .wmv .rm .ram .mpg .mpeg .zip .execache deny QUERYacl apache rep_header Server ^Apachebroken_vary_encoding allow apacherefresh_pattern ^ftp: 1440 20% 10080refresh_pattern ^gopher: 1440 0% 1440refresh_pattern . 0 20% 4320cache_store_log nonepid_filename /usr/local/squid/var/logs/squid.pidemulate_httpd_log onSquid常用命令初始化在squid.conf里配置的cache目录squid -z如果有错误提示，请检查cache目录的权限，可以更改目录权限chown -R squid:squid /cache目录对squid.conf排错，即验证squid.conf的语法和配置squid -k parse如果在squid.conf中有语法或配置错误，这里会返回提示，若无返回，尝试启动squid前台启动squid，并输出启动过程/usr/local/squid/sbin/squid -N -d1如果有ready to server reques相关信息，说明squid启动成功然后ctrl+c ,停止squid,并以后台运行的方式启动它启动squid在后台运行squid -s可以使用ps -ax | grep squid 来查看squid进程是否存在停止squidsquid -k shutdown重新引导修改过的squid.confsquid -k reconfigure -f /XXX/squid.conf当squid进行配置更改后，可以使用该命令进行squid配置重载把squid添加到系统启动项vim /etc/rc.local/usr/local/squid/sbin/squid -s修改cache缓存目录的权限chown -R squid.squid /cache目录cache缓存目录根据自己的配置更改，squid用户和组是squid，squid修改squid日志目录的权限chown -R squid.squid 定义的日志文件所在目录这一步并不是适合每一个使用squid的用户，意为让squid有权限在该目录里进行写操作查看你的日志文档more /usr/local/squid/var/logs/access.log | grep TCP_MEM_HIT该指令可以看到在squid运行过程中，有那些文件被squid缓存到内存中，并返回给访问用户。more /usr/local/squid/var/logs/access.log | grep TCP_HIT该指令可以看到在squid运行过程中，有那些文件被squid缓存到cache目录中，并返回给访问用户。more /usr/local/squid/var/logs/access.log | grep TCP_MISS该指令可以看到在squid运行过程中，有那些文件没有被squid缓存，而是从原始服务器获取并返回给访问用户。Squid命中率分析12/usr/local/squid/bin/squidclient -p 80 mgr:info/usr/local/squid/bin/squidclient -p 80 mgr:5min可以看到详细的性能情况,其中PORT是你的proxy的端口，5min可以是60min取得squid运行状态信息：1squidclient -p 80 mgr:info取得squid内存使用情况：1squidclient -p 80 mgr:mem取得squid已经缓存的列表：1squidclient -p 80 mgr:bjects. use it carefully,it may crash取得squid的磁盘使用情况：1squidclient -p 80 mgr:diskd强制更新某个url：1squidclient -p 80 -m PURGE http://www.xxx.com/xxx.php更多的请查看：squidclient-h 或者 squidclient -p 80 mgr:查命中率：1squidclient -h IP(具体侦听IP) -p 80(具体侦听端口) mgr:info定期清理swap.state内无效数据123/path/to/squid/sbin/squid -k rotate -f /path/to/squid/conf_filevi /etc/crontab0 0 * * * root /usr/local/sbin/squid -k rotate -f /usr/local/etc/squid/squid1.conf当squid应用运行了一段时间之后，cache_dir对应的swap.state文件就会变得越来越大，里面的无效接口数据越来越多，这可能影响squid的响应时间，因此需要使用squid清理swap.state里面的无效数据，减少swap.state的大小。","raw":"---\ntitle: squid介绍及其简单配置\ncopyright: true\ntags:\n  - squid\n  - proxy\ncategories:\n  - Linux\nabbrlink: 55e3d16d\ndate: 2019-05-15 15:15:30\ntype:\nkeyword:\ntop:\ncomments:\npassword:\n---\n\n# squid的概念\n\nsquid是一种用来缓存Internet数据的软件。接受来自人们需要下载的目标（object）的请求并适当的处理这些请求。也就是说，如果一个人想下载一web界面，他请求squid为他取得这个页面。squid随之连接到远程服务器并向这个页面发出请求。然后，squid显式地聚集数据到客户端机器，而且同时复制一份。当下一次有人需要同一页面时， squid可以简单的从磁盘中读到它，那样数据会立即传输到客户机上。\n\n<!-- more -->\n\n# 下载地址\n\nsquid-cache 官网 http://www.squid-cache.org\n\nsquid介绍及其简单配置 https://www.cnblogs.com/cherishry/p/5706736.html\n\nCentOS 7安装squid代理服务器 https://blog.csdn.net/ithomer/article/details/78136993\n\n## squid代理的作用\n\n*   通过缓存的方式为用户提供Web访问加速\n*   对用户的Web访问进行过滤控制\n\n## 工作流程\n\n当代理服务器中有客户端需要的数据时：\n\na.客户端向代理服务器发送数据请求；\n\nb.代理服务器检查自己的数据缓存；\n\nc.代理服务器在缓存中找到了用户想要的数据，取出数据；\n\nd.代理服务器将从缓存中取得的数据返回给客户端。\n\n当代理服务器中没有客户端需要的数据时了：\n\n1.客户端向代理服务器发送数据请求；\n\n2.代理服务器检查自己的数据缓存；\n\n3.代理服务器在缓存中没有找到用户想要的数据；\n\n4.代理服务器向Internet 上的远端服务器发送数据请求；\n\n5.远端服务器响应，返回相应的数据；\n\n6.代理服务器取得远端服务器的数据，返回给客户端，并保留一份到自己的数据缓存中。\n\n![](https://images2015.cnblogs.com/blog/872781/201607/872781-20160726112850919-758636566.jpg)\n\nSquid代理服务器工作在TCP/IP应用层\n\n![](https://images2015.cnblogs.com/blog/872781/201607/872781-20160726112935653-887103660.jpg)\n\n## Squid各种代理的定义\n\n### 正向代理\n\n#### 标准的代理缓冲服务器\n\n一个标准的代理缓冲服务被用于缓存静态的网页到本地网络上的一台主机上（即代理服务器）。当被缓存的页面被第二次访问的时候，浏览器将直接从本地代理服务器那里获取请求数据而不再向原web站点请求数据。这样就节省了宝贵的网络带宽，而且提高了访问速度。但是，要想实现这种方式，必须在每一个内部主机的浏览器上明确指名代理服务器的IP地址和端口号。客户端上网时，每次都把请求发送给代理服务器处理,代理服务器根据请求确定是否连接到远程web服务器获取数据。如果在本地缓冲区有目标文件，则直接将文件传给用户即可。如果没有的话则先取回文件，先在本地保存一份缓冲，然后将文件发送给客户端浏览器。\n\n#### 透明代理缓冲服务器\n\n透明代理缓冲服务器和标准代理服务器的功能完全相同。但是，代理操作对客户端的浏览器是透明的（即不需指明代理服务器的IP和端口）。透明代理服务器阻断网络通信，并且过滤出访问外部的HTTP（80端口）流量。如果客户端的请求在本地有缓冲则将缓冲的数据直接发给用户，如果在本地没有缓冲则向远程web服务器发出请求，其余操作和标准的代理服务器完全相同。对于linux操作系统来说，透明代理使用Iptables或者Ipchains实现。因此不需要对浏览器作任何设置，所以，透明代理对于ISP（Internet服务器提供商）特别有用。\n\n### 反向代理\n\n#### 反向代理缓冲器\n\n反向代理是和前两种代理完全不同的一种代理服务。使用它可以降低原始WEB服务器的负载。反向代理服务器承担了对原始WEB服务器的静态页面的请求，防止原始服务器过载。它位于WEB服务器和Internet之间，处理所有对WEB服务器的请求，组织了WEB服务器和Internet的直接通信。如果互联网用户请求的页面在代理服务器上有缓冲的话，代理服务器直接将缓冲内容发送给用户。如果没有缓冲则先向WEB服务器发出请求，取回数据，本地缓存后再发给用户。这种方式通过降低了WEB服务器的请求数从而降低了WEB服务器的负载。\n\n### 正向代理与反向代理的区别\n\n### 概念\n\n正向代理：对于原始服务器而言，就是客户端的代言人\n反向代理：对于客户端而言，就像是原始服务器\n\n### 用途\n\n正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。\n反向代理还可以为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。另外，反向代理还可以启用高级URL策略和管理技术，从而使处于不同web服务器系统的web页面同时存在于同一个URL空间下。\n\n### 安全性\n\n正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。\n反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。\n\n## Squid主要组成部分\n\n服务名：`squid`\n主程序：`/usr/sbin/squid`\n配置目录：`/etc/squid`\n主配置文件：`/etc/squid/squid.conf`\n监听tcp端口号：`3128`\n默认访问日志文件：`/var/log/squid/access.log`\n\n## squid常用配置选项\n\n`/etc/squid/squid.conf`\n\n```\n\nhttp_port 3128  (还可以只监听一个IP http_port 192.168.0.1:3128)\ncache_mem 64MB  #缓存占内存大小\nmaximum_object_size 4096KB  #最大缓存块\nreply_body_max_size  1024000 allow all      #限定下载文件大小\naccess_log /var/log/squid/access.log    #访问日志存放的地方\nvisible_hostname    proxy.test.xom  #可见的主机名\ncache_dir ufs /var/spool/squid  100 16 256 \n#ufs:缓存数据的存储格式\n#/var/spool/squid    缓存目录\n#100：缓存目录占磁盘空间大小（M）\n#16：缓存空间一级子目录个数\n#256：缓存空间二级子目录个数\ncache_mgr webmaster@test.com    #定义管理员邮箱\nhttp_access deny all    #访问控制\n\n```\n## squid中的访问控制\n\n  使用访问控制特性，可以控制在访问时根据特定的时间间隔进行缓存、访问特定站点或一组站点等等。squid访问控制有两个要素：ACL元素和访问列表。访问列表可以允许或拒绝某些用户对此服务的访问。\n\n### ACL元素类型\n\n*   src：源地址（即客户机IP地址）\n*   dst：目标地址（即服务器IP地址）\n*   srcdomain：源名称（即客户机名称）\n*   dstdomain：目标名称（即服务器名称）\n*   time：一天中的时刻和一周内的一天\n*   url_regex：URL规则表达式匹配\n*   urlpath_regex：URL-path规则表达式匹配，略去协议和主机名\n*   proxy_auth：通过外部程序进行用户验证\n*   maxconn：单一IP的最大连接数\n\n### ACL格式\n\n\t为了使用控制功能，必须先设置ACL规则并应用。ACL声明的格式如下：\n\n注：\n\n*   acl_element_name 可以是任一个在ACL中定义的名称\n*   任何两个ACL元素不能用相同的名字\n*   每个ACL由列表值组成。当进行匹配检测的时候，多个值由逻辑或运算连接；换言之，即任一ACL元素的值被匹配，则这个ACL元素即被匹配。\n*   并不是所有ACL元素都能使用访问列表中的全部类型\n*   不同的ACL元素写在不同行中，squid将把他们组合在一个列表中\n\n### 访问条目\n\n我们可以使用许多不同的访问条目。下面是我们常用的几个：\n\n*   http_access:允许HTTP访问\n*   no_cache:定义对缓存请求的响应。\n    访问列表的规则由一些类似'allow'或‘deny’的关键字构成，用以允许或拒绝向特定或一组ACL元素提供服务。\n\n1.  一个访问列表可以由多条规则组成\n2.  如果没有任何规则与访问请求匹配，默认动作将与列表中最后一条规则对应。\n3.  一个访问条目中所有元素将用逻辑与运算连接\n    http_access Action 声明1 AND 声明2 AND 声明 OR.\n    http_access Action 声明3\n    多个http_accesss声明间用或运算连接，但每个访问条目的元素间用与运算连接。\n4.  列表中的规则总是遵循由上而下的顺序\n5.  这些规则按照他们的排列顺序进行匹配检测，一旦检测到匹配的规则，匹配就立即结束。\n\n## Squid.conf配置文件详解\n\n```\n#acl all src 0.0.0.0/0.0.0.0 and http_access allow all选项定义了一个访问控制列表。详细情况参见和Squid软件\n#携带的文档。这里的访问控制列表允许所有对代理服务的访问，因为这里该代理是加速web服务器。\nacl all src 0.0.0.0/0.0.0.0                 #允许所有IP访问\nacl manager proto http                 #manager url协议为http\nacl localhost src 127.0.0.1/255.255.255.255  #允午本机IP\nacl to_localhost dst 127.0.0.1                 #允午目的地址为本机IP\nacl Safe_ports port 80                # 允许安全更新的端口为80\nacl CONNECT method CONNECT        #请求方法以CONNECT\nhttp_access allow all                #允许所有人使用该代理.因为这里是代理加速web服务器\nhttp_reply_access allow all                #允许所有客户端使用该代理\n\nacl OverConnLimit maxconn 16        #限制每个IP最大允许16个连接，防止攻击\nhttp_access deny OverConnLimit\n\nicp_access deny all                        #禁止从邻居服务器缓冲内发送和接收ICP请求.\nmiss_access allow all                #允许直接更新请求\nident_lookup_access deny all                                #禁止lookup检查DNS\nhttp_port 8080 transparent                                #指定Squid监听浏览器客户请求的端口号。\n\nhierarchy_stoplist cgi-bin ?                #用来强制某些特定的对象不被缓存，主要是处于安全的目的。\nacl QUERY urlpath_regex cgi-bin \\?\ncache deny QUERY\n\ncache_mem 1 GB        #这是一个优化选项，增加该内存值有利于缓存。应该注意的是：\n                     #一般来说如果系统有内存，设置该值为(n/)3M。现在是3G 所以这里1G\nfqdncache_size 1024        #FQDN 高速缓存大小\nmaximum_object_size_in_memory 2 MB        #允许最大的文件载入内存\n\nmemory_replacement_policy heap LFUDA  #动态使用最小的，移出内存cache\ncache_replacement_policy heap LFUDA         #动态使用最小的，移出硬盘cache\n\ncache_dir ufs /home/cache 5000 32 512  #高速缓存目录 ufs 类型 使用的缓冲值最大允午1000MB空间，\n#32个一级目录，512个二级目录\n\nmax_open_disk_fds 0                                 #允许最大打开文件数量,0 无限制\nminimum_object_size 1 KB                         #允午最小文件请求体大小\nmaximum_object_size 20 MB                 #允午最大文件请求体大小\n\ncache_swap_low 90                            #最小允许使用swap 90%\ncache_swap_high 95                            #最多允许使用swap 95%\n\nipcache_size 2048                                # IP 地址高速缓存大小 2M\nipcache_low 90                                #最小允许ipcache使用swap 90%\nipcache_high 95                                  #最大允许ipcache使用swap 90%\n\n\naccess_log /var/log/squid/access.log squid        #定义日志存放记录\ncache_log /var/log/squid/cache.log squid\ncache_store_log none                        #禁止store日志\n\nemulate_httpd_log on        #将使Squid仿照Web服务器的格式创建访问记录。如果希望使用\n                                #Web访问记录分析程序，就需要设置这个参数。\n\nrefresh_pattern . 0 20% 4320 override-expire override-lastmod reload-into-ims ignore-reload   #更新cache规则\n\nacl buggy_server url_regex ^http://.... http://          #只允许http的请求\nbroken_posts allow buggy_server\n\nacl apache rep_header Server ^Apache                 #允许apache的编码\nbroken_vary_encoding allow apache\n\nrequest_entities off                                        #禁止非http的标分准请求，防止攻击\nheader_access header allow all                        #允许所有的http报头\nrelaxed_header_parser on                                #不严格分析http报头.\nclient_lifetime 120 minute                                #最大客户连接时间 120分钟\n\ncache_mgr sky@test.com                        #指定当缓冲出现问题时向缓冲管理者发送告警信息的地址信息。\n\ncache_effective_user squid                        #这里以用户squid的身份Squid服务器\ncache_effective_group squid\n\nicp_port 0                       #指定Squid从邻居服务器缓冲内发送和接收ICP请求的端口号。\n                     #这里设置为0是因为这里配置Squid为内部Web服务器的加速器，\n                     #所以不需要使用邻居服务器的缓冲。0是禁用\n\n# cache_peer 设置允许更新缓存的主机，因是本机所以127.0.0.1\ncache_peer 127.0.0.1 parent 80 0 no-query default multicast-responder no-netdb-exchange\ncache_peer_domain 127.0.0.1                                 \nhostname_aliases 127.0.0.1\n\nerror_directory /usr/share/squid/errors/Simplify_Chinese        #定义错误路径\n\nalways_direct allow all                # cache丢失或不存在是允许所有请求直接转发到原始服务器\nignore_unknown_nameservers on        #开反DNS查询，当域名地址不相同时候，禁止访问\ncoredump_dir  /var/log/squid                 #定义dump的目录\n\nmax_filedesc 2048                #最大打开的文件描述\n\nhalf_closed_clients off        #使Squid在当read不再返回数据时立即关闭客户端的连接。\n                                #有时read不再返回数据是由于某些客户关闭TCP的发送数据\n                                #而仍然保持接收数据。而Squid分辨不出TCP半关闭和完全关闭。\n\nbuffered_logs on #若打开选项“buffered_logs”可以稍稍提高加速某些对日志文件的写入，该选项主要是实现优化特性。\n\n#防止天涯盗链，转嫁给百度\nacl tianya referer_regex -i tianya\nhttp_access deny tianya\ndeny_info  tianya\n#阻止baidu蜘蛛\nacl baidu req_header User-Agent Baiduspider\nhttp_access deny baidu\n#限制同一IP客户端的最大连接数\nacl OverConnLimit maxconn 128\nhttp_access deny OverConnLimit\n\n#防止被人利用为HTTP代理，设置允许访问的IP地址\nacl myip dst 222.18.63.37\nhttp_access deny !myip\n\n#允许本地管理\nacl Manager proto cache_object\nacl Localhost src 127.0.0.1 222.18.63.37\nhttp_access allow Manager Localhost\ncachemgr_passwd 53034338 all\nhttp_access deny Manager\n\n#仅仅允许80端口的代理\nacl all src 0.0.0.0/0.0.0.0\nacl Safe_ports port 80 # http\nhttp_access deny !Safe_ports\nhttp_access allow all\n\n#Squid信息设置\nvisible_hostname happy.swjtu.edu.cn\ncache_mgr  ooopic2008@qq.com\n\n#基本设置\ncache_effective_user squid\ncache_effective_group squid\ntcp_recv_bufsize 65535 bytes\n\n#2.6的反向代理加速配置\ncache_peer 127.0.0.1 parent 80 0 no-query originserver\n\n#错误文档\nerror_directory /usr/local/squid/share/errors/Simplify_Chinese\n\n#单台使用，不使用该功能\nicp_port 0\n\nhierarchy_stoplist cgi-bin ?\n\nacl QUERY urlpath_regex cgi-bin \\? .php .cgi .avi .wmv .rm .ram .mpg .mpeg .zip .exe\ncache deny QUERY\n\nacl apache rep_header Server ^Apache\nbroken_vary_encoding allow apache\n\n\nrefresh_pattern ^ftp:           1440 20%     10080\nrefresh_pattern ^gopher:        1440 0%    1440\nrefresh_pattern .             0    20%     4320\n\ncache_store_log none\npid_filename /usr/local/squid/var/logs/squid.pid\nemulate_httpd_log on\n```\n\n## Squid常用命令\n\n1.  初始化在squid.conf里配置的cache目录\n    squid -z\n    如果有错误提示，请检查cache目录的权限，可以更改目录权限\n    chown -R squid:squid /cache目录\n2.  对squid.conf排错，即验证squid.conf的语法和配置\n    squid -k parse\n    如果在squid.conf中有语法或配置错误，这里会返回提示，若无返回，尝试启动squid\n3.  前台启动squid，并输出启动过程\n    /usr/local/squid/sbin/squid -N -d1\n    如果有ready to server reques相关信息，说明squid启动成功\n    然后ctrl+c ,停止squid,并以后台运行的方式启动它\n4.  启动squid在后台运行\n    squid -s\n    可以使用ps -ax | grep squid 来查看squid进程是否存在\n5.  停止squid\n    squid -k shutdown\n6.  重新引导修改过的squid.conf\n    squid -k reconfigure -f /XXX/squid.conf\n    当squid进行配置更改后，可以使用该命令进行squid配置重载\n7.  把squid添加到系统启动项\n    vim /etc/rc.local\n    /usr/local/squid/sbin/squid -s\n8.  修改cache缓存目录的权限\n    chown -R squid.squid /cache目录\n    cache缓存目录根据自己的配置更改，squid用户和组是squid，squid\n9.  修改squid日志目录的权限\n    chown -R squid.squid 定义的日志文件所在目录\n    这一步并不是适合每一个使用squid的用户，意为让squid有权限在该目录里进行写操作\n10.  查看你的日志文档\n    more /usr/local/squid/var/logs/access.log | grep TCP_MEM_HIT\n    该指令可以看到在squid运行过程中，有那些文件被squid缓存到内存中，并返回给访问用户。\n    more /usr/local/squid/var/logs/access.log | grep TCP_HIT\n    该指令可以看到在squid运行过程中，有那些文件被squid缓存到cache目录中，并返回给访问用户。\n    more /usr/local/squid/var/logs/access.log | grep TCP_MISS\n    该指令可以看到在squid运行过程中，有那些文件没有被squid缓存，而是从原始服务器获取并返回给访问用户。\n\n## Squid命中率分析\n\n```\n/usr/local/squid/bin/squidclient -p 80 mgr:info\n/usr/local/squid/bin/squidclient -p 80 mgr:5min\n```\n可以看到详细的性能情况,其中PORT是你的proxy的端口，5min可以是60min\n取得squid运行状态信息：\n\n```\n squidclient -p 80 mgr:info\n```\n\n取得squid内存使用情况：\n\n```\nsquidclient -p 80 mgr:mem\n```\n\n取得squid已经缓存的列表：\n\n```\nsquidclient -p 80 mgr:bjects. use it carefully,it may crash\n```\n\n取得squid的磁盘使用情况：\n\n```\nsquidclient -p 80 mgr:diskd\n```\n\n强制更新某个url：\n\n```\nsquidclient -p 80 -m PURGE http://www.xxx.com/xxx.php\n```\n\n更多的请查看：squidclient-h 或者 squidclient -p 80 mgr:\n查命中率：\n\n```\nsquidclient -h IP(具体侦听IP) -p 80(具体侦听端口) mgr:info\n```\n\n## 定期清理swap.state内无效数据\n\n```\n/path/to/squid/sbin/squid -k rotate -f /path/to/squid/conf_file\nvi /etc/crontab\n0        0       *       *       *       root    /usr/local/sbin/squid -k rotate -f /usr/local/etc/squid/squid1.conf\n```\n\n当squid应用运行了一段时间之后，cache_dir对应的swap.state文件就会变得越来越大，里面的无效接口数据越来越多，这可能影响squid的响应时间，因此需要使用squid清理swap.state里面的无效数据，减少swap.state的大小。\n","content":"<h1 id=\"squid的概念\"><a href=\"#squid的概念\" class=\"headerlink\" title=\"squid的概念\"></a>squid的概念</h1><p>squid是一种用来缓存Internet数据的软件。接受来自人们需要下载的目标（object）的请求并适当的处理这些请求。也就是说，如果一个人想下载一web界面，他请求squid为他取得这个页面。squid随之连接到远程服务器并向这个页面发出请求。然后，squid显式地聚集数据到客户端机器，而且同时复制一份。当下一次有人需要同一页面时， squid可以简单的从磁盘中读到它，那样数据会立即传输到客户机上。</p><a id=\"more\"></a><h1 id=\"下载地址\"><a href=\"#下载地址\" class=\"headerlink\" title=\"下载地址\"></a>下载地址</h1><p>squid-cache 官网 <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zcXVpZC1jYWNoZS5vcmc=\" title=\"http://www.squid-cache.org\">http://www.squid-cache.org<i class=\"fa fa-external-link\"></i></span></p><p>squid介绍及其简单配置 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY2hlcmlzaHJ5L3AvNTcwNjczNi5odG1s\" title=\"https://www.cnblogs.com/cherishry/p/5706736.html\">https://www.cnblogs.com/cherishry/p/5706736.html<i class=\"fa fa-external-link\"></i></span></p><p>CentOS 7安装squid代理服务器 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0aG9tZXIvYXJ0aWNsZS9kZXRhaWxzLzc4MTM2OTkz\" title=\"https://blog.csdn.net/ithomer/article/details/78136993\">https://blog.csdn.net/ithomer/article/details/78136993<i class=\"fa fa-external-link\"></i></span></p><h2 id=\"squid代理的作用\"><a href=\"#squid代理的作用\" class=\"headerlink\" title=\"squid代理的作用\"></a>squid代理的作用</h2><ul><li>通过缓存的方式为用户提供Web访问加速</li><li>对用户的Web访问进行过滤控制</li></ul><h2 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h2><p>当代理服务器中有客户端需要的数据时：</p><p>a.客户端向代理服务器发送数据请求；</p><p>b.代理服务器检查自己的数据缓存；</p><p>c.代理服务器在缓存中找到了用户想要的数据，取出数据；</p><p>d.代理服务器将从缓存中取得的数据返回给客户端。</p><p>当代理服务器中没有客户端需要的数据时了：</p><p>1.客户端向代理服务器发送数据请求；</p><p>2.代理服务器检查自己的数据缓存；</p><p>3.代理服务器在缓存中没有找到用户想要的数据；</p><p>4.代理服务器向Internet 上的远端服务器发送数据请求；</p><p>5.远端服务器响应，返回相应的数据；</p><p>6.代理服务器取得远端服务器的数据，返回给客户端，并保留一份到自己的数据缓存中。</p><p><img src=\"https://images2015.cnblogs.com/blog/872781/201607/872781-20160726112850919-758636566.jpg\" alt=\"\"></p><p>Squid代理服务器工作在TCP/IP应用层</p><p><img src=\"https://images2015.cnblogs.com/blog/872781/201607/872781-20160726112935653-887103660.jpg\" alt=\"\"></p><h2 id=\"Squid各种代理的定义\"><a href=\"#Squid各种代理的定义\" class=\"headerlink\" title=\"Squid各种代理的定义\"></a>Squid各种代理的定义</h2><h3 id=\"正向代理\"><a href=\"#正向代理\" class=\"headerlink\" title=\"正向代理\"></a>正向代理</h3><h4 id=\"标准的代理缓冲服务器\"><a href=\"#标准的代理缓冲服务器\" class=\"headerlink\" title=\"标准的代理缓冲服务器\"></a>标准的代理缓冲服务器</h4><p>一个标准的代理缓冲服务被用于缓存静态的网页到本地网络上的一台主机上（即代理服务器）。当被缓存的页面被第二次访问的时候，浏览器将直接从本地代理服务器那里获取请求数据而不再向原web站点请求数据。这样就节省了宝贵的网络带宽，而且提高了访问速度。但是，要想实现这种方式，必须在每一个内部主机的浏览器上明确指名代理服务器的IP地址和端口号。客户端上网时，每次都把请求发送给代理服务器处理,代理服务器根据请求确定是否连接到远程web服务器获取数据。如果在本地缓冲区有目标文件，则直接将文件传给用户即可。如果没有的话则先取回文件，先在本地保存一份缓冲，然后将文件发送给客户端浏览器。</p><h4 id=\"透明代理缓冲服务器\"><a href=\"#透明代理缓冲服务器\" class=\"headerlink\" title=\"透明代理缓冲服务器\"></a>透明代理缓冲服务器</h4><p>透明代理缓冲服务器和标准代理服务器的功能完全相同。但是，代理操作对客户端的浏览器是透明的（即不需指明代理服务器的IP和端口）。透明代理服务器阻断网络通信，并且过滤出访问外部的HTTP（80端口）流量。如果客户端的请求在本地有缓冲则将缓冲的数据直接发给用户，如果在本地没有缓冲则向远程web服务器发出请求，其余操作和标准的代理服务器完全相同。对于linux操作系统来说，透明代理使用Iptables或者Ipchains实现。因此不需要对浏览器作任何设置，所以，透明代理对于ISP（Internet服务器提供商）特别有用。</p><h3 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h3><h4 id=\"反向代理缓冲器\"><a href=\"#反向代理缓冲器\" class=\"headerlink\" title=\"反向代理缓冲器\"></a>反向代理缓冲器</h4><p>反向代理是和前两种代理完全不同的一种代理服务。使用它可以降低原始WEB服务器的负载。反向代理服务器承担了对原始WEB服务器的静态页面的请求，防止原始服务器过载。它位于WEB服务器和Internet之间，处理所有对WEB服务器的请求，组织了WEB服务器和Internet的直接通信。如果互联网用户请求的页面在代理服务器上有缓冲的话，代理服务器直接将缓冲内容发送给用户。如果没有缓冲则先向WEB服务器发出请求，取回数据，本地缓存后再发给用户。这种方式通过降低了WEB服务器的请求数从而降低了WEB服务器的负载。</p><h3 id=\"正向代理与反向代理的区别\"><a href=\"#正向代理与反向代理的区别\" class=\"headerlink\" title=\"正向代理与反向代理的区别\"></a>正向代理与反向代理的区别</h3><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>正向代理：对于原始服务器而言，就是客户端的代言人<br>反向代理：对于客户端而言，就像是原始服务器</p><h3 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h3><p>正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。<br>反向代理还可以为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。另外，反向代理还可以启用高级URL策略和管理技术，从而使处于不同web服务器系统的web页面同时存在于同一个URL空间下。</p><h3 id=\"安全性\"><a href=\"#安全性\" class=\"headerlink\" title=\"安全性\"></a>安全性</h3><p>正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。<br>反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。</p><h2 id=\"Squid主要组成部分\"><a href=\"#Squid主要组成部分\" class=\"headerlink\" title=\"Squid主要组成部分\"></a>Squid主要组成部分</h2><p>服务名：<code>squid</code><br>主程序：<code>/usr/sbin/squid</code><br>配置目录：<code>/etc/squid</code><br>主配置文件：<code>/etc/squid/squid.conf</code><br>监听tcp端口号：<code>3128</code><br>默认访问日志文件：<code>/var/log/squid/access.log</code></p><h2 id=\"squid常用配置选项\"><a href=\"#squid常用配置选项\" class=\"headerlink\" title=\"squid常用配置选项\"></a>squid常用配置选项</h2><p><code>/etc/squid/squid.conf</code></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">http_port 3128  (还可以只监听一个IP http_port 192.168.0.1:3128)</span><br><span class=\"line\">cache_mem 64MB  #缓存占内存大小</span><br><span class=\"line\">maximum_object_size 4096KB  #最大缓存块</span><br><span class=\"line\">reply_body_max_size  1024000 allow all      #限定下载文件大小</span><br><span class=\"line\">access_log /var/log/squid/access.log    #访问日志存放的地方</span><br><span class=\"line\">visible_hostname    proxy.test.xom  #可见的主机名</span><br><span class=\"line\">cache_dir ufs /var/spool/squid  100 16 256 </span><br><span class=\"line\">#ufs:缓存数据的存储格式</span><br><span class=\"line\">#/var/spool/squid    缓存目录</span><br><span class=\"line\">#100：缓存目录占磁盘空间大小（M）</span><br><span class=\"line\">#16：缓存空间一级子目录个数</span><br><span class=\"line\">#256：缓存空间二级子目录个数</span><br><span class=\"line\">cache_mgr webmaster@test.com    #定义管理员邮箱</span><br><span class=\"line\">http_access deny all    #访问控制</span><br></pre></td></tr></table></figure><h2 id=\"squid中的访问控制\"><a href=\"#squid中的访问控制\" class=\"headerlink\" title=\"squid中的访问控制\"></a>squid中的访问控制</h2><p>使用访问控制特性，可以控制在访问时根据特定的时间间隔进行缓存、访问特定站点或一组站点等等。squid访问控制有两个要素：ACL元素和访问列表。访问列表可以允许或拒绝某些用户对此服务的访问。</p><h3 id=\"ACL元素类型\"><a href=\"#ACL元素类型\" class=\"headerlink\" title=\"ACL元素类型\"></a>ACL元素类型</h3><ul><li>src：源地址（即客户机IP地址）</li><li>dst：目标地址（即服务器IP地址）</li><li>srcdomain：源名称（即客户机名称）</li><li>dstdomain：目标名称（即服务器名称）</li><li>time：一天中的时刻和一周内的一天</li><li>url_regex：URL规则表达式匹配</li><li>urlpath_regex：URL-path规则表达式匹配，略去协议和主机名</li><li>proxy_auth：通过外部程序进行用户验证</li><li>maxconn：单一IP的最大连接数</li></ul><h3 id=\"ACL格式\"><a href=\"#ACL格式\" class=\"headerlink\" title=\"ACL格式\"></a>ACL格式</h3><pre><code>为了使用控制功能，必须先设置ACL规则并应用。ACL声明的格式如下：\n</code></pre><p>注：</p><ul><li>acl_element_name 可以是任一个在ACL中定义的名称</li><li>任何两个ACL元素不能用相同的名字</li><li>每个ACL由列表值组成。当进行匹配检测的时候，多个值由逻辑或运算连接；换言之，即任一ACL元素的值被匹配，则这个ACL元素即被匹配。</li><li>并不是所有ACL元素都能使用访问列表中的全部类型</li><li>不同的ACL元素写在不同行中，squid将把他们组合在一个列表中</li></ul><h3 id=\"访问条目\"><a href=\"#访问条目\" class=\"headerlink\" title=\"访问条目\"></a>访问条目</h3><p>我们可以使用许多不同的访问条目。下面是我们常用的几个：</p><ul><li>http_access:允许HTTP访问</li><li>no_cache:定义对缓存请求的响应。<br>访问列表的规则由一些类似’allow’或‘deny’的关键字构成，用以允许或拒绝向特定或一组ACL元素提供服务。</li></ul><ol><li>一个访问列表可以由多条规则组成</li><li>如果没有任何规则与访问请求匹配，默认动作将与列表中最后一条规则对应。</li><li>一个访问条目中所有元素将用逻辑与运算连接<br>http_access Action 声明1 AND 声明2 AND 声明 OR.<br>http_access Action 声明3<br>多个http_accesss声明间用或运算连接，但每个访问条目的元素间用与运算连接。</li><li>列表中的规则总是遵循由上而下的顺序</li><li>这些规则按照他们的排列顺序进行匹配检测，一旦检测到匹配的规则，匹配就立即结束。</li></ol><h2 id=\"Squid-conf配置文件详解\"><a href=\"#Squid-conf配置文件详解\" class=\"headerlink\" title=\"Squid.conf配置文件详解\"></a>Squid.conf配置文件详解</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#acl all src 0.0.0.0/0.0.0.0 and http_access allow all选项定义了一个访问控制列表。详细情况参见和Squid软件</span><br><span class=\"line\">#携带的文档。这里的访问控制列表允许所有对代理服务的访问，因为这里该代理是加速web服务器。</span><br><span class=\"line\">acl all src 0.0.0.0/0.0.0.0                 #允许所有IP访问</span><br><span class=\"line\">acl manager proto http                 #manager url协议为http</span><br><span class=\"line\">acl localhost src 127.0.0.1/255.255.255.255  #允午本机IP</span><br><span class=\"line\">acl to_localhost dst 127.0.0.1                 #允午目的地址为本机IP</span><br><span class=\"line\">acl Safe_ports port 80                # 允许安全更新的端口为80</span><br><span class=\"line\">acl CONNECT method CONNECT        #请求方法以CONNECT</span><br><span class=\"line\">http_access allow all                #允许所有人使用该代理.因为这里是代理加速web服务器</span><br><span class=\"line\">http_reply_access allow all                #允许所有客户端使用该代理</span><br><span class=\"line\"></span><br><span class=\"line\">acl OverConnLimit maxconn 16        #限制每个IP最大允许16个连接，防止攻击</span><br><span class=\"line\">http_access deny OverConnLimit</span><br><span class=\"line\"></span><br><span class=\"line\">icp_access deny all                        #禁止从邻居服务器缓冲内发送和接收ICP请求.</span><br><span class=\"line\">miss_access allow all                #允许直接更新请求</span><br><span class=\"line\">ident_lookup_access deny all                                #禁止lookup检查DNS</span><br><span class=\"line\">http_port 8080 transparent                                #指定Squid监听浏览器客户请求的端口号。</span><br><span class=\"line\"></span><br><span class=\"line\">hierarchy_stoplist cgi-bin ?                #用来强制某些特定的对象不被缓存，主要是处于安全的目的。</span><br><span class=\"line\">acl QUERY urlpath_regex cgi-bin \\?</span><br><span class=\"line\">cache deny QUERY</span><br><span class=\"line\"></span><br><span class=\"line\">cache_mem 1 GB        #这是一个优化选项，增加该内存值有利于缓存。应该注意的是：</span><br><span class=\"line\">                     #一般来说如果系统有内存，设置该值为(n/)3M。现在是3G 所以这里1G</span><br><span class=\"line\">fqdncache_size 1024        #FQDN 高速缓存大小</span><br><span class=\"line\">maximum_object_size_in_memory 2 MB        #允许最大的文件载入内存</span><br><span class=\"line\"></span><br><span class=\"line\">memory_replacement_policy heap LFUDA  #动态使用最小的，移出内存cache</span><br><span class=\"line\">cache_replacement_policy heap LFUDA         #动态使用最小的，移出硬盘cache</span><br><span class=\"line\"></span><br><span class=\"line\">cache_dir ufs /home/cache 5000 32 512  #高速缓存目录 ufs 类型 使用的缓冲值最大允午1000MB空间，</span><br><span class=\"line\">#32个一级目录，512个二级目录</span><br><span class=\"line\"></span><br><span class=\"line\">max_open_disk_fds 0                                 #允许最大打开文件数量,0 无限制</span><br><span class=\"line\">minimum_object_size 1 KB                         #允午最小文件请求体大小</span><br><span class=\"line\">maximum_object_size 20 MB                 #允午最大文件请求体大小</span><br><span class=\"line\"></span><br><span class=\"line\">cache_swap_low 90                            #最小允许使用swap 90%</span><br><span class=\"line\">cache_swap_high 95                            #最多允许使用swap 95%</span><br><span class=\"line\"></span><br><span class=\"line\">ipcache_size 2048                                # IP 地址高速缓存大小 2M</span><br><span class=\"line\">ipcache_low 90                                #最小允许ipcache使用swap 90%</span><br><span class=\"line\">ipcache_high 95                                  #最大允许ipcache使用swap 90%</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">access_log /var/log/squid/access.log squid        #定义日志存放记录</span><br><span class=\"line\">cache_log /var/log/squid/cache.log squid</span><br><span class=\"line\">cache_store_log none                        #禁止store日志</span><br><span class=\"line\"></span><br><span class=\"line\">emulate_httpd_log on        #将使Squid仿照Web服务器的格式创建访问记录。如果希望使用</span><br><span class=\"line\">                                #Web访问记录分析程序，就需要设置这个参数。</span><br><span class=\"line\"></span><br><span class=\"line\">refresh_pattern . 0 20% 4320 override-expire override-lastmod reload-into-ims ignore-reload   #更新cache规则</span><br><span class=\"line\"></span><br><span class=\"line\">acl buggy_server url_regex ^http://.... http://          #只允许http的请求</span><br><span class=\"line\">broken_posts allow buggy_server</span><br><span class=\"line\"></span><br><span class=\"line\">acl apache rep_header Server ^Apache                 #允许apache的编码</span><br><span class=\"line\">broken_vary_encoding allow apache</span><br><span class=\"line\"></span><br><span class=\"line\">request_entities off                                        #禁止非http的标分准请求，防止攻击</span><br><span class=\"line\">header_access header allow all                        #允许所有的http报头</span><br><span class=\"line\">relaxed_header_parser on                                #不严格分析http报头.</span><br><span class=\"line\">client_lifetime 120 minute                                #最大客户连接时间 120分钟</span><br><span class=\"line\"></span><br><span class=\"line\">cache_mgr sky@test.com                        #指定当缓冲出现问题时向缓冲管理者发送告警信息的地址信息。</span><br><span class=\"line\"></span><br><span class=\"line\">cache_effective_user squid                        #这里以用户squid的身份Squid服务器</span><br><span class=\"line\">cache_effective_group squid</span><br><span class=\"line\"></span><br><span class=\"line\">icp_port 0                       #指定Squid从邻居服务器缓冲内发送和接收ICP请求的端口号。</span><br><span class=\"line\">                     #这里设置为0是因为这里配置Squid为内部Web服务器的加速器，</span><br><span class=\"line\">                     #所以不需要使用邻居服务器的缓冲。0是禁用</span><br><span class=\"line\"></span><br><span class=\"line\"># cache_peer 设置允许更新缓存的主机，因是本机所以127.0.0.1</span><br><span class=\"line\">cache_peer 127.0.0.1 parent 80 0 no-query default multicast-responder no-netdb-exchange</span><br><span class=\"line\">cache_peer_domain 127.0.0.1                                 </span><br><span class=\"line\">hostname_aliases 127.0.0.1</span><br><span class=\"line\"></span><br><span class=\"line\">error_directory /usr/share/squid/errors/Simplify_Chinese        #定义错误路径</span><br><span class=\"line\"></span><br><span class=\"line\">always_direct allow all                # cache丢失或不存在是允许所有请求直接转发到原始服务器</span><br><span class=\"line\">ignore_unknown_nameservers on        #开反DNS查询，当域名地址不相同时候，禁止访问</span><br><span class=\"line\">coredump_dir  /var/log/squid                 #定义dump的目录</span><br><span class=\"line\"></span><br><span class=\"line\">max_filedesc 2048                #最大打开的文件描述</span><br><span class=\"line\"></span><br><span class=\"line\">half_closed_clients off        #使Squid在当read不再返回数据时立即关闭客户端的连接。</span><br><span class=\"line\">                                #有时read不再返回数据是由于某些客户关闭TCP的发送数据</span><br><span class=\"line\">                                #而仍然保持接收数据。而Squid分辨不出TCP半关闭和完全关闭。</span><br><span class=\"line\"></span><br><span class=\"line\">buffered_logs on #若打开选项“buffered_logs”可以稍稍提高加速某些对日志文件的写入，该选项主要是实现优化特性。</span><br><span class=\"line\"></span><br><span class=\"line\">#防止天涯盗链，转嫁给百度</span><br><span class=\"line\">acl tianya referer_regex -i tianya</span><br><span class=\"line\">http_access deny tianya</span><br><span class=\"line\">deny_info  tianya</span><br><span class=\"line\">#阻止baidu蜘蛛</span><br><span class=\"line\">acl baidu req_header User-Agent Baiduspider</span><br><span class=\"line\">http_access deny baidu</span><br><span class=\"line\">#限制同一IP客户端的最大连接数</span><br><span class=\"line\">acl OverConnLimit maxconn 128</span><br><span class=\"line\">http_access deny OverConnLimit</span><br><span class=\"line\"></span><br><span class=\"line\">#防止被人利用为HTTP代理，设置允许访问的IP地址</span><br><span class=\"line\">acl myip dst 222.18.63.37</span><br><span class=\"line\">http_access deny !myip</span><br><span class=\"line\"></span><br><span class=\"line\">#允许本地管理</span><br><span class=\"line\">acl Manager proto cache_object</span><br><span class=\"line\">acl Localhost src 127.0.0.1 222.18.63.37</span><br><span class=\"line\">http_access allow Manager Localhost</span><br><span class=\"line\">cachemgr_passwd 53034338 all</span><br><span class=\"line\">http_access deny Manager</span><br><span class=\"line\"></span><br><span class=\"line\">#仅仅允许80端口的代理</span><br><span class=\"line\">acl all src 0.0.0.0/0.0.0.0</span><br><span class=\"line\">acl Safe_ports port 80 # http</span><br><span class=\"line\">http_access deny !Safe_ports</span><br><span class=\"line\">http_access allow all</span><br><span class=\"line\"></span><br><span class=\"line\">#Squid信息设置</span><br><span class=\"line\">visible_hostname happy.swjtu.edu.cn</span><br><span class=\"line\">cache_mgr  ooopic2008@qq.com</span><br><span class=\"line\"></span><br><span class=\"line\">#基本设置</span><br><span class=\"line\">cache_effective_user squid</span><br><span class=\"line\">cache_effective_group squid</span><br><span class=\"line\">tcp_recv_bufsize 65535 bytes</span><br><span class=\"line\"></span><br><span class=\"line\">#2.6的反向代理加速配置</span><br><span class=\"line\">cache_peer 127.0.0.1 parent 80 0 no-query originserver</span><br><span class=\"line\"></span><br><span class=\"line\">#错误文档</span><br><span class=\"line\">error_directory /usr/local/squid/share/errors/Simplify_Chinese</span><br><span class=\"line\"></span><br><span class=\"line\">#单台使用，不使用该功能</span><br><span class=\"line\">icp_port 0</span><br><span class=\"line\"></span><br><span class=\"line\">hierarchy_stoplist cgi-bin ?</span><br><span class=\"line\"></span><br><span class=\"line\">acl QUERY urlpath_regex cgi-bin \\? .php .cgi .avi .wmv .rm .ram .mpg .mpeg .zip .exe</span><br><span class=\"line\">cache deny QUERY</span><br><span class=\"line\"></span><br><span class=\"line\">acl apache rep_header Server ^Apache</span><br><span class=\"line\">broken_vary_encoding allow apache</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">refresh_pattern ^ftp:           1440 20%     10080</span><br><span class=\"line\">refresh_pattern ^gopher:        1440 0%    1440</span><br><span class=\"line\">refresh_pattern .             0    20%     4320</span><br><span class=\"line\"></span><br><span class=\"line\">cache_store_log none</span><br><span class=\"line\">pid_filename /usr/local/squid/var/logs/squid.pid</span><br><span class=\"line\">emulate_httpd_log on</span><br></pre></td></tr></table></figure><h2 id=\"Squid常用命令\"><a href=\"#Squid常用命令\" class=\"headerlink\" title=\"Squid常用命令\"></a>Squid常用命令</h2><ol><li>初始化在squid.conf里配置的cache目录<br>squid -z<br>如果有错误提示，请检查cache目录的权限，可以更改目录权限<br>chown -R squid:squid /cache目录</li><li>对squid.conf排错，即验证squid.conf的语法和配置<br>squid -k parse<br>如果在squid.conf中有语法或配置错误，这里会返回提示，若无返回，尝试启动squid</li><li>前台启动squid，并输出启动过程<br>/usr/local/squid/sbin/squid -N -d1<br>如果有ready to server reques相关信息，说明squid启动成功<br>然后ctrl+c ,停止squid,并以后台运行的方式启动它</li><li>启动squid在后台运行<br>squid -s<br>可以使用ps -ax | grep squid 来查看squid进程是否存在</li><li>停止squid<br>squid -k shutdown</li><li>重新引导修改过的squid.conf<br>squid -k reconfigure -f /XXX/squid.conf<br>当squid进行配置更改后，可以使用该命令进行squid配置重载</li><li>把squid添加到系统启动项<br>vim /etc/rc.local<br>/usr/local/squid/sbin/squid -s</li><li>修改cache缓存目录的权限<br>chown -R squid.squid /cache目录<br>cache缓存目录根据自己的配置更改，squid用户和组是squid，squid</li><li>修改squid日志目录的权限<br>chown -R squid.squid 定义的日志文件所在目录<br>这一步并不是适合每一个使用squid的用户，意为让squid有权限在该目录里进行写操作</li><li>查看你的日志文档<br>more /usr/local/squid/var/logs/access.log | grep TCP_MEM_HIT<br>该指令可以看到在squid运行过程中，有那些文件被squid缓存到内存中，并返回给访问用户。<br>more /usr/local/squid/var/logs/access.log | grep TCP_HIT<br>该指令可以看到在squid运行过程中，有那些文件被squid缓存到cache目录中，并返回给访问用户。<br>more /usr/local/squid/var/logs/access.log | grep TCP_MISS<br>该指令可以看到在squid运行过程中，有那些文件没有被squid缓存，而是从原始服务器获取并返回给访问用户。</li></ol><h2 id=\"Squid命中率分析\"><a href=\"#Squid命中率分析\" class=\"headerlink\" title=\"Squid命中率分析\"></a>Squid命中率分析</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/local/squid/bin/squidclient -p 80 mgr:info</span><br><span class=\"line\">/usr/local/squid/bin/squidclient -p 80 mgr:5min</span><br></pre></td></tr></table></figure><p>可以看到详细的性能情况,其中PORT是你的proxy的端口，5min可以是60min<br>取得squid运行状态信息：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">squidclient -p 80 mgr:info</span><br></pre></td></tr></table></figure><p>取得squid内存使用情况：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">squidclient -p 80 mgr:mem</span><br></pre></td></tr></table></figure><p>取得squid已经缓存的列表：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">squidclient -p 80 mgr:bjects. use it carefully,it may crash</span><br></pre></td></tr></table></figure><p>取得squid的磁盘使用情况：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">squidclient -p 80 mgr:diskd</span><br></pre></td></tr></table></figure><p>强制更新某个url：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">squidclient -p 80 -m PURGE http://www.xxx.com/xxx.php</span><br></pre></td></tr></table></figure><p>更多的请查看：squidclient-h 或者 squidclient -p 80 mgr:<br>查命中率：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">squidclient -h IP(具体侦听IP) -p 80(具体侦听端口) mgr:info</span><br></pre></td></tr></table></figure><h2 id=\"定期清理swap-state内无效数据\"><a href=\"#定期清理swap-state内无效数据\" class=\"headerlink\" title=\"定期清理swap.state内无效数据\"></a>定期清理swap.state内无效数据</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/path/to/squid/sbin/squid -k rotate -f /path/to/squid/conf_file</span><br><span class=\"line\">vi /etc/crontab</span><br><span class=\"line\">0        0       *       *       *       root    /usr/local/sbin/squid -k rotate -f /usr/local/etc/squid/squid1.conf</span><br></pre></td></tr></table></figure><p>当squid应用运行了一段时间之后，cache_dir对应的swap.state文件就会变得越来越大，里面的无效接口数据越来越多，这可能影响squid的响应时间，因此需要使用squid清理swap.state里面的无效数据，减少swap.state的大小。</p>","slug":"squid","updated":"2019-05-23T12:33:08.392Z","comments":true,"link":"","permalink":"https://shuntan.github.io/posts/55e3d16d/","excerpt":"squid的概念squid是一种用来缓存Internet数据的软件。接受来自人们需要下载的目标（object）的请求并适当的处理这些请求。也就是说，如果一个人想下载一web界面，他请求squid为他取得这个页面。squid随之连接到远程服务器并向这个页面发出请求。然后，squid显式地聚集数据到客户端机器，而且同时复制一份。当下一次有人需要同一页面时， squid可以简单的从磁盘中读到它，那样数据会立即传输到客户机上。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://shuntan.github.io/categories/Linux/"}],"tags":[{"name":"squid","slug":"squid","permalink":"https://shuntan.github.io/tags/squid/"},{"name":"proxy","slug":"proxy","permalink":"https://shuntan.github.io/tags/proxy/"}]},{"title":"科学上网：用 VPS 搭建 shadowsocks 服务器","date":"2019-05-15T06:38:46.000Z","path":"posts/a067636e/","text":"shadowsocks 简介shadowsocks 是一款自定义协议的代理软件，由于其流量特征不明显，（直到不久前）一直可以稳定提供上网代理。shadowsocks 客户端会在本地开启一个 socks5 代理，通过此代理的网络访问请求由客户端发送至服务端，服务端发出请求，收到响应数据后再发回客户端。因此使用 shadowsocks 需要一台墙外的服务器来部署 shadowsocks 服务端。购买 VPS 服务器主流的 VPS（虚拟主机）服务器提供商有三家：linodedigital oceanbandwagon下面的比上面的便宜。如果只是自用，bandwagon 足够。一般使用 paypal 绑定一个 visa 或 mastercard 信用卡来付款。注意要用国际 paypal 帐号，国内的是不能用外币付款的。在 bandwagon 购买 VPS 以后会获得一个主机地址和用于 ssh 登录的 root 密码。远程登陆 VPSMac或 Linux 下直接在终端中ssh root@your_vps_ip your_ssh_port即可。在 windows 系统下需要专门的客户端来 SSH 登录 VPS。在&nbsp;xShell 官网&nbsp;&nbsp;下载 xShell。家庭和学校用户可以免费试用，下载时选择 home&nbsp;and&nbsp;school&nbsp;use 即可。需要用邮箱注册一下，下载链接会发送到邮箱中。xShell 中新建一个连接，会要求输入目标 IP 地址和端口，以及 root 密码，按提示操作即可。安装 shadowsocks最好是centos71.安装pip由于安装的是python 版本的 shadowsocks，所以首先安装pip$ curl &quot;https://bootstrap.pypa.io/get-pip.py&quot; -o &quot;get-pip.py&quot; $ python get-pip.py 2.安装shadowsocks$ pip install --upgrade pip $ pip install shadowsocks 3.创建配置文件创建文件所在目录:/etc 创建文件命令$ vi /etc/shadowsocks.json 若进入了etc目录$ vi shadowsocks.json 配置文件内容：单端口：1234567891011121314151617&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, --服务器IP，直接用0.0.0.0也可 &quot;server_port&quot;:8888, --端口端口 &quot;local_address&quot;: &quot;127.0.0.1&quot;, --本地地址，可省略 &quot;local_port&quot;:1080,--本地端口，可省略 &quot;password&quot;:&quot;password&quot;,--密码 &quot;timeout&quot;:300, --超时时间，可省略 &quot;method&quot;:&quot;aes-256-cfb&quot;, --加密策略，有多重策略，具体自查&#125;多端口：12345678910111213141516171819202122232425&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;port_password&quot;:&#123;--每个端口对应一个密码 &quot;1111&quot;:&quot;password1&quot;, &quot;1112&quot;:&quot;password2&quot;, &quot;1113&quot;:&quot;password3&quot; &#125;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;:false&#125;4.启动shadowsocks启动ssserver -c /etc/shadowsocks.json -d start 停止ssserver -c /etc/shadowsocks.json -d stop 重启ssserver -c /etc/shadowsocks.json -d restart 启动成功即可通过ss客户端使用。在window端可以在控制台通过以下命令查看端口是否打开telnet {ip} {port} 5.配置自启动新建启动脚本文件/etc/systemd/system/shadowsocks.service，内容如下： [Unit]Description=Shadowsocks [Service]TimeoutStartSec=0 ExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json [Install]WantedBy=multi-user.target 通过以下命令注册，启动服务$ systemctl enable shadowsocks $ systemctl start shadowsocks 启动后可以查看服务状态$ systemctl status shadowsocks -l 若启动成功：● shadowsocks.service - ShadowsocksLoaded: loaded (/etc/systemd/system/shadowsocks.service; enabled; vendor preset: disabled)Active: active (running) since Sun 2017-08-13 18:03:41 CST; 1h 29min agoMain PID: 9567 (ssserver)CGroup: /system.slice/shadowsocks.service└─9567 /usr/bin/python2 /usr/bin/ssserver -c /etc/shadowsocks.json如果，服务失败，重启服务器试一下安装并启动 shadowsocks 客户端shadowsocks 支持 windows、Mac&nbsp;OS&nbsp;X、Linux、Android、iOS 等多个平台。不过 iOS 由于系统对应用后台运行的限制，推荐使用客户端内嵌的浏览器科学上网，给其他应用代理时需要每过几分钟重新启动一下 app。shadowsocks 项目 Github 主页在这里。里面可以找到客户端下载地址。下载安装客户端以后，只需按服务器的配置填写 IP 地址、服务器端口、本地端口（如果没有本地端口选项，就是默认的 1080）、密码、加密方式等参数，启动就可以了。客户端支持全局代理和 PAC 代理两种方式，后者会使用一个脚本来自动检查一个网站是否在需要代理的网站列表中，自动选择直接连接或代理连接。PAC 列表可以在线更新，但是难免有收录不全的情况。这时可以选择关闭 shadowsocks 代理（实际上是取消对系统代理的配置，shadowsocks 客户端仍然保持工作），然后使用支持自定义规则的代理管理插件来实现自动切换代理，比如 switchyOmega。使用 switchyOmega 实现自动切换代理switchyOmega 是 chrome 浏览器上一个很好用的代理管理插件。它的前身 switchySharp 更有名。 chrome 应用商店本身需要翻墙才能访问，因此需要先在 shadowsocks 启动代理模式下下载安装，再关闭 shadowsocks 代理。 安装完毕后，右击 switchyOmega 图标，选择选项，进入 switchOmega 配置界面。 创建 shadowsocks 情景模式新建一个情景模式，比如叫 SS，代理协议选择 socks5，代理地址为 127.0.0.1，端口 1080。 现在切换到 SS 情景模式就可以通过 shadowsocks 科学上网了。后面获取自动切换规则列表 设置自动切换模式在设置界面选择自动切换模式，在 “切换规则” 中勾选“规则列表规则”，对应的情景模式选择刚刚新建的 SS。然后在下面的规则列表地址中填写https://autoproxy-gfwlist.googlecode.com/svn/trunk/gfwlist.txt规则列表格式选择 AutoProxy。然后点击立即更新情景模式， 更新完成后会有提示。点击左侧的 “应用选项”。然后单击 switchyOmega 图标，选择自动切换，就可以在访问“不存在的网站” 时自动切换到 shadowsocks 代理了。添加自定义规则如果遇到某个国外网站无法直接连接或速度太慢时，可以单击 switchyOmega 图标，选择 “添加条件”，情景模式选择 SS，就可以了。这时打开 switchyOmega 选项，在自动切换模式的切换规则中就可以看到刚刚添加的规则。可以在这里管理自定义的规则。导入和导出 switchyOmega 设置如果换了一台电脑，重新设置一遍 switchyOmega 就太麻烦了。可以在设置好的 switchyOmega 中导出设置文件，在另一个 chrome 浏览器中导入，就可以直接复制原来的设置了。在 switchyOmega 选项的左侧点击 “导入 / 导出”，点击“生成备份文件” 即可生成 switchyOmega 设置备份。点击 “从备份文件恢复” 可以导入备份文件。","raw":"---\ntitle: 科学上网：用 VPS 搭建 shadowsocks 服务器\ncopyright: true\ntags:\n  - VPS\n  - shadowsocks\ncategories: Linux\nabbrlink: a067636e\ndate: 2019-05-15 14:38:46\ntype:\nkeyword:\ntop:\ncomments:\npassword:\n---\n\n## shadowsocks 简介\n\nshadowsocks 是一款自定义协议的代理软件，由于其流量特征不明显，（直到不久前）一直可以稳定提供上网代理。\n\nshadowsocks 客户端会在本地开启一个 socks5 代理，通过此代理的网络访问请求由客户端发送至服务端，服务端发出请求，收到响应数据后再发回客户端。\n\n因此使用 shadowsocks 需要一台墙外的服务器来部署 shadowsocks 服务端。\n\n<!-- more -->\n\n## 购买 VPS 服务器\n\n  主流的 VPS（虚拟主机）服务器提供商有三家：\n\n*   linode\n*   digital ocean\n*   bandwagon\n\n下面的比上面的便宜。如果只是自用，bandwagon 足够。\n\n一般使用 paypal 绑定一个 visa 或 mastercard 信用卡来付款。注意要用国际 paypal 帐号，国内的是不能用外币付款的。\n\n在 bandwagon 购买 VPS 以后会获得一个主机地址和用于 ssh 登录的 root 密码。\n\n## 远程登陆 VPS\n\n  Mac或 Linux 下直接在终端中ssh root@your_vps_ip your_ssh_port即可。\n在 windows 系统下需要专门的客户端来 SSH 登录 VPS。在&nbsp;[xShell 官网](http://www.netsarang.com/download/down_form.html?code=522&amp;utm_source=textarea.com&amp;utm_medium=textarea.com&amp;utm_campaign=article)&nbsp;&nbsp;下载 xShell。\n\n  家庭和学校用户可以免费试用，下载时选择 home&nbsp;and&nbsp;school&nbsp;use 即可。需要用邮箱注册一下，下载链接会发送到邮箱中。\n\n  xShell 中新建一个连接，会要求输入目标 IP 地址和端口，以及 root 密码，按提示操作即可。\n\n## 安装 shadowsocks\n\n最好是centos7\n\n1.安装pip\n\n由于安装的是python 版本的 shadowsocks，所以首先安装pip\n\n\t$ curl \"https://bootstrap.pypa.io/get-pip.py\" -o \"get-pip.py\"\n\n\t$ python get-pip.py\n\n2.安装shadowsocks\t\n\n\t$ pip install --upgrade pip\n\n\t$ pip install shadowsocks\n\n3.创建配置文件\n\n\t创建文件所在目录:/etc\n\n创建文件命令\n\n\t$ vi /etc/shadowsocks.json\n\n若进入了etc目录\n\n\t$ vi shadowsocks.json\n\n配置文件内容：\n\n单端口：\n\n```\n{\n\n \"server\":\"0.0.0.0\", --服务器IP，直接用0.0.0.0也可\n\n \"server_port\":8888, --端口端口\n\n \"local_address\": \"127.0.0.1\", --本地地址，可省略\n\n \"local_port\":1080,--本地端口，可省略\n\n \"password\":\"password\",--密码\n\n \"timeout\":300, --超时时间，可省略\n\n \"method\":\"aes-256-cfb\", --加密策略，有多重策略，具体自查\n\n}\n```\n\n多端口：\n\n```\n{\n\n \"server\":\"0.0.0.0\",\n\n \"local_address\":\"127.0.0.1\",\n\n \"local_port\":1080,\n\n \"port_password\":{--每个端口对应一个密码\n\n \"1111\":\"password1\",\n\n \"1112\":\"password2\",\n\n \"1113\":\"password3\"\n\n },\n\n \"timeout\":300,\n\n \"method\":\"aes-256-cfb\",\n\n \"fast_open\":false\n\n}\n```\n\n4.启动shadowsocks\n\n启动\n\n\tssserver -c /etc/shadowsocks.json -d start\n\n停止\n\n\tssserver -c /etc/shadowsocks.json -d stop\n\n重启\n\n\tssserver -c /etc/shadowsocks.json -d restart\n\n启动成功即可通过ss客户端使用。\n\n在window端可以在控制台通过以下命令查看端口是否打开\n\n\ttelnet {ip} {port}\n\n5.配置自启动\n\n\t新建启动脚本文件/etc/systemd/system/shadowsocks.service，内容如下：\n\n[Unit]\n\n\tDescription=Shadowsocks\n\n[Service]\n\n\tTimeoutStartSec=0\n\n\tExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json\n\n[Install]\n\n\tWantedBy=multi-user.target\n\n通过以下命令注册，启动服务\n\n\t$ systemctl enable shadowsocks\n\n\t$ systemctl start shadowsocks\n\n启动后可以查看服务状态\n\n\t$ systemctl status shadowsocks -l\n\n若启动成功：\n\n● shadowsocks.service - Shadowsocks\n\nLoaded: loaded (/etc/systemd/system/shadowsocks.service; enabled; vendor preset: disabled)\n\nActive: active (running) since Sun 2017-08-13 18:03:41 CST; 1h 29min ago\n\nMain PID: 9567 (ssserver)\n\nCGroup: /system.slice/shadowsocks.service\n\n└─9567 /usr/bin/python2 /usr/bin/ssserver -c /etc/shadowsocks.json\n如果，服务失败，重启服务器试一下\n\n## 安装并启动 shadowsocks 客户端\n\n  shadowsocks 支持 windows、Mac&nbsp;OS&nbsp;X、Linux、Android、iOS 等多个平台。不过 iOS 由于系统对应用后台运行的限制，推荐使用客户端内嵌的浏览器科学上网，给其他应用代理时需要每过几分钟重新启动一下 app。\n\n  shadowsocks 项目 Github 主页在[这里](https://github.com/shadowsocks/shadowsocks?utm_source=textarea.com&amp;utm_medium=textarea.com&amp;utm_campaign=article)。\n\n  里面可以找到客户端下载地址。\n\n  下载安装客户端以后，只需按服务器的配置填写 IP 地址、服务器端口、本地端口（如果没有本地端口选项，就是默认的 1080）、密码、加密方式等参数，启动就可以了。\n\n  客户端支持全局代理和 PAC 代理两种方式，后者会使用一个脚本来自动检查一个网站是否在需要代理的网站列表中，自动选择直接连接或代理连接。\n\n  PAC 列表可以在线更新，但是难免有收录不全的情况。这时可以选择关闭 shadowsocks 代理（实际上是取消对系统代理的配置，shadowsocks 客户端仍然保持工作），然后使用支持自定义规则的代理管理插件来实现自动切换代理，比如 switchyOmega。\n\n## 使用 switchyOmega 实现自动切换代理\n\n\tswitchyOmega 是 chrome 浏览器上一个很好用的代理管理插件。它的前身 switchySharp 更有名。\n\n\tchrome 应用商店本身需要翻墙才能访问，因此需要先在 shadowsocks 启动代理模式下下载安装，再关闭 shadowsocks 代理。\n\n\t安装完毕后，右击 switchyOmega 图标，选择选项，进入 switchOmega 配置界面。\n\n### 创建 shadowsocks 情景模式\n\n\t新建一个情景模式，比如叫 SS，代理协议选择 socks5，代理地址为 127.0.0.1，端口 1080。\n\n\t现在切换到 SS 情景模式就可以通过 shadowsocks 科学上网了。后面获取自动切换规则列表\n\n### 设置自动切换模式\n\n  在设置界面选择自动切换模式，在 “切换规则” 中勾选“规则列表规则”，对应的情景模式选择刚刚新建的 SS。\n\n  然后在下面的规则列表地址中填写\n\n  https://autoproxy-gfwlist.googlecode.com/svn/trunk/gfwlist.txt\n\n  规则列表格式选择 AutoProxy。\n\n  然后点击立即更新情景模式， 更新完成后会有提示。\n\n  点击左侧的 “应用选项”。然后单击 switchyOmega 图标，选择自动切换，就可以在访问“不存在的网站” 时自动切换到 shadowsocks 代理了。\n\n### 添加自定义规则\n\n  如果遇到某个国外网站无法直接连接或速度太慢时，可以单击 switchyOmega 图标，选择 “添加条件”，情景模式选择 SS，就可以了。\n\n  这时打开 switchyOmega 选项，在自动切换模式的切换规则中就可以看到刚刚添加的规则。可以在这里管理自定义的规则。\n\n### 导入和导出 switchyOmega 设置\n\n  如果换了一台电脑，重新设置一遍 switchyOmega 就太麻烦了。可以在设置好的 switchyOmega 中导出设置文件，在另一个 chrome 浏览器中导入，就可以直接复制原来的设置了。\n\n  在 switchyOmega 选项的左侧点击 “导入 / 导出”，点击“生成备份文件” 即可生成 switchyOmega 设置备份。点击 “从备份文件恢复” 可以导入备份文件。\n","content":"<h2 id=\"shadowsocks-简介\"><a href=\"#shadowsocks-简介\" class=\"headerlink\" title=\"shadowsocks 简介\"></a>shadowsocks 简介</h2><p>shadowsocks 是一款自定义协议的代理软件，由于其流量特征不明显，（直到不久前）一直可以稳定提供上网代理。</p><p>shadowsocks 客户端会在本地开启一个 socks5 代理，通过此代理的网络访问请求由客户端发送至服务端，服务端发出请求，收到响应数据后再发回客户端。</p><p>因此使用 shadowsocks 需要一台墙外的服务器来部署 shadowsocks 服务端。</p><a id=\"more\"></a><h2 id=\"购买-VPS-服务器\"><a href=\"#购买-VPS-服务器\" class=\"headerlink\" title=\"购买 VPS 服务器\"></a>购买 VPS 服务器</h2><p>主流的 VPS（虚拟主机）服务器提供商有三家：</p><ul><li>linode</li><li>digital ocean</li><li>bandwagon</li></ul><p>下面的比上面的便宜。如果只是自用，bandwagon 足够。</p><p>一般使用 paypal 绑定一个 visa 或 mastercard 信用卡来付款。注意要用国际 paypal 帐号，国内的是不能用外币付款的。</p><p>在 bandwagon 购买 VPS 以后会获得一个主机地址和用于 ssh 登录的 root 密码。</p><h2 id=\"远程登陆-VPS\"><a href=\"#远程登陆-VPS\" class=\"headerlink\" title=\"远程登陆 VPS\"></a>远程登陆 VPS</h2><p>Mac或 Linux 下直接在终端中ssh root@your_vps_ip your_ssh_port即可。<br>在 windows 系统下需要专门的客户端来 SSH 登录 VPS。在&nbsp;<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5uZXRzYXJhbmcuY29tL2Rvd25sb2FkL2Rvd25fZm9ybS5odG1sP2NvZGU9NTIyJmFtcDt1dG1fc291cmNlPXRleHRhcmVhLmNvbSZhbXA7dXRtX21lZGl1bT10ZXh0YXJlYS5jb20mYW1wO3V0bV9jYW1wYWlnbj1hcnRpY2xl\" title=\"http://www.netsarang.com/download/down_form.html?code=522&amp;utm_source=textarea.com&amp;utm_medium=textarea.com&amp;utm_campaign=article\">xShell 官网<i class=\"fa fa-external-link\"></i></span>&nbsp;&nbsp;下载 xShell。</p><p>家庭和学校用户可以免费试用，下载时选择 home&nbsp;and&nbsp;school&nbsp;use 即可。需要用邮箱注册一下，下载链接会发送到邮箱中。</p><p>xShell 中新建一个连接，会要求输入目标 IP 地址和端口，以及 root 密码，按提示操作即可。</p><h2 id=\"安装-shadowsocks\"><a href=\"#安装-shadowsocks\" class=\"headerlink\" title=\"安装 shadowsocks\"></a>安装 shadowsocks</h2><p>最好是centos7</p><p>1.安装pip</p><p>由于安装的是python 版本的 shadowsocks，所以首先安装pip</p><pre><code>$ curl &quot;https://bootstrap.pypa.io/get-pip.py&quot; -o &quot;get-pip.py&quot;\n\n$ python get-pip.py\n</code></pre><p>2.安装shadowsocks</p><pre><code>$ pip install --upgrade pip\n\n$ pip install shadowsocks\n</code></pre><p>3.创建配置文件</p><pre><code>创建文件所在目录:/etc\n</code></pre><p>创建文件命令</p><pre><code>$ vi /etc/shadowsocks.json\n</code></pre><p>若进入了etc目录</p><pre><code>$ vi shadowsocks.json\n</code></pre><p>配置文件内容：</p><p>单端口：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> &quot;server&quot;:&quot;0.0.0.0&quot;, --服务器IP，直接用0.0.0.0也可</span><br><span class=\"line\"></span><br><span class=\"line\"> &quot;server_port&quot;:8888, --端口端口</span><br><span class=\"line\"></span><br><span class=\"line\"> &quot;local_address&quot;: &quot;127.0.0.1&quot;, --本地地址，可省略</span><br><span class=\"line\"></span><br><span class=\"line\"> &quot;local_port&quot;:1080,--本地端口，可省略</span><br><span class=\"line\"></span><br><span class=\"line\"> &quot;password&quot;:&quot;password&quot;,--密码</span><br><span class=\"line\"></span><br><span class=\"line\"> &quot;timeout&quot;:300, --超时时间，可省略</span><br><span class=\"line\"></span><br><span class=\"line\"> &quot;method&quot;:&quot;aes-256-cfb&quot;, --加密策略，有多重策略，具体自查</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>多端口：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> &quot;server&quot;:&quot;0.0.0.0&quot;,</span><br><span class=\"line\"></span><br><span class=\"line\"> &quot;local_address&quot;:&quot;127.0.0.1&quot;,</span><br><span class=\"line\"></span><br><span class=\"line\"> &quot;local_port&quot;:1080,</span><br><span class=\"line\"></span><br><span class=\"line\"> &quot;port_password&quot;:&#123;--每个端口对应一个密码</span><br><span class=\"line\"></span><br><span class=\"line\"> &quot;1111&quot;:&quot;password1&quot;,</span><br><span class=\"line\"></span><br><span class=\"line\"> &quot;1112&quot;:&quot;password2&quot;,</span><br><span class=\"line\"></span><br><span class=\"line\"> &quot;1113&quot;:&quot;password3&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"> &quot;timeout&quot;:300,</span><br><span class=\"line\"></span><br><span class=\"line\"> &quot;method&quot;:&quot;aes-256-cfb&quot;,</span><br><span class=\"line\"></span><br><span class=\"line\"> &quot;fast_open&quot;:false</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>4.启动shadowsocks</p><p>启动</p><pre><code>ssserver -c /etc/shadowsocks.json -d start\n</code></pre><p>停止</p><pre><code>ssserver -c /etc/shadowsocks.json -d stop\n</code></pre><p>重启</p><pre><code>ssserver -c /etc/shadowsocks.json -d restart\n</code></pre><p>启动成功即可通过ss客户端使用。</p><p>在window端可以在控制台通过以下命令查看端口是否打开</p><pre><code>telnet {ip} {port}\n</code></pre><p>5.配置自启动</p><pre><code>新建启动脚本文件/etc/systemd/system/shadowsocks.service，内容如下：\n</code></pre><p>[Unit]</p><pre><code>Description=Shadowsocks\n</code></pre><p>[Service]</p><pre><code>TimeoutStartSec=0\n\nExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json\n</code></pre><p>[Install]</p><pre><code>WantedBy=multi-user.target\n</code></pre><p>通过以下命令注册，启动服务</p><pre><code>$ systemctl enable shadowsocks\n\n$ systemctl start shadowsocks\n</code></pre><p>启动后可以查看服务状态</p><pre><code>$ systemctl status shadowsocks -l\n</code></pre><p>若启动成功：</p><p>● shadowsocks.service - Shadowsocks</p><p>Loaded: loaded (/etc/systemd/system/shadowsocks.service; enabled; vendor preset: disabled)</p><p>Active: active (running) since Sun 2017-08-13 18:03:41 CST; 1h 29min ago</p><p>Main PID: 9567 (ssserver)</p><p>CGroup: /system.slice/shadowsocks.service</p><p>└─9567 /usr/bin/python2 /usr/bin/ssserver -c /etc/shadowsocks.json<br>如果，服务失败，重启服务器试一下</p><h2 id=\"安装并启动-shadowsocks-客户端\"><a href=\"#安装并启动-shadowsocks-客户端\" class=\"headerlink\" title=\"安装并启动 shadowsocks 客户端\"></a>安装并启动 shadowsocks 客户端</h2><p>shadowsocks 支持 windows、Mac&nbsp;OS&nbsp;X、Linux、Android、iOS 等多个平台。不过 iOS 由于系统对应用后台运行的限制，推荐使用客户端内嵌的浏览器科学上网，给其他应用代理时需要每过几分钟重新启动一下 app。</p><p>shadowsocks 项目 Github 主页在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NoYWRvd3NvY2tzL3NoYWRvd3NvY2tzP3V0bV9zb3VyY2U9dGV4dGFyZWEuY29tJmFtcDt1dG1fbWVkaXVtPXRleHRhcmVhLmNvbSZhbXA7dXRtX2NhbXBhaWduPWFydGljbGU=\" title=\"https://github.com/shadowsocks/shadowsocks?utm_source=textarea.com&amp;utm_medium=textarea.com&amp;utm_campaign=article\">这里<i class=\"fa fa-external-link\"></i></span>。</p><p>里面可以找到客户端下载地址。</p><p>下载安装客户端以后，只需按服务器的配置填写 IP 地址、服务器端口、本地端口（如果没有本地端口选项，就是默认的 1080）、密码、加密方式等参数，启动就可以了。</p><p>客户端支持全局代理和 PAC 代理两种方式，后者会使用一个脚本来自动检查一个网站是否在需要代理的网站列表中，自动选择直接连接或代理连接。</p><p>PAC 列表可以在线更新，但是难免有收录不全的情况。这时可以选择关闭 shadowsocks 代理（实际上是取消对系统代理的配置，shadowsocks 客户端仍然保持工作），然后使用支持自定义规则的代理管理插件来实现自动切换代理，比如 switchyOmega。</p><h2 id=\"使用-switchyOmega-实现自动切换代理\"><a href=\"#使用-switchyOmega-实现自动切换代理\" class=\"headerlink\" title=\"使用 switchyOmega 实现自动切换代理\"></a>使用 switchyOmega 实现自动切换代理</h2><pre><code>switchyOmega 是 chrome 浏览器上一个很好用的代理管理插件。它的前身 switchySharp 更有名。\n\nchrome 应用商店本身需要翻墙才能访问，因此需要先在 shadowsocks 启动代理模式下下载安装，再关闭 shadowsocks 代理。\n\n安装完毕后，右击 switchyOmega 图标，选择选项，进入 switchOmega 配置界面。\n</code></pre><h3 id=\"创建-shadowsocks-情景模式\"><a href=\"#创建-shadowsocks-情景模式\" class=\"headerlink\" title=\"创建 shadowsocks 情景模式\"></a>创建 shadowsocks 情景模式</h3><pre><code>新建一个情景模式，比如叫 SS，代理协议选择 socks5，代理地址为 127.0.0.1，端口 1080。\n\n现在切换到 SS 情景模式就可以通过 shadowsocks 科学上网了。后面获取自动切换规则列表\n</code></pre><h3 id=\"设置自动切换模式\"><a href=\"#设置自动切换模式\" class=\"headerlink\" title=\"设置自动切换模式\"></a>设置自动切换模式</h3><p>在设置界面选择自动切换模式，在 “切换规则” 中勾选“规则列表规则”，对应的情景模式选择刚刚新建的 SS。</p><p>然后在下面的规则列表地址中填写</p><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hdXRvcHJveHktZ2Z3bGlzdC5nb29nbGVjb2RlLmNvbS9zdm4vdHJ1bmsvZ2Z3bGlzdC50eHQ=\" title=\"https://autoproxy-gfwlist.googlecode.com/svn/trunk/gfwlist.txt\">https://autoproxy-gfwlist.googlecode.com/svn/trunk/gfwlist.txt<i class=\"fa fa-external-link\"></i></span></p><p>规则列表格式选择 AutoProxy。</p><p>然后点击立即更新情景模式， 更新完成后会有提示。</p><p>点击左侧的 “应用选项”。然后单击 switchyOmega 图标，选择自动切换，就可以在访问“不存在的网站” 时自动切换到 shadowsocks 代理了。</p><h3 id=\"添加自定义规则\"><a href=\"#添加自定义规则\" class=\"headerlink\" title=\"添加自定义规则\"></a>添加自定义规则</h3><p>如果遇到某个国外网站无法直接连接或速度太慢时，可以单击 switchyOmega 图标，选择 “添加条件”，情景模式选择 SS，就可以了。</p><p>这时打开 switchyOmega 选项，在自动切换模式的切换规则中就可以看到刚刚添加的规则。可以在这里管理自定义的规则。</p><h3 id=\"导入和导出-switchyOmega-设置\"><a href=\"#导入和导出-switchyOmega-设置\" class=\"headerlink\" title=\"导入和导出 switchyOmega 设置\"></a>导入和导出 switchyOmega 设置</h3><p>如果换了一台电脑，重新设置一遍 switchyOmega 就太麻烦了。可以在设置好的 switchyOmega 中导出设置文件，在另一个 chrome 浏览器中导入，就可以直接复制原来的设置了。</p><p>在 switchyOmega 选项的左侧点击 “导入 / 导出”，点击“生成备份文件” 即可生成 switchyOmega 设置备份。点击 “从备份文件恢复” 可以导入备份文件。</p>","slug":"shadowsocks","updated":"2019-05-23T12:33:08.378Z","comments":true,"link":"","permalink":"https://shuntan.github.io/posts/a067636e/","excerpt":"shadowsocks 简介shadowsocks 是一款自定义协议的代理软件，由于其流量特征不明显，（直到不久前）一直可以稳定提供上网代理。shadowsocks 客户端会在本地开启一个 socks5 代理，通过此代理的网络访问请求由客户端发送至服务端，服务端发出请求，收到响应数据后再发回客户端。因此使用 shadowsocks 需要一台墙外的服务器来部署 shadowsocks 服务端。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://shuntan.github.io/categories/Linux/"}],"tags":[{"name":"VPS","slug":"VPS","permalink":"https://shuntan.github.io/tags/VPS/"},{"name":"shadowsocks","slug":"shadowsocks","permalink":"https://shuntan.github.io/tags/shadowsocks/"}]},{"title":"Tag Plugins","date":"2019-05-10T04:35:58.000Z","path":"posts/e2e5eeac/","text":"FAQWelcome to tag-pluginsTag Plugin is a way to make special style contents supported by Hexo. For example, we cannot show a image with custom size in standard Markdown. And then we can use tag plugins to solve it. Hexo has a lot of tags which can help user. And Hexo also have interfaces to themes which make themes able to create their own tags. Following tags is provided by NexT:Centered QuoteInclude RawButtonFull ImageGroup PicturesLabelMermaidNotePDFTabsVideoCentered QuoteThis tag will make a quote with two lines before and after it, and text quoted will be centered. When using centered quote, if we have multi-line text, and each line has a different length, the quote won’t be symmetrical, so it’s recommended to use when only have single line text. For example before article all after article to make a summary.Usagecenter-quote.js123&#123;% centerquote %&#125;Something&#123;% endcenterquote %&#125;&lt;!-- Tag Alias --&gt;&#123;% cq %&#125;Something&#123;% endcq %&#125;Example1&#123;% cq %&#125;Elegant in code, simple in core&#123;% endcq %&#125;Elegant in code, simple in coreInclude RawThis tag include any raw content into your posts. Path is relative to your site source directory.Usageinclude-raw.js1&#123;% include_raw '_data/path/to/file.html' %&#125;ExampleLet’s create include-raw.html file in _data directory under site root directory with following content:1Any &lt;strong&gt;raw content&lt;/strong&gt; may be included with this tag.Then in any post we can use this content with include_raw tag:1&#123;% include_raw '_data/path/to/include-raw.html' %&#125;","raw":"---\ntitle: Tag Plugins\ncopyright: true\ntags:\n  - Hexo\n  - Next\ncategories:\n  - Hexo\nabbrlink: e2e5eeac\ndate: 2019-05-10 12:35:58\ntype:\nkeyword:\ntop:\ncomments:\npassword:\n---\n\n{% note info %}\n### FAQ\n**Welcome** to [tag-plugins](https://theme-next.org/docs/tag-plugins/)\n{% endnote %}\n\nTag Plugin is a way to make special style contents supported by Hexo. For example, we cannot show a image with custom size in standard Markdown. And then we can use tag plugins to solve it. [Hexo has a lot of tags](https://hexo.io/docs/tag-plugins) which can help user. And Hexo also have interfaces to themes which make themes able to create their own tags. Following tags is provided by NexT:\n\n<!--more-->\n\n* [Centered Quote](#Centered-Quote)\n* [Include Raw](#Include-Raw)\n* [Button](/docs/tag-plugins/button)\n* [Full Image](/docs/tag-plugins/full-image)\n* [Group Pictures](/docs/tag-plugins/group-pictures)\n* [Label](/docs/tag-plugins/label)\n* [Mermaid](/docs/tag-plugins/mermaid)\n* [Note](/docs/tag-plugins/note)\n* [PDF](/docs/tag-plugins/pdf)\n* [Tabs](/docs/tag-plugins/tabs)\n* [Video](/docs/tag-plugins/video)\n\n### Centered Quote\n\nThis tag will make a quote with two lines before and after it, and text quoted will be centered. When using centered quote, if we have multi-line text, and each line has a different length, the quote won't be symmetrical, so it's recommended to use when only have single line text. For example before article all after article to make a summary.\n\n#### Usage\n\n```html center-quote.js\n{% centerquote %}Something{% endcenterquote %}\n<!-- Tag Alias -->\n{% cq %}Something{% endcq %}\n```\n\n#### Example\n\n```md\n{% cq %}Elegant in code, simple in core{% endcq %}\n```\n\n{% cq %}Elegant in code, simple in core{% endcq %}\n\n### Include Raw\n\nThis tag include any raw content into your posts. Path is relative to your site source directory.\n\n#### Usage\n\n```html include-raw.js\n{% include_raw '_data/path/to/file.html' %}\n```\n\n#### Example\n\nLet's create `include-raw.html` file in `_data` directory under {% label info@site root directory %} with following content:\n\n```html\nAny <strong>raw content</strong> may be included with this tag.\n```\n\nThen in any post we can use this content with `include_raw` tag:\n\n```md\n{% include_raw '_data/path/to/include-raw.html' %}\n```\n\n{% include_raw '_data/include-raw.html' %}","content":"<div class=\"note info\"><h3 id=\"FAQ\"><a href=\"#FAQ\" class=\"headerlink\" title=\"FAQ\"></a>FAQ</h3><p><strong>Welcome</strong> to <span class=\"exturl\" data-url=\"aHR0cHM6Ly90aGVtZS1uZXh0Lm9yZy9kb2NzL3RhZy1wbHVnaW5zLw==\" title=\"https://theme-next.org/docs/tag-plugins/\">tag-plugins<i class=\"fa fa-external-link\"></i></span></p></div><p>Tag Plugin is a way to make special style contents supported by Hexo. For example, we cannot show a image with custom size in standard Markdown. And then we can use tag plugins to solve it. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdGFnLXBsdWdpbnM=\" title=\"https://hexo.io/docs/tag-plugins\">Hexo has a lot of tags<i class=\"fa fa-external-link\"></i></span> which can help user. And Hexo also have interfaces to themes which make themes able to create their own tags. Following tags is provided by NexT:</p><a id=\"more\"></a><ul><li><a href=\"#Centered-Quote\">Centered Quote</a></li><li><a href=\"#Include-Raw\">Include Raw</a></li><li><a href=\"/docs/tag-plugins/button\">Button</a></li><li><a href=\"/docs/tag-plugins/full-image\">Full Image</a></li><li><a href=\"/docs/tag-plugins/group-pictures\">Group Pictures</a></li><li><a href=\"/docs/tag-plugins/label\">Label</a></li><li><a href=\"/docs/tag-plugins/mermaid\">Mermaid</a></li><li><a href=\"/docs/tag-plugins/note\">Note</a></li><li><a href=\"/docs/tag-plugins/pdf\">PDF</a></li><li><a href=\"/docs/tag-plugins/tabs\">Tabs</a></li><li><a href=\"/docs/tag-plugins/video\">Video</a></li></ul><h3 id=\"Centered-Quote\"><a href=\"#Centered-Quote\" class=\"headerlink\" title=\"Centered Quote\"></a>Centered Quote</h3><p>This tag will make a quote with two lines before and after it, and text quoted will be centered. When using centered quote, if we have multi-line text, and each line has a different length, the quote won’t be symmetrical, so it’s recommended to use when only have single line text. For example before article all after article to make a summary.</p><h4 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h4><figure class=\"highlight html\"><figcaption><span>center-quote.js</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% centerquote %&#125;Something&#123;% endcenterquote %&#125;</span><br><span class=\"line\"><span class=\"comment\">&lt;!-- Tag Alias --&gt;</span></span><br><span class=\"line\">&#123;% cq %&#125;Something&#123;% endcq %&#125;</span><br></pre></td></tr></table></figure><h4 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h4><figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% cq %&#125;Elegant in code, simple in core&#123;% endcq %&#125;</span><br></pre></td></tr></table></figure><blockquote class=\"blockquote-center\"><p>Elegant in code, simple in core</p></blockquote><h3 id=\"Include-Raw\"><a href=\"#Include-Raw\" class=\"headerlink\" title=\"Include Raw\"></a>Include Raw</h3><p>This tag include any raw content into your posts. Path is relative to your site source directory.</p><h4 id=\"Usage-1\"><a href=\"#Usage-1\" class=\"headerlink\" title=\"Usage\"></a>Usage</h4><figure class=\"highlight html\"><figcaption><span>include-raw.js</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% include_raw '_data/path/to/file.html' %&#125;</span><br></pre></td></tr></table></figure><h4 id=\"Example-1\"><a href=\"#Example-1\" class=\"headerlink\" title=\"Example\"></a>Example</h4><p>Let’s create <code>include-raw.html</code> file in <code>_data</code> directory under <span class=\"label info\">site root directory</span> with following content:</p><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Any <span class=\"tag\">&lt;<span class=\"name\">strong</span>&gt;</span>raw content<span class=\"tag\">&lt;/<span class=\"name\">strong</span>&gt;</span> may be included with this tag.</span><br></pre></td></tr></table></figure><p>Then in any post we can use this content with <code>include_raw</code> tag:</p><figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% include<span class=\"emphasis\">_raw '_</span>data/path/to/include-raw.html' %&#125;</span><br></pre></td></tr></table></figure>","slug":"Tag Plugins","updated":"2019-05-23T12:33:08.387Z","comments":true,"link":"","permalink":"https://shuntan.github.io/posts/e2e5eeac/","excerpt":"FAQWelcome to tag-pluginsTag Plugin is a way to make special style contents supported by Hexo. For example, we cannot show a image with custom size in standard Markdown. And then we can use tag plugins to solve it. Hexo has a lot of tags which can help user. And Hexo also have interfaces to themes which make themes able to create their own tags. Following tags is provided by NexT:","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://shuntan.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://shuntan.github.io/tags/Hexo/"},{"name":"Next","slug":"Next","permalink":"https://shuntan.github.io/tags/Next/"}]},{"title":"《辐射4》二次元萌妹MOD","date":"2019-05-06T15:03:34.000Z","path":"posts/8c023e79/","text":"《辐射4》二次元萌妹MOD补丁类型：游戏MOD整理时间：2019-05-05大小：18.73MB补丁制作：hiyokomod补丁语言：多国版本：v1.0download由N网作者“hiyokomod”制作的一款人物外观替换美化mod“二次元萌妹MOD”，将游戏中将游戏中多位女性NPC外观修改为二次元美少女，非常精致的面部建模和可修改项，带给每一个老冰棍！喜欢这些萌妹子就来3DM下载体验吧！截图注意事项需要下载“LooksMenu捏脸菜单==&gt;点我下载”。使用说明NMM自动安装方法：点我下载NMM1、添加压缩包到NMM(列表中出现)； 2、双击列表安装； 3、进入游戏即可。 **手动安装方法(不推荐)：** 1、解压缩； 2、将data文件夹复制到游戏根目录； 3、用MOD管理器加载ESP； 4、进入游戏中即可。 演示视频分流百度网盘(提取码：br93)本地电信网通高速下载电信下载联通下载","raw":"---\ntitle: 《辐射4》二次元萌妹MOD\ncopyright: true\ncategories:\n  - Mod\ntags:\n  - Games\n  - Pc\ntop: 100\ndescription: >-\n  由N网作者“hiyokomod”制作的一款人物外观替换美化mod“**二次元萌妹MOD**”，将游戏中将游戏中多位女性NPC外观修改为二次元美少女，非常精致的面部建模和可修改项，带给每一个老冰棍！喜欢这些萌妹子就来3DM下载体验吧！\nabbrlink: 8c023e79\ndate: 2019-05-06 23:03:34\ntype:\n---\n\n![](https://img.3dmgame.com/uploads/images/thumbkwdfirst/20180828/1535458637_329538.jpg)\n![](https://img.3dmgame.com/uploads/images/thumbkwdfirst/20180522/1526978780_509292.png)\n\n# 《辐射4》二次元萌妹MOD\n\n\n*   补丁类型：游戏MOD\n*   整理时间：2019-05-05\n*   大小：18.73MB\n*   补丁制作：hiyokomod\n*   补丁语言：多国\n*   版本：v1.0\n\n\n[download](http://id.ttz9.cn/thn/%E3%80%8A%E8%BE%90%E5%B0%844%E3%80%8B%E4%BA%8C%E6%AC%A1%E5%85%83%E8%90%8C%E5%A6%B9MOD_id371@371_2138610)\n\n{% cq %}\n由N网作者“hiyokomod”制作的一款人物外观替换美化mod“**二次元萌妹MOD**”，\n将游戏中将游戏中多位女性NPC外观修改为二次元美少女，非常精致的面部建模和可修改项，\n带给每一个老冰棍！喜欢这些萌妹子就来3DM下载体验吧！\n{% endcq %}\n\n<!-- more -->\n\n### 截图\n\n![《辐射4》二次元萌妹MOD](https://img.3dmgame.com/uploads/images/news/20190505/1557045450_376264.png) \n\n![《辐射4》二次元萌妹MOD](https://img.3dmgame.com/uploads/images/news/20190505/1557045450_327571.jpeg) \n\n![《辐射4》二次元萌妹MOD](https://img.3dmgame.com/uploads/images/news/20190505/1557045450_903130.jpeg) \n\n![《辐射4》二次元萌妹MOD](https://img.3dmgame.com/uploads/images/news/20190505/1557045450_319499.jpeg) \n\n![《辐射4》二次元萌妹MOD](https://img.3dmgame.com/uploads/images/news/20190505/1557045450_929840.jpeg) \n\n![《辐射4》二次元萌妹MOD](https://img.3dmgame.com/uploads/images/news/20190505/1557045450_553987.jpeg) \n\n![《辐射4》二次元萌妹MOD](https://img.3dmgame.com/uploads/images/news/20190505/1557045450_557348.jpeg) \n\n![《辐射4》二次元萌妹MOD](https://img.3dmgame.com/uploads/images/news/20190505/1557045450_140245.jpeg) \n\n![《辐射4》二次元萌妹MOD](https://img.3dmgame.com/uploads/images/news/20190505/1557045450_907658.jpeg) \n\n![《辐射4》二次元萌妹MOD](https://img.3dmgame.com/uploads/images/news/20190505/1557045450_261890.jpeg) \n\n### 注意事项\n\n需要下载“**<span style=\"color:#E53333;\">LooksMenu捏脸菜单</span>**==&gt;[点我下载](https://dl.3dmgame.com/patch/138611.html)”。\n\n### 使用说明\n\n**NMM自动安装方法：** \n[点我下载NMM](https://dl.3dmgame.com/patch/128998.html)\n\n\t1、添加压缩包到NMM(列表中出现)；\n\n\t2、双击列表安装；\n\n\t3、进入游戏即可。\n\n\t**手动安装方法(不推荐)：** \n\n\t1、解压缩；\n\n\t2、将data文件夹复制到游戏根目录；\n\n\t3、用MOD管理器加载ESP；\n\n\t4、进入游戏中即可。\n\n\n### 演示视频\n\n<iframe src=\"https://player.youku.com/embed/XNDE2Njc1OTM0MA==?client_id=5a73c0df8eb0d91d\" allowfullscreen=\"\" width=\"640\" height=\"480\" frameborder=\"0\">\n</iframe>\n\n<iframe src=\"https://player.youku.com/embed/XNDE2Njc2MjM2NA==?client_id=5a73c0df8eb0d91d\" allowfullscreen=\"\" width=\"640\" height=\"480\" frameborder=\"0\">\n</iframe>\n\n\n分流\n\n>[百度网盘(提取码：br93)](https://pan.baidu.com/s/1hYTBEc2DQbmP2k98JLSwkA)\n\n\n本地\n\n>[电信](http://dl1.cudown.com/buding/mod/3DMGAME-FO4AnimeRaceNanakochanmod.rar)\n[网通](http://dl1.cudown.com/buding/mod/3DMGAME-FO4AnimeRaceNanakochanmod.rar)\n\n>[高速下载](http://id.ttz9.cn/thn/%E3%80%8A%E8%BE%90%E5%B0%844%E3%80%8B%E4%BA%8C%E6%AC%A1%E5%85%83%E8%90%8C%E5%A6%B9MOD_id372@372_2138610)\n[电信下载](http://id.ttz9.cn/thn/%E3%80%8A%E8%BE%90%E5%B0%844%E3%80%8B%E4%BA%8C%E6%AC%A1%E5%85%83%E8%90%8C%E5%A6%B9MOD_id372@372_2138610)\n[联通下载](http://id.ttz9.cn/thn/%E3%80%8A%E8%BE%90%E5%B0%844%E3%80%8B%E4%BA%8C%E6%AC%A1%E5%85%83%E8%90%8C%E5%A6%B9MOD_id372@372_2138610)\n\n","content":"<p><img src=\"https://img.3dmgame.com/uploads/images/thumbkwdfirst/20180828/1535458637_329538.jpg\" alt=\"\"><br><img src=\"https://img.3dmgame.com/uploads/images/thumbkwdfirst/20180522/1526978780_509292.png\" alt=\"\"></p><h1 id=\"《辐射4》二次元萌妹MOD\"><a href=\"#《辐射4》二次元萌妹MOD\" class=\"headerlink\" title=\"《辐射4》二次元萌妹MOD\"></a>《辐射4》二次元萌妹MOD</h1><ul><li>补丁类型：游戏MOD</li><li>整理时间：2019-05-05</li><li>大小：18.73MB</li><li>补丁制作：hiyokomod</li><li>补丁语言：多国</li><li>版本：v1.0</li></ul><p><span class=\"exturl\" data-url=\"aHR0cDovL2lkLnR0ejkuY24vdGhuLyVFMyU4MCU4QSVFOCVCRSU5MCVFNSVCMCU4NDQlRTMlODAlOEIlRTQlQkElOEMlRTYlQUMlQTElRTUlODUlODMlRTglOTAlOEMlRTUlQTYlQjlNT0RfaWQzNzFAMzcxXzIxMzg2MTA=\" title=\"http://id.ttz9.cn/thn/%E3%80%8A%E8%BE%90%E5%B0%844%E3%80%8B%E4%BA%8C%E6%AC%A1%E5%85%83%E8%90%8C%E5%A6%B9MOD_id371@371_2138610\">download<i class=\"fa fa-external-link\"></i></span></p><blockquote class=\"blockquote-center\"><p>由N网作者“hiyokomod”制作的一款人物外观替换美化mod“<strong>二次元萌妹MOD</strong>”，<br>将游戏中将游戏中多位女性NPC外观修改为二次元美少女，非常精致的面部建模和可修改项，<br>带给每一个老冰棍！喜欢这些萌妹子就来3DM下载体验吧！</p></blockquote><a id=\"more\"></a><h3 id=\"截图\"><a href=\"#截图\" class=\"headerlink\" title=\"截图\"></a>截图</h3><p><img src=\"https://img.3dmgame.com/uploads/images/news/20190505/1557045450_376264.png\" alt=\"《辐射4》二次元萌妹MOD\"></p><p><img src=\"https://img.3dmgame.com/uploads/images/news/20190505/1557045450_327571.jpeg\" alt=\"《辐射4》二次元萌妹MOD\"></p><p><img src=\"https://img.3dmgame.com/uploads/images/news/20190505/1557045450_903130.jpeg\" alt=\"《辐射4》二次元萌妹MOD\"></p><p><img src=\"https://img.3dmgame.com/uploads/images/news/20190505/1557045450_319499.jpeg\" alt=\"《辐射4》二次元萌妹MOD\"></p><p><img src=\"https://img.3dmgame.com/uploads/images/news/20190505/1557045450_929840.jpeg\" alt=\"《辐射4》二次元萌妹MOD\"></p><p><img src=\"https://img.3dmgame.com/uploads/images/news/20190505/1557045450_553987.jpeg\" alt=\"《辐射4》二次元萌妹MOD\"></p><p><img src=\"https://img.3dmgame.com/uploads/images/news/20190505/1557045450_557348.jpeg\" alt=\"《辐射4》二次元萌妹MOD\"></p><p><img src=\"https://img.3dmgame.com/uploads/images/news/20190505/1557045450_140245.jpeg\" alt=\"《辐射4》二次元萌妹MOD\"></p><p><img src=\"https://img.3dmgame.com/uploads/images/news/20190505/1557045450_907658.jpeg\" alt=\"《辐射4》二次元萌妹MOD\"></p><p><img src=\"https://img.3dmgame.com/uploads/images/news/20190505/1557045450_261890.jpeg\" alt=\"《辐射4》二次元萌妹MOD\"></p><h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><p>需要下载“<strong><span style=\"color:#e53333\">LooksMenu捏脸菜单</span></strong>==&gt;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kbC4zZG1nYW1lLmNvbS9wYXRjaC8xMzg2MTEuaHRtbA==\" title=\"https://dl.3dmgame.com/patch/138611.html\">点我下载<i class=\"fa fa-external-link\"></i></span>”。</p><h3 id=\"使用说明\"><a href=\"#使用说明\" class=\"headerlink\" title=\"使用说明\"></a>使用说明</h3><p><strong>NMM自动安装方法：</strong><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kbC4zZG1nYW1lLmNvbS9wYXRjaC8xMjg5OTguaHRtbA==\" title=\"https://dl.3dmgame.com/patch/128998.html\">点我下载NMM<i class=\"fa fa-external-link\"></i></span></p><pre><code>1、添加压缩包到NMM(列表中出现)；\n\n2、双击列表安装；\n\n3、进入游戏即可。\n\n**手动安装方法(不推荐)：** \n\n1、解压缩；\n\n2、将data文件夹复制到游戏根目录；\n\n3、用MOD管理器加载ESP；\n\n4、进入游戏中即可。\n</code></pre><h3 id=\"演示视频\"><a href=\"#演示视频\" class=\"headerlink\" title=\"演示视频\"></a>演示视频</h3><iframe src=\"https://player.youku.com/embed/XNDE2Njc1OTM0MA==?client_id=5a73c0df8eb0d91d\" allowfullscreen width=\"640\" height=\"480\" frameborder=\"0\"><br></iframe><iframe src=\"https://player.youku.com/embed/XNDE2Njc2MjM2NA==?client_id=5a73c0df8eb0d91d\" allowfullscreen width=\"640\" height=\"480\" frameborder=\"0\"><br></iframe><p>分流</p><blockquote><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMWhZVEJFYzJEUWJtUDJrOThKTFN3a0E=\" title=\"https://pan.baidu.com/s/1hYTBEc2DQbmP2k98JLSwkA\">百度网盘(提取码：br93)<i class=\"fa fa-external-link\"></i></span></p></blockquote><p>本地</p><blockquote><p><span class=\"exturl\" data-url=\"aHR0cDovL2RsMS5jdWRvd24uY29tL2J1ZGluZy9tb2QvM0RNR0FNRS1GTzRBbmltZVJhY2VOYW5ha29jaGFubW9kLnJhcg==\" title=\"http://dl1.cudown.com/buding/mod/3DMGAME-FO4AnimeRaceNanakochanmod.rar\">电信<i class=\"fa fa-external-link\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cDovL2RsMS5jdWRvd24uY29tL2J1ZGluZy9tb2QvM0RNR0FNRS1GTzRBbmltZVJhY2VOYW5ha29jaGFubW9kLnJhcg==\" title=\"http://dl1.cudown.com/buding/mod/3DMGAME-FO4AnimeRaceNanakochanmod.rar\">网通<i class=\"fa fa-external-link\"></i></span></p></blockquote><blockquote><p><span class=\"exturl\" data-url=\"aHR0cDovL2lkLnR0ejkuY24vdGhuLyVFMyU4MCU4QSVFOCVCRSU5MCVFNSVCMCU4NDQlRTMlODAlOEIlRTQlQkElOEMlRTYlQUMlQTElRTUlODUlODMlRTglOTAlOEMlRTUlQTYlQjlNT0RfaWQzNzJAMzcyXzIxMzg2MTA=\" title=\"http://id.ttz9.cn/thn/%E3%80%8A%E8%BE%90%E5%B0%844%E3%80%8B%E4%BA%8C%E6%AC%A1%E5%85%83%E8%90%8C%E5%A6%B9MOD_id372@372_2138610\">高速下载<i class=\"fa fa-external-link\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cDovL2lkLnR0ejkuY24vdGhuLyVFMyU4MCU4QSVFOCVCRSU5MCVFNSVCMCU4NDQlRTMlODAlOEIlRTQlQkElOEMlRTYlQUMlQTElRTUlODUlODMlRTglOTAlOEMlRTUlQTYlQjlNT0RfaWQzNzJAMzcyXzIxMzg2MTA=\" title=\"http://id.ttz9.cn/thn/%E3%80%8A%E8%BE%90%E5%B0%844%E3%80%8B%E4%BA%8C%E6%AC%A1%E5%85%83%E8%90%8C%E5%A6%B9MOD_id372@372_2138610\">电信下载<i class=\"fa fa-external-link\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cDovL2lkLnR0ejkuY24vdGhuLyVFMyU4MCU4QSVFOCVCRSU5MCVFNSVCMCU4NDQlRTMlODAlOEIlRTQlQkElOEMlRTYlQUMlQTElRTUlODUlODMlRTglOTAlOEMlRTUlQTYlQjlNT0RfaWQzNzJAMzcyXzIxMzg2MTA=\" title=\"http://id.ttz9.cn/thn/%E3%80%8A%E8%BE%90%E5%B0%844%E3%80%8B%E4%BA%8C%E6%AC%A1%E5%85%83%E8%90%8C%E5%A6%B9MOD_id372@372_2138610\">联通下载<i class=\"fa fa-external-link\"></i></span></p></blockquote>","slug":"《辐射4》二次元萌妹MOD","updated":"2019-05-23T12:33:08.381Z","comments":true,"link":"","permalink":"https://shuntan.github.io/posts/8c023e79/","excerpt":"《辐射4》二次元萌妹MOD补丁类型：游戏MOD整理时间：2019-05-05大小：18.73MB补丁制作：hiyokomod补丁语言：多国版本：v1.0download由N网作者“hiyokomod”制作的一款人物外观替换美化mod“二次元萌妹MOD”，将游戏中将游戏中多位女性NPC外观修改为二次元美少女，非常精致的面部建模和可修改项，带给每一个老冰棍！喜欢这些萌妹子就来3DM下载体验吧！","categories":[{"name":"Mod","slug":"Mod","permalink":"https://shuntan.github.io/categories/Mod/"}],"tags":[{"name":"Games","slug":"Games","permalink":"https://shuntan.github.io/tags/Games/"},{"name":"Pc","slug":"Pc","permalink":"https://shuntan.github.io/tags/Pc/"}]},{"title":"给hexo博客next主题添加背景音乐","date":"2019-05-06T13:11:05.000Z","path":"posts/96f89d1/","text":"请访问我的个人博客 sourcod我的hexo博客使用的是next主题所有次教程在next主题上修改。修改 themes/next/layout/_macro/sidebar.swig 文件添加音乐播放器内容在 themes/next/_config.yml 配置文件中添加歌单地址配置background_music: //music.163.com/outchain/player?type=0&amp;amp;id=2120628564&amp;amp;auto=1&amp;amp;height=66注册网易云音乐自己研究创建歌单自己研究给歌单添加自己喜欢的音乐看你自己了分享歌单不会获取外链的请上度娘: 怎么把自己的歌单做成外链获取外链播放器把地址copy出来height=90改成 66这样以后只需要修改网易云音乐的歌单，博客的背景音乐就会自动修改了。如果出现音乐不自动播放，那是资源的问题，自己上网易云音乐生成外链的页面看看会不会自动播放。把坏资源删除就OK了。修改完我的博客的效果","raw":"---\ntitle: 给hexo博客next主题添加背景音乐\ncopyright: true\ncategories:\n  - Hexo教程\ntags:\n  - hexo\nabbrlink: 96f89d1\ndate: 2019-05-06 21:11:05\n---\n\n* 请访问我的个人博客 [sourcod](//blog.sourcod.com)\n\n> 我的hexo博客使用的是next主题所有次教程在next主题上修改。\n\n### 修改 `themes/next/layout/_macro/sidebar.swig` 文件\n\n添加音乐播放器内容 \n\n![sidebar](http://sourcod.oss-cn-beijing.aliyuncs.com/hexo/91fc7624571cb9276c6338b1c9913fa3.png)\n\n<!-- more -->\n\n### 在 `themes/next/_config.yml` 配置文件中添加歌单地址配置\n\n`background_music: //music.163.com/outchain/player?type=0&amp;id=2120628564&amp;auto=1&amp;height=66` \n\n![歌单地址配置](http://sourcod.oss-cn-beijing.aliyuncs.com/hexo/676e3e18fa9bdc5af7621bc471cc2895.png)\n\n### <a name=\"t2\"></a>注册网易云音乐\n\n自己研究\n\n### <a name=\"t3\"></a>创建歌单\n\n自己研究\n\n### <a name=\"t4\"></a>给歌单添加自己喜欢的音乐\n\n看你自己了\n\n### <a name=\"t5\"></a>分享歌单\n\n不会获取外链的请上度娘: [怎么把自己的歌单做成外链](https://jingyan.baidu.com/article/d7130635dcdf6813fdf475c7.html)\n\n### <a name=\"t6\"></a>获取外链播放器\n\n![外链播放器](http://sourcod.oss-cn-beijing.aliyuncs.com/hexo/3684d31ccbbb950e018b16113068a967.png)\n\n### <a name=\"t7\"></a>把地址copy出来`height=90`改成 `66`\n\n![外链](http://sourcod.oss-cn-beijing.aliyuncs.com/hexo/47f61ed64adaa3db93c0eceec989978e.png)\n\n> 这样以后只需要修改网易云音乐的歌单，博客的背景音乐就会自动修改了。\n> \n> 如果出现音乐不自动播放，那是资源的问题，自己上网易云音乐生成外链的页面看看会不会自动播放。把坏资源删除就OK了。\n\n* * *\n\n_修改完我的博客的效果_\n\n![博客效果](http://sourcod.oss-cn-beijing.aliyuncs.com/hexo/e10246452ccbc9a5eb5e2f2b8c5c70e7.png)","content":"<ul><li>请访问我的个人博客 <a href=\"//blog.sourcod.com\">sourcod</a></li></ul><blockquote><p>我的hexo博客使用的是next主题所有次教程在next主题上修改。</p></blockquote><h3 id=\"修改-themes-next-layout-macro-sidebar-swig-文件\"><a href=\"#修改-themes-next-layout-macro-sidebar-swig-文件\" class=\"headerlink\" title=\"修改 themes/next/layout/_macro/sidebar.swig 文件\"></a>修改 <code>themes/next/layout/_macro/sidebar.swig</code> 文件</h3><p>添加音乐播放器内容</p><p><img src=\"http://sourcod.oss-cn-beijing.aliyuncs.com/hexo/91fc7624571cb9276c6338b1c9913fa3.png\" alt=\"sidebar\"></p><a id=\"more\"></a><h3 id=\"在-themes-next-config-yml-配置文件中添加歌单地址配置\"><a href=\"#在-themes-next-config-yml-配置文件中添加歌单地址配置\" class=\"headerlink\" title=\"在 themes/next/_config.yml 配置文件中添加歌单地址配置\"></a>在 <code>themes/next/_config.yml</code> 配置文件中添加歌单地址配置</h3><p><code>background_music: //music.163.com/outchain/player?type=0&amp;amp;id=2120628564&amp;amp;auto=1&amp;amp;height=66</code></p><p><img src=\"http://sourcod.oss-cn-beijing.aliyuncs.com/hexo/676e3e18fa9bdc5af7621bc471cc2895.png\" alt=\"歌单地址配置\"></p><h3 id=\"注册网易云音乐\"><a href=\"#注册网易云音乐\" class=\"headerlink\" title=\"注册网易云音乐\"></a><a name=\"t2\"></a>注册网易云音乐</h3><p>自己研究</p><h3 id=\"创建歌单\"><a href=\"#创建歌单\" class=\"headerlink\" title=\"创建歌单\"></a><a name=\"t3\"></a>创建歌单</h3><p>自己研究</p><h3 id=\"给歌单添加自己喜欢的音乐\"><a href=\"#给歌单添加自己喜欢的音乐\" class=\"headerlink\" title=\"给歌单添加自己喜欢的音乐\"></a><a name=\"t4\"></a>给歌单添加自己喜欢的音乐</h3><p>看你自己了</p><h3 id=\"分享歌单\"><a href=\"#分享歌单\" class=\"headerlink\" title=\"分享歌单\"></a><a name=\"t5\"></a>分享歌单</h3><p>不会获取外链的请上度娘: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qaW5neWFuLmJhaWR1LmNvbS9hcnRpY2xlL2Q3MTMwNjM1ZGNkZjY4MTNmZGY0NzVjNy5odG1s\" title=\"https://jingyan.baidu.com/article/d7130635dcdf6813fdf475c7.html\">怎么把自己的歌单做成外链<i class=\"fa fa-external-link\"></i></span></p><h3 id=\"获取外链播放器\"><a href=\"#获取外链播放器\" class=\"headerlink\" title=\"获取外链播放器\"></a><a name=\"t6\"></a>获取外链播放器</h3><p><img src=\"http://sourcod.oss-cn-beijing.aliyuncs.com/hexo/3684d31ccbbb950e018b16113068a967.png\" alt=\"外链播放器\"></p><h3 id=\"把地址copy出来height-90改成-66\"><a href=\"#把地址copy出来height-90改成-66\" class=\"headerlink\" title=\"把地址copy出来height=90改成 66\"></a><a name=\"t7\"></a>把地址copy出来<code>height=90</code>改成 <code>66</code></h3><p><img src=\"http://sourcod.oss-cn-beijing.aliyuncs.com/hexo/47f61ed64adaa3db93c0eceec989978e.png\" alt=\"外链\"></p><blockquote><p>这样以后只需要修改网易云音乐的歌单，博客的背景音乐就会自动修改了。</p><p>如果出现音乐不自动播放，那是资源的问题，自己上网易云音乐生成外链的页面看看会不会自动播放。把坏资源删除就OK了。</p></blockquote><hr><p><em>修改完我的博客的效果</em></p><p><img src=\"http://sourcod.oss-cn-beijing.aliyuncs.com/hexo/e10246452ccbc9a5eb5e2f2b8c5c70e7.png\" alt=\"博客效果\"></p>","slug":"给hexo博客next主题添加背景音乐","updated":"2019-05-23T12:33:08.390Z","comments":true,"link":"","permalink":"https://shuntan.github.io/posts/96f89d1/","excerpt":"请访问我的个人博客 sourcod我的hexo博客使用的是next主题所有次教程在next主题上修改。修改 themes/next/layout/_macro/sidebar.swig 文件添加音乐播放器内容","categories":[{"name":"Hexo教程","slug":"Hexo教程","permalink":"https://shuntan.github.io/categories/Hexo教程/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://shuntan.github.io/tags/hexo/"}]},{"title":"问道","date":"2019-04-11T11:12:20.000Z","path":"posts/a3b6fe04/","text":"游戏背景介绍鸿蒙开化之初，中州大陆昆仑之颠的鸿钧上人创立道教，并收徒三人，各授以道门绝技，三徒皆修成混元大罗金仙万劫不坏之体，分别发展出道教的人道、阐教和截教三个分支。此三徒正是人道教主太上老君、阐教教主元始天尊和截教的通天教主。三教主秉承师父鸿钧上人教诲，广收门徒将道教流传于世。只因入道门中即可修仙，使人跳出三界之外，不在五行之中，免除生死轮回之苦，使得入道修行之人多不胜数。但修仙之道并非苦心修炼便可达成，修行路上，均要经历三百年一小劫，一千五百年一大劫的劫数。修行之人均无法避开劫数，只能根据自身道行的深浅去经历劫数。值商周两朝交替之时，恰逢修仙一千五百年仙劫，于是三教主共议封神榜，以观众仙根行浅深。然劫数难逃，封神一役，致使道门内部阐教和截教不和，修仙众人俱遭屠戮，更引来西方教派参与纷争，后因鸿钧上人亲自出面调停，终得以平息。通天教主被鸿钧上人禁制在紫霄宫昆仑之颠修行思过。时光如梭，转眼已过千年，师尊鸿钧上人外出云游，不知所踪。而通天仿佛已经习惯了这种被禁固的生活，除了每日的必做的修真炼气和静诵《黄庭》，他更多的时间总是在断崖边静静坐着。也许只有这个时刻，他才能真真实实地感觉到自己的存在，千年的苦行使他的修为倍增，同时也让他饱受了孤单和寂寞，他已经很久没有说过一句话了，很久是多久，他自己也不知道，他只知道他在等，他们都在等。.空旷的断崖边，一个人影伫立，良久，一动不动。山风劲袭，人犹如与山浑然一体，仍是一动不动，坚毅的面容毫无表情，只有明亮的双眸在黑夜印衬下寒光闪现，眺望着远方。远处，骷髅山顶，一块顽石好象动了一动，又动了一动，仿佛有了呼吸。慢慢地，顽石周围竟然忽隐忽现出着玄黄色的光芒，最终幻化为一个人形的光团，缓缓飘向山后的幽冥涧。此时，人影的苍白面容上浮现出奇怪的笑意，令人不寒而栗，他是通天。五百年后的中洲大陆。在东海渔村，世世代代以捕鱼为生的渔民有一天突然发现离他们村子不远的海面上，竟然出现一个异常美丽的仙岛。在天墉城，熙熙攘攘地街道上突然多了一些身着奇装奇服，行为举止十分可疑之人。在揽仙镇，一个平凡冷清的小镇上突然间热闹了起来，从四面八方赶来的俊男美女络绎不绝。本来平静的《问道》世界中出现各种异象和征兆，而此时，准备一探究竟的玩家，正赶往揽仙镇的途中。 [1]截图下载客户端下载登录器下载目前只提供1.60.0905版本客户端百度云下载链接🔗百度云密码(kq7m)与版本对应的登录器，服务器为公益服，不做任何盈利和不具备商业性质！链接：https://pan.baidu.com/s/1RN4VX3bOwH61xC70t82dMw提取码：**复制这段内容后打开百度网盘手机App，操作更方便哦更多资讯: Deployment","raw":"---\ntitle: 问道\ncopyright: true\npassword: 123\ncategories:\n  - PC\ntags:\n  - online\n  - game\nabbrlink: a3b6fe04\ndate: 2019-04-11 19:12:20\n---\n\n### 游戏背景介绍\n\n鸿蒙开化之初，中州大陆昆仑之颠的鸿钧上人创立道教，并收徒三人，各授以道门绝技，三徒皆修成混元大罗金仙万劫不坏之体，分别发展出道教的人道、阐教和截教三个分支。此三徒正是人道教主太上老君、阐教教主元始天尊和截教的通天教主。\n<!-- more -->\n三教主秉承师父鸿钧上人教诲，广收门徒将道教流传于世。只因入道门中即可修仙，使人跳出三界之外，不在五行之中，免除生死轮回之苦，使得入道修行之人多不胜数。但修仙之道并非苦心修炼便可达成，修行路上，均要经历三百年一小劫，一千五百年一大劫的劫数。修行之人均无法避开劫数，只能根据自身道行的深浅去经历劫数。值商周两朝交替之时，恰逢修仙一千五百年仙劫，于是三教主共议封神榜，以观众仙根行浅深。然劫数难逃，封神一役，致使道门内部阐教和截教不和，修仙众人俱遭屠戮，更引来西方教派参与纷争，后因鸿钧上人亲自出面调停，终得以平息。通天教主被鸿钧上人禁制在紫霄宫昆仑之颠修行思过。\n时光如梭，转眼已过千年，师尊鸿钧上人外出云游，不知所踪。而通天仿佛已经习惯了这种被禁固的生活，除了每日的必做的修真炼气和静诵《黄庭》，他更多的时间总是在断崖边静静坐着。也许只有这个时刻，他才能真真实实地感觉到自己的存在，千年的苦行使他的修为倍增，同时也让他饱受了孤单和寂寞，他已经很久没有说过一句话了，很久是多久，他自己也不知道，他只知道他在等，他们都在等。.\n空旷的断崖边，一个人影伫立，良久，一动不动。山风劲袭，人犹如与山浑然一体，仍是一动不动，坚毅的面容毫无表情，只有明亮的双眸在黑夜印衬下寒光闪现，眺望着远方。远处，骷髅山顶，一块顽石好象动了一动，又动了一动，仿佛有了呼吸。慢慢地，顽石周围竟然忽隐忽现出着玄黄色的光芒，最终幻化为一个人形的光团，缓缓飘向山后的幽冥涧。此时，人影的苍白面容上浮现出奇怪的笑意，令人不寒而栗，他是通天。\n五百年后的中洲大陆。\n在东海渔村，世世代代以捕鱼为生的渔民有一天突然发现离他们村子不远的海面上，竟然出现一个异常美丽的仙岛。\n在天墉城，熙熙攘攘地街道上突然多了一些身着奇装奇服，行为举止十分可疑之人。\n在揽仙镇，一个平凡冷清的小镇上突然间热闹了起来，从四面八方赶来的俊男美女络绎不绝。\n本来平静的《问道》世界中出现各种异象和征兆，而此时，准备一探究竟的玩家，正赶往揽仙镇的途中。 [1] \n\n### 截图\n![](问道/../261557566768_.pic_hd.jpg)\n\n### 下载\n{% tabs Fourth unique name %}\n<!-- tab 客户端下载 -->\n{% note success %}\n目前只提供1.60.0905版本客户端百度云下载链接🔗\n{% btn https://pan.baidu.com/s/1rsdS6oiuAxoYr5wXeZr22A, 百度云, edge, kq7m %}\n{% button #, 密码(kq7m) %}\n{% endnote %}\n<!-- endtab -->\n\n<!-- tab 登录器下载 -->\n{% note warning %}\n与版本对应的登录器，服务器为公益服，不做任何盈利和不具备商业性质！\n链接：https://pan.baidu.com/s/1RN4VX3bOwH61xC70t82dMw \n提取码：**** \n复制这段内容后打开百度网盘手机App，操作更方便哦\n\n<img src=\"问道/../281557578598_.pic_hd.jpg\" width = \"100px\" height = \"100px\" />\n{% endnote %}\n\n<!-- endtab -->\n{% endtabs %}\n\n\n更多资讯: [Deployment](https://hexo.io/docs/deployment.html)\n","content":"<h3 id=\"游戏背景介绍\"><a href=\"#游戏背景介绍\" class=\"headerlink\" title=\"游戏背景介绍\"></a>游戏背景介绍</h3><p>鸿蒙开化之初，中州大陆昆仑之颠的鸿钧上人创立道教，并收徒三人，各授以道门绝技，三徒皆修成混元大罗金仙万劫不坏之体，分别发展出道教的人道、阐教和截教三个分支。此三徒正是人道教主太上老君、阐教教主元始天尊和截教的通天教主。<br><a id=\"more\"></a><br>三教主秉承师父鸿钧上人教诲，广收门徒将道教流传于世。只因入道门中即可修仙，使人跳出三界之外，不在五行之中，免除生死轮回之苦，使得入道修行之人多不胜数。但修仙之道并非苦心修炼便可达成，修行路上，均要经历三百年一小劫，一千五百年一大劫的劫数。修行之人均无法避开劫数，只能根据自身道行的深浅去经历劫数。值商周两朝交替之时，恰逢修仙一千五百年仙劫，于是三教主共议封神榜，以观众仙根行浅深。然劫数难逃，封神一役，致使道门内部阐教和截教不和，修仙众人俱遭屠戮，更引来西方教派参与纷争，后因鸿钧上人亲自出面调停，终得以平息。通天教主被鸿钧上人禁制在紫霄宫昆仑之颠修行思过。<br>时光如梭，转眼已过千年，师尊鸿钧上人外出云游，不知所踪。而通天仿佛已经习惯了这种被禁固的生活，除了每日的必做的修真炼气和静诵《黄庭》，他更多的时间总是在断崖边静静坐着。也许只有这个时刻，他才能真真实实地感觉到自己的存在，千年的苦行使他的修为倍增，同时也让他饱受了孤单和寂寞，他已经很久没有说过一句话了，很久是多久，他自己也不知道，他只知道他在等，他们都在等。.<br>空旷的断崖边，一个人影伫立，良久，一动不动。山风劲袭，人犹如与山浑然一体，仍是一动不动，坚毅的面容毫无表情，只有明亮的双眸在黑夜印衬下寒光闪现，眺望着远方。远处，骷髅山顶，一块顽石好象动了一动，又动了一动，仿佛有了呼吸。慢慢地，顽石周围竟然忽隐忽现出着玄黄色的光芒，最终幻化为一个人形的光团，缓缓飘向山后的幽冥涧。此时，人影的苍白面容上浮现出奇怪的笑意，令人不寒而栗，他是通天。<br>五百年后的中洲大陆。<br>在东海渔村，世世代代以捕鱼为生的渔民有一天突然发现离他们村子不远的海面上，竟然出现一个异常美丽的仙岛。<br>在天墉城，熙熙攘攘地街道上突然多了一些身着奇装奇服，行为举止十分可疑之人。<br>在揽仙镇，一个平凡冷清的小镇上突然间热闹了起来，从四面八方赶来的俊男美女络绎不绝。<br>本来平静的《问道》世界中出现各种异象和征兆，而此时，准备一探究竟的玩家，正赶往揽仙镇的途中。 [1]</p><h3 id=\"截图\"><a href=\"#截图\" class=\"headerlink\" title=\"截图\"></a>截图</h3><p><img src=\"问道/../261557566768_.pic_hd.jpg\" alt=\"\"></p><h3 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h3><div class=\"tabs\" id=\"fourth-unique-name\"><ul class=\"nav-tabs\"><li class=\"tab active\"><a href=\"#fourth-unique-name-1\">客户端下载</a></li><li class=\"tab\"><a href=\"#fourth-unique-name-2\">登录器下载</a></li></ul><div class=\"tab-content\"><div class=\"tab-pane active\" id=\"fourth-unique-name-1\"><div class=\"note success\"><br><p>目前只提供1.60.0905版本客户端百度云下载链接🔗<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMXJzZFM2b2l1QXhvWXI1d1hlWnIyMkE=\" title=\"kq7m\"><i class=\"fa fa-edge\"></i>百度云<i class=\"fa fa-external-link\"></i></span><br><a class=\"btn\" href=\"#\">密码(kq7m)</a></p><br></div></div><div class=\"tab-pane\" id=\"fourth-unique-name-2\"><div class=\"note warning\"><br><p>与版本对应的登录器，服务器为公益服，不做任何盈利和不具备商业性质！<br>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMVJONFZYM2JPd0g2MXhDNzB0ODJkTXc=\" title=\"https://pan.baidu.com/s/1RN4VX3bOwH61xC70t82dMw\">https://pan.baidu.com/s/1RN4VX3bOwH61xC70t82dMw<i class=\"fa fa-external-link\"></i></span><br>提取码：<em>**</em><br>复制这段内容后打开百度网盘手机App，操作更方便哦</p><p><img src=\"问道/../281557578598_.pic_hd.jpg\" width=\"100px\" height=\"100px\"></p><br></div></div></div></div><p>更多资讯: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZGVwbG95bWVudC5odG1s\" title=\"https://hexo.io/docs/deployment.html\">Deployment<i class=\"fa fa-external-link\"></i></span></p>","slug":"问道","updated":"2019-05-23T12:33:08.384Z","comments":true,"link":"","permalink":"https://shuntan.github.io/posts/a3b6fe04/","excerpt":"游戏背景介绍鸿蒙开化之初，中州大陆昆仑之颠的鸿钧上人创立道教，并收徒三人，各授以道门绝技，三徒皆修成混元大罗金仙万劫不坏之体，分别发展出道教的人道、阐教和截教三个分支。此三徒正是人道教主太上老君、阐教教主元始天尊和截教的通天教主。","categories":[{"name":"PC","slug":"PC","permalink":"https://shuntan.github.io/categories/PC/"}],"tags":[{"name":"online","slug":"online","permalink":"https://shuntan.github.io/tags/online/"},{"name":"game","slug":"game","permalink":"https://shuntan.github.io/tags/game/"}]},{"title":"Hello World","date":"2018-10-24T14:19:55.904Z","path":"posts/4a17b156/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new \"My New Post\"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deploy更多资讯: Deployment","raw":"---\ntitle: Hello World\ncategories:\n  - Diary\ntags:\n  - Diary\nabbrlink: 4a17b156\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!--more-->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\n更多资讯: [Deployment](https://hexo.io/docs/deployment.html)\n","content":"<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\" title=\"https://hexo.io/\">Hexo<i class=\"fa fa-external-link\"></i></span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\" title=\"https://hexo.io/docs/\">documentation<i class=\"fa fa-external-link\"></i></span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\" title=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting<i class=\"fa fa-external-link\"></i></span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\" title=\"https://github.com/hexojs/hexo/issues\">GitHub<i class=\"fa fa-external-link\"></i></span>.</p><a id=\"more\"></a><h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\" title=\"https://hexo.io/docs/writing.html\">Writing<i class=\"fa fa-external-link\"></i></span></p><h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\" title=\"https://hexo.io/docs/server.html\">Server<i class=\"fa fa-external-link\"></i></span></p><h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\" title=\"https://hexo.io/docs/generating.html\">Generating<i class=\"fa fa-external-link\"></i></span></p><h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure><p>更多资讯: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZGVwbG95bWVudC5odG1s\" title=\"https://hexo.io/docs/deployment.html\">Deployment<i class=\"fa fa-external-link\"></i></span></p>","slug":"hello-world","updated":"2019-05-23T12:33:08.388Z","comments":true,"link":"","permalink":"https://shuntan.github.io/posts/4a17b156/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","categories":[{"name":"Diary","slug":"Diary","permalink":"https://shuntan.github.io/categories/Diary/"}],"tags":[{"name":"Diary","slug":"Diary","permalink":"https://shuntan.github.io/tags/Diary/"}]}]}